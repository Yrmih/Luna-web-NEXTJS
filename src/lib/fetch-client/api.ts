/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * SOLAR API
 * Solução Avançada em Atendimento de Refererência (SOLAR)
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = `${process.env.NEXT_PUBLIC_SOLAR_API_URL}`.replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Acao
 */
export interface Acao {
    /**
     * 
     * @type {number}
     * @memberof Acao
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Acao
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Acao
     */
    descricao?: string;
    /**
     * 
     * @type {string}
     * @memberof Acao
     */
    codigo_eproc?: string;
    /**
     * 
     * @type {string}
     * @memberof Acao
     */
    codigo_cnj?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Acao
     */
    judicial?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Acao
     */
    extrajudicial?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Acao
     */
    penal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Acao
     */
    inquerito?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Acao
     */
    acao_penal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Acao
     */
    execucao_penal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Acao
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Acao
     */
    area?: number;
}
/**
 * 
 * @export
 * @interface Acordo
 */
export interface Acordo {
    /**
     * 
     * @type {number}
     * @memberof Acordo
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Acordo
     */
    tipo?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Acordo
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Acordo
     */
    atendimento: number;
    /**
     * 
     * @type {number}
     * @memberof Acordo
     */
    termo?: number;
}
/**
 * 
 * @export
 * @interface Agenda
 */
export interface Agenda {
    /**
     * 
     * @type {number}
     * @memberof Agenda
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Agenda
     */
    titulo?: string;
    /**
     * 
     * @type {Generic}
     * @memberof Agenda
     */
    defensoria: Generic;
    /**
     * 
     * @type {string}
     * @memberof Agenda
     */
    data_inicial: string;
    /**
     * 
     * @type {string}
     * @memberof Agenda
     */
    data_final: string;
    /**
     * 
     * @type {Date}
     * @memberof Agenda
     */
    cadastrado_em: Date;
    /**
     * 
     * @type {Usuario}
     * @memberof Agenda
     */
    cadastrado_por: Usuario;
    /**
     * 
     * @type {Array<AgendaFilho>}
     * @memberof Agenda
     */
    filhos: Array<AgendaFilho>;
}
/**
 * 
 * @export
 * @interface AgendaDetail
 */
export interface AgendaDetail {
    /**
     * 
     * @type {number}
     * @memberof AgendaDetail
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AgendaDetail
     */
    titulo?: string;
    /**
     * 
     * @type {Generic}
     * @memberof AgendaDetail
     */
    defensoria: Generic;
    /**
     * 
     * @type {string}
     * @memberof AgendaDetail
     */
    data_inicial: string;
    /**
     * 
     * @type {string}
     * @memberof AgendaDetail
     */
    data_final: string;
    /**
     * 
     * @type {Date}
     * @memberof AgendaDetail
     */
    cadastrado_em: Date;
    /**
     * 
     * @type {Usuario}
     * @memberof AgendaDetail
     */
    cadastrado_por: Usuario;
    /**
     * 
     * @type {Array<AgendaFilhoDetail>}
     * @memberof AgendaDetail
     */
    filhos: Array<AgendaFilhoDetail>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgendaDetail
     */
    horarios: Array<string>;
}
/**
 * 
 * @export
 * @interface AgendaFilho
 */
export interface AgendaFilho {
    /**
     * 
     * @type {number}
     * @memberof AgendaFilho
     */
    id?: number;
    /**
     * 
     * @type {Generic}
     * @memberof AgendaFilho
     */
    defensoria: Generic;
}
/**
 * 
 * @export
 * @interface AgendaFilhoDetail
 */
export interface AgendaFilhoDetail {
    /**
     * 
     * @type {number}
     * @memberof AgendaFilhoDetail
     */
    id?: number;
    /**
     * 
     * @type {Generic}
     * @memberof AgendaFilhoDetail
     */
    defensoria: Generic;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgendaFilhoDetail
     */
    horarios: Array<string>;
}
/**
 * 
 * @export
 * @interface AlertaProcessoMovimento
 */
export interface AlertaProcessoMovimento {
    /**
     * 
     * @type {number}
     * @memberof AlertaProcessoMovimento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AlertaProcessoMovimento
     */
    mensagem?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertaProcessoMovimento
     */
    visualizado_por_nome?: string;
    /**
     * 
     * @type {Date}
     * @memberof AlertaProcessoMovimento
     */
    data_visualizado?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AlertaProcessoMovimento
     */
    visualizado?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof AlertaProcessoMovimento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AlertaProcessoMovimento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AlertaProcessoMovimento
     */
    honorario: number;
    /**
     * 
     * @type {number}
     * @memberof AlertaProcessoMovimento
     */
    visualizado_por?: number;
}
/**
 * 
 * @export
 * @interface Analise
 */
export interface Analise {
    /**
     * 
     * @type {number}
     * @memberof Analise
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Analise
     */
    motivo?: string;
    /**
     * 
     * @type {Date}
     * @memberof Analise
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Analise
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Analise
     */
    fase: number;
    /**
     * 
     * @type {number}
     * @memberof Analise
     */
    cadastrado_por?: number;
}
/**
 * 
 * @export
 * @interface Aprisionamento
 */
export interface Aprisionamento {
    /**
     * 
     * @type {number}
     * @memberof Aprisionamento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Aprisionamento
     */
    data_inicial: Date;
    /**
     * 
     * @type {Date}
     * @memberof Aprisionamento
     */
    data_final?: Date;
    /**
     * 
     * @type {number}
     * @memberof Aprisionamento
     */
    situacao?: number;
    /**
     * 
     * @type {string}
     * @memberof Aprisionamento
     */
    historico?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Aprisionamento
     */
    detracao?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof Aprisionamento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {number}
     * @memberof Aprisionamento
     */
    origem_cadastro?: number;
    /**
     * 
     * @type {Date}
     * @memberof Aprisionamento
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Aprisionamento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Aprisionamento
     */
    prisao: number;
    /**
     * 
     * @type {number}
     * @memberof Aprisionamento
     */
    estabelecimento_penal: number;
    /**
     * 
     * @type {number}
     * @memberof Aprisionamento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Aprisionamento
     */
    excluido_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Aprisionamento
     */
    eventos?: Array<number>;
}
/**
 * 
 * @export
 * @interface Area
 */
export interface Area {
    /**
     * 
     * @type {number}
     * @memberof Area
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof Area
     */
    penal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Area
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface Assunto
 */
export interface Assunto {
    /**
     * 
     * @type {number}
     * @memberof Assunto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Assunto
     */
    titulo: string;
    /**
     * 
     * @type {string}
     * @memberof Assunto
     */
    codigo?: string;
    /**
     * 
     * @type {number}
     * @memberof Assunto
     */
    ordem: number;
    /**
     * 
     * @type {Date}
     * @memberof Assunto
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Assunto
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {string}
     * @memberof Assunto
     */
    descricao?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Assunto
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Assunto
     */
    pai?: number;
    /**
     * 
     * @type {number}
     * @memberof Assunto
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Assunto
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface Atendimento
 */
export interface Atendimento {
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    numero?: number;
    /**
     * 
     * @type {string}
     * @memberof Atendimento
     */
    uuid?: string;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    tipo?: number;
    /**
     * 
     * @type {Date}
     * @memberof Atendimento
     */
    data_agendamento?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Atendimento
     */
    data_atendimento?: Date;
    /**
     * 
     * @type {string}
     * @memberof Atendimento
     */
    historico?: string;
    /**
     * 
     * @type {string}
     * @memberof Atendimento
     */
    historico_recepcao?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Atendimento
     */
    remarcado_auto?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Atendimento
     */
    prazo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Atendimento
     */
    exibir_no_painel_de_acompanhamento?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    prioridade?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    multiplicador?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    interesse_conciliacao?: number;
    /**
     * 
     * @type {string}
     * @memberof Atendimento
     */
    justificativa_nao_interesse?: string;
    /**
     * 
     * @type {Date}
     * @memberof Atendimento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Atendimento
     */
    data_cadastro_crc?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Atendimento
     */
    data_modificacao?: Date;
    /**
     * 
     * @type {string}
     * @memberof Atendimento
     */
    motivo_exclusao?: string;
    /**
     * 
     * @type {Date}
     * @memberof Atendimento
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Atendimento
     */
    ativo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Atendimento
     */
    oficio?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Atendimento
     */
    detalhes?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Atendimento
     */
    resposta_visualizada_por_atendente?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    agenda?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    agendado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    atendido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    inicial?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    origem?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    remarcado?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    nucleo?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    qualificacao?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    forma_atendimento?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    tipo_coletividade?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    tipo_motivo_exclusao?: number;
    /**
     * 
     * @type {number}
     * @memberof Atendimento
     */
    excluido_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Atendimento
     */
    assuntos?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Atendimento
     */
    participantes?: Array<number>;
}
/**
 * 
 * @export
 * @interface AtendimentoDocumento
 */
export interface AtendimentoDocumento {
    /**
     * 
     * @type {string}
     * @memberof AtendimentoDocumento
     */
    nome?: string;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoDocumento
     */
    arquivo?: string;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoDocumento
     */
    atendimento?: number;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoDocumento
     */
    enviado_por?: number;
}
/**
 * 
 * @export
 * @interface AtendimentoModeloDocumento
 */
export interface AtendimentoModeloDocumento {
    /**
     * 
     * @type {number}
     * @memberof AtendimentoModeloDocumento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoModeloDocumento
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoModeloDocumento
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoModeloDocumento
     */
    jasper_resource?: string;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoModeloDocumento
     */
    jasper_name?: string;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoModeloDocumento
     */
    jasper_params?: string;
    /**
     * 
     * @type {Date}
     * @memberof AtendimentoModeloDocumento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AtendimentoModeloDocumento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoModeloDocumento
     */
    ged_modelo?: number;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoModeloDocumento
     */
    cadastrado_por?: number;
}
/**
 * 
 * @export
 * @interface AtendimentoParticipante
 */
export interface AtendimentoParticipante {
    /**
     * 
     * @type {number}
     * @memberof AtendimentoParticipante
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoParticipante
     */
    atendimento: number;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoParticipante
     */
    servidor: number;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoParticipante
     */
    cargo?: number;
}
/**
 * 
 * @export
 * @interface AtendimentoRecepcao
 */
export interface AtendimentoRecepcao {
    /**
     * 
     * @type {number}
     * @memberof AtendimentoRecepcao
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoRecepcao
     */
    numero: number;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    tipo: string;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoRecepcao
     */
    tipo_id: number;
    /**
     * 
     * @type {ParteAtendimentoRecepcao}
     * @memberof AtendimentoRecepcao
     */
    requerente: ParteAtendimentoRecepcao;
    /**
     * 
     * @type {ParteAtendimentoRecepcao}
     * @memberof AtendimentoRecepcao
     */
    requerido: ParteAtendimentoRecepcao;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    area: string;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    pedido: string;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    horario: string;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    horario_atendimento: string;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    horario_atendimento_recepcao: string;
    /**
     * 
     * @type {boolean}
     * @memberof AtendimentoRecepcao
     */
    atrasado: boolean;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    historico_agendamento: string;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    historico_recepcao: string;
    /**
     * 
     * @type {boolean}
     * @memberof AtendimentoRecepcao
     */
    historico_atendimento: boolean;
    /**
     * 
     * @type {DefensoriaAtendimentoRecepcao}
     * @memberof AtendimentoRecepcao
     */
    defensoria: DefensoriaAtendimentoRecepcao;
    /**
     * 
     * @type {DefensorAtendimentoRecepcao}
     * @memberof AtendimentoRecepcao
     */
    defensor: DefensorAtendimentoRecepcao;
    /**
     * 
     * @type {DefensorAtendimentoRecepcao}
     * @memberof AtendimentoRecepcao
     */
    substituto: DefensorAtendimentoRecepcao;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoRecepcao
     */
    guiche: number;
    /**
     * 
     * @type {boolean}
     * @memberof AtendimentoRecepcao
     */
    extra: boolean;
    /**
     * 
     * @type {string}
     * @memberof AtendimentoRecepcao
     */
    agenda: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AtendimentoRecepcao
     */
    telefones: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof AtendimentoRecepcao
     */
    prazo: boolean;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoRecepcao
     */
    prioridade: number;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoRecepcao
     */
    atividades: number;
    /**
     * 
     * @type {boolean}
     * @memberof AtendimentoRecepcao
     */
    apoio: boolean;
    /**
     * 
     * @type {EmAtendimentoRecepcao}
     * @memberof AtendimentoRecepcao
     */
    em_atendimento: EmAtendimentoRecepcao;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoRecepcao
     */
    forma_atendimento: number;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoRecepcao
     */
    status: number;
}
/**
 * 
 * @export
 * @interface AtendimentoTotalSerializar
 */
export interface AtendimentoTotalSerializar {
    /**
     * 
     * @type {string}
     * @memberof AtendimentoTotalSerializar
     */
    tipo?: string;
    /**
     * 
     * @type {number}
     * @memberof AtendimentoTotalSerializar
     */
    quantidade: number;
}
/**
 * 
 * @export
 * @interface AtividadeExtraordinaria
 */
export interface AtividadeExtraordinaria {
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof AtividadeExtraordinaria
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtividadeExtraordinaria
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtividadeExtraordinaria
     */
    desativado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtividadeExtraordinaria
     */
    data_referencia?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtividadeExtraordinaria
     */
    encerrado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    numero?: number;
    /**
     * 
     * @type {string}
     * @memberof AtividadeExtraordinaria
     */
    titulo?: string;
    /**
     * 
     * @type {string}
     * @memberof AtividadeExtraordinaria
     */
    historico?: string;
    /**
     * 
     * @type {string}
     * @memberof AtividadeExtraordinaria
     */
    complemento?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AtividadeExtraordinaria
     */
    em_edicao?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    processo?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    parte?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    tipo: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    setor_criacao: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    setor_encaminhado?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    encerrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinaria
     */
    area?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AtividadeExtraordinaria
     */
    participantes?: Array<number>;
}
/**
 * 
 * @export
 * @interface AtividadeExtraordinariaTipo
 */
export interface AtividadeExtraordinariaTipo {
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinariaTipo
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof AtividadeExtraordinariaTipo
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtividadeExtraordinariaTipo
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtividadeExtraordinariaTipo
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinariaTipo
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinariaTipo
     */
    tipo_processo?: number;
    /**
     * 
     * @type {string}
     * @memberof AtividadeExtraordinariaTipo
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof AtividadeExtraordinariaTipo
     */
    nome_norm: string;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinariaTipo
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinariaTipo
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof AtividadeExtraordinariaTipo
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface Atuacao
 */
export interface Atuacao {
    /**
     * 
     * @type {number}
     * @memberof Atuacao
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Atuacao
     */
    data_inicial: Date;
    /**
     * 
     * @type {Date}
     * @memberof Atuacao
     */
    data_final: Date;
    /**
     * 
     * @type {Generic}
     * @memberof Atuacao
     */
    defensoria: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof Atuacao
     */
    defensor: Generic;
    /**
     * 
     * @type {number}
     * @memberof Atuacao
     */
    usuario?: number;
    /**
     * 
     * @type {Generic}
     * @memberof Atuacao
     */
    titular: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof Atuacao
     */
    cargo: Generic;
    /**
     * 
     * @type {AtuacaoDocumento}
     * @memberof Atuacao
     */
    documento: AtuacaoDocumento;
    /**
     * 
     * @type {ServidorBasic}
     * @memberof Atuacao
     */
    cadastrado_por: ServidorBasic;
    /**
     * 
     * @type {ServidorBasic}
     * @memberof Atuacao
     */
    excluido_por: ServidorBasic;
    /**
     * 
     * @type {Date}
     * @memberof Atuacao
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Atuacao
     */
    data_atualizacao?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Atuacao
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {number}
     * @memberof Atuacao
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof Atuacao
     */
    observacao?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Atuacao
     */
    designacao_extraordinaria?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Atuacao
     */
    ativo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Atuacao
     */
    codigo_athenas?: string;
    /**
     * 
     * @type {string}
     * @memberof Atuacao
     */
    codigo_plantao?: string;
    /**
     * 
     * @type {string}
     * @memberof Atuacao
     */
    codigo_plantao_local?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Atuacao
     */
    foi_enviado_email_plantao?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Atuacao
     */
    pode_assinar_ged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Atuacao
     */
    habilitado_chat_edefensor?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Atuacao
     */
    visualiza_chat_edefensor?: boolean;
}
/**
 * 
 * @export
 * @interface AtuacaoCreate
 */
export interface AtuacaoCreate {
    /**
     * 
     * @type {number}
     * @memberof AtuacaoCreate
     */
    id?: number;
    /**
     * 
     * @type {Generic}
     * @memberof AtuacaoCreate
     */
    defensor?: Generic;
    /**
     * 
     * @type {Date}
     * @memberof AtuacaoCreate
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtuacaoCreate
     */
    data_atualizacao?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtuacaoCreate
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoCreate
     */
    tipo?: number;
    /**
     * 
     * @type {Date}
     * @memberof AtuacaoCreate
     */
    data_inicial: Date;
    /**
     * 
     * @type {Date}
     * @memberof AtuacaoCreate
     */
    data_final?: Date;
    /**
     * 
     * @type {string}
     * @memberof AtuacaoCreate
     */
    observacao?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AtuacaoCreate
     */
    designacao_extraordinaria?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AtuacaoCreate
     */
    ativo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AtuacaoCreate
     */
    codigo_athenas?: string;
    /**
     * 
     * @type {string}
     * @memberof AtuacaoCreate
     */
    codigo_plantao?: string;
    /**
     * 
     * @type {string}
     * @memberof AtuacaoCreate
     */
    codigo_plantao_local?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AtuacaoCreate
     */
    foi_enviado_email_plantao?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AtuacaoCreate
     */
    pode_assinar_ged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AtuacaoCreate
     */
    habilitado_chat_edefensor?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AtuacaoCreate
     */
    visualiza_chat_edefensor?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoCreate
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoCreate
     */
    excluido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoCreate
     */
    defensoria: number;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoCreate
     */
    titular?: number;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoCreate
     */
    documento?: number;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoCreate
     */
    cargo?: number;
}
/**
 * 
 * @export
 * @interface AtuacaoDocumento
 */
export interface AtuacaoDocumento {
    /**
     * 
     * @type {number}
     * @memberof AtuacaoDocumento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AtuacaoDocumento
     */
    tipo_str?: string;
    /**
     * 
     * @type {string}
     * @memberof AtuacaoDocumento
     */
    numero: string;
    /**
     * 
     * @type {Date}
     * @memberof AtuacaoDocumento
     */
    data: Date;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoDocumento
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof AtuacaoDocumento
     */
    doe_numero?: number;
    /**
     * 
     * @type {Date}
     * @memberof AtuacaoDocumento
     */
    doe_data?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AtuacaoDocumento
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface Atualizacao
 */
export interface Atualizacao {
    /**
     * 
     * @type {number}
     * @memberof Atualizacao
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Atualizacao
     */
    tipo: number;
    /**
     * 
     * @type {Date}
     * @memberof Atualizacao
     */
    data: Date;
    /**
     * 
     * @type {string}
     * @memberof Atualizacao
     */
    texto: string;
    /**
     * 
     * @type {boolean}
     * @memberof Atualizacao
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface Audiencia
 */
export interface Audiencia {
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Audiencia
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Audiencia
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Audiencia
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {string}
     * @memberof Audiencia
     */
    descricao?: string;
    /**
     * 
     * @type {Date}
     * @memberof Audiencia
     */
    data_protocolo?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Audiencia
     */
    data_termino_protocolo?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Audiencia
     */
    ativo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Audiencia
     */
    automatico?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    atividade?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Audiencia
     */
    plantao?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    evento_eproc?: number;
    /**
     * 
     * @type {string}
     * @memberof Audiencia
     */
    usuario_eproc?: string;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    audiencia_status?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Audiencia
     */
    audiencia_realizada?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    custodia?: number;
    /**
     * 
     * @type {Date}
     * @memberof Audiencia
     */
    data_baixa?: Date;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    excluido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    processo: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    parte?: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    defensoria?: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    defensor_cadastro?: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    defensor_substituto?: number;
    /**
     * 
     * @type {number}
     * @memberof Audiencia
     */
    baixado_por?: number;
}
/**
 * 
 * @export
 * @interface AudienciaTotal
 */
export interface AudienciaTotal {
    /**
     * 
     * @type {string}
     * @memberof AudienciaTotal
     */
    tipo?: string;
    /**
     * 
     * @type {number}
     * @memberof AudienciaTotal
     */
    quantidade: number;
}
/**
 * 
 * @export
 * @interface Bairro
 */
export interface Bairro {
    /**
     * 
     * @type {number}
     * @memberof Bairro
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Bairro
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof Bairro
     */
    municipio?: number;
}
/**
 * 
 * @export
 * @interface CEP
 */
export interface CEP {
    /**
     * 
     * @type {number}
     * @memberof CEP
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof CEP
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CEP
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CEP
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof CEP
     */
    cep: string;
    /**
     * 
     * @type {string}
     * @memberof CEP
     */
    logradouro?: string;
    /**
     * 
     * @type {string}
     * @memberof CEP
     */
    complemento?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CEP
     */
    eh_geral?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CEP
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CEP
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CEP
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CEP
     */
    municipio?: number;
    /**
     * 
     * @type {number}
     * @memberof CEP
     */
    bairro?: number;
}
/**
 * 
 * @export
 * @interface CalculoExecucaoPenal
 */
export interface CalculoExecucaoPenal {
    /**
     * 
     * @type {number}
     * @memberof CalculoExecucaoPenal
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    pessoa_nome: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    execucao_numero: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    estabelecimento_penal_nome: string;
    /**
     * 
     * @type {number}
     * @memberof CalculoExecucaoPenal
     */
    regime_atual: number;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    data_base: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    data_progressao: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    data_livramento: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    data_termino: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    total_pena: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    total_detracoes: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    total_interrupcoes: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    total_remissoes: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    pena_cumprida_data_base: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    pena_cumprida_data_registro: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    pena_restante_data_base: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    pena_restante_data_registro: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    data_atualizacao: string;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    atualizado_por_nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof CalculoExecucaoPenal
     */
    ativo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CalculoExecucaoPenal
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof CalculoExecucaoPenal
     */
    execucao: number;
    /**
     * 
     * @type {number}
     * @memberof CalculoExecucaoPenal
     */
    estabelecimento_penal: number;
    /**
     * 
     * @type {number}
     * @memberof CalculoExecucaoPenal
     */
    atualizado_por: number;
}
/**
 * 
 * @export
 * @interface Cargo
 */
export interface Cargo {
    /**
     * 
     * @type {number}
     * @memberof Cargo
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Cargo
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Cargo
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Cargo
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Cargo
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Cargo
     */
    nome_norm: string;
    /**
     * 
     * @type {string}
     * @memberof Cargo
     */
    codigo: string;
    /**
     * 
     * @type {number}
     * @memberof Cargo
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Cargo
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Cargo
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface CategoriaDeAgenda
 */
export interface CategoriaDeAgenda {
    /**
     * 
     * @type {number}
     * @memberof CategoriaDeAgenda
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoriaDeAgenda
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof CategoriaDeAgenda
     */
    sigla?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CategoriaDeAgenda
     */
    eh_categoria_crc?: boolean;
}
/**
 * 
 * @export
 * @interface Classe
 */
export interface Classe {
    /**
     * 
     * @type {number}
     * @memberof Classe
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Classe
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Classe
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Classe
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof Classe
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof Classe
     */
    tipo_processo?: number;
    /**
     * 
     * @type {string}
     * @memberof Classe
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Classe
     */
    nome_norm: string;
    /**
     * 
     * @type {number}
     * @memberof Classe
     */
    indeferimento_pode_registrar_recurso?: number;
    /**
     * 
     * @type {number}
     * @memberof Classe
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Classe
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Classe
     */
    desativado_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Classe
     */
    modelos_documentos?: Array<number>;
}
/**
 * 
 * @export
 * @interface Coletivo
 */
export interface Coletivo {
    /**
     * 
     * @type {number}
     * @memberof Coletivo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Coletivo
     */
    propac: string;
    /**
     * 
     * @type {number}
     * @memberof Coletivo
     */
    atendimento: number;
    /**
     * 
     * @type {number}
     * @memberof Coletivo
     */
    comunidade?: number;
}
/**
 * 
 * @export
 * @interface Comarca
 */
export interface Comarca {
    /**
     * 
     * @type {number}
     * @memberof Comarca
     */
    id?: number;
    /**
     * 
     * @type {Array<Generic>}
     * @memberof Comarca
     */
    filhos?: Array<Generic>;
    /**
     * 
     * @type {Date}
     * @memberof Comarca
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Comarca
     */
    data_atualizacao?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Comarca
     */
    data_implantacao?: Date;
    /**
     * 
     * @type {string}
     * @memberof Comarca
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Comarca
     */
    codigo?: string;
    /**
     * 
     * @type {string}
     * @memberof Comarca
     */
    codigo_eproc?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Comarca
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Comarca
     */
    coordenadoria?: number;
}
/**
 * 
 * @export
 * @interface ComarcaBasic
 */
export interface ComarcaBasic {
    /**
     * 
     * @type {number}
     * @memberof ComarcaBasic
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ComarcaBasic
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof ComarcaBasic
     */
    coordenadoria?: number;
}
/**
 * 
 * @export
 * @interface ContribDocumento
 */
export interface ContribDocumento {
    /**
     * 
     * @type {number}
     * @memberof ContribDocumento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ContribDocumento
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContribDocumento
     */
    exibir_em_documento_assistido?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContribDocumento
     */
    exibir_em_documento_atendimento?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContribDocumento
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface ContribEndereco
 */
export interface ContribEndereco {
    /**
     * 
     * @type {number}
     * @memberof ContribEndereco
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ContribEndereco
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ContribEndereco
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ContribEndereco
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof ContribEndereco
     */
    logradouro?: string;
    /**
     * 
     * @type {string}
     * @memberof ContribEndereco
     */
    numero?: string;
    /**
     * 
     * @type {string}
     * @memberof ContribEndereco
     */
    complemento?: string;
    /**
     * 
     * @type {string}
     * @memberof ContribEndereco
     */
    cep?: string;
    /**
     * 
     * @type {number}
     * @memberof ContribEndereco
     */
    tipo_area?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ContribEndereco
     */
    principal?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ContribEndereco
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof ContribEndereco
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ContribEndereco
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ContribEndereco
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ContribEndereco
     */
    bairro?: number;
    /**
     * 
     * @type {number}
     * @memberof ContribEndereco
     */
    municipio: number;
}
/**
 * 
 * @export
 * @interface ContribTelefone
 */
export interface ContribTelefone {
    /**
     * 
     * @type {number}
     * @memberof ContribTelefone
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ContribTelefone
     */
    ddd?: number;
    /**
     * 
     * @type {string}
     * @memberof ContribTelefone
     */
    numero: string;
    /**
     * 
     * @type {number}
     * @memberof ContribTelefone
     */
    tipo: number;
    /**
     * 
     * @type {string}
     * @memberof ContribTelefone
     */
    nome?: string;
}
/**
 * 
 * @export
 * @interface ContribUser
 */
export interface ContribUser {
    /**
     * 
     * @type {number}
     * @memberof ContribUser
     */
    id?: number;
    /**
     * Obrigatório. 150 caracteres ou menos. Letras, números e @/./+/-/_ apenas.
     * @type {string}
     * @memberof ContribUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof ContribUser
     */
    email?: string;
    /**
     * Indica que este usuário tem todas as permissões sem atribuí-las explicitamente.
     * @type {boolean}
     * @memberof ContribUser
     */
    is_superuser?: boolean;
}
/**
 * 
 * @export
 * @interface CoreDocumento
 */
export interface CoreDocumento {
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof CoreDocumento
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreDocumento
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreDocumento
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof CoreDocumento
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof CoreDocumento
     */
    arquivo?: string;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    nivel_sigilo?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    processo?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    evento: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    parte?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    tipo: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    modelo?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreDocumento
     */
    documento?: number;
}
/**
 * 
 * @export
 * @interface CoreEvento
 */
export interface CoreEvento {
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof CoreEvento
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreEvento
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreEvento
     */
    desativado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreEvento
     */
    data_referencia?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreEvento
     */
    encerrado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    numero?: number;
    /**
     * 
     * @type {string}
     * @memberof CoreEvento
     */
    titulo?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreEvento
     */
    historico?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreEvento
     */
    complemento?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CoreEvento
     */
    em_edicao?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    processo?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    parte?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    tipo: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    setor_criacao: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    setor_encaminhado?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    encerrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreEvento
     */
    area?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CoreEvento
     */
    participantes?: Array<number>;
}
/**
 * 
 * @export
 * @interface CoreModeloDocumento
 */
export interface CoreModeloDocumento {
    /**
     * 
     * @type {number}
     * @memberof CoreModeloDocumento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof CoreModeloDocumento
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreModeloDocumento
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreModeloDocumento
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof CoreModeloDocumento
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof CoreModeloDocumento
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof CoreModeloDocumento
     */
    jasper_resource?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreModeloDocumento
     */
    jasper_name?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreModeloDocumento
     */
    jasper_params?: string;
    /**
     * 
     * @type {number}
     * @memberof CoreModeloDocumento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreModeloDocumento
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreModeloDocumento
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreModeloDocumento
     */
    tipo_documento: number;
    /**
     * 
     * @type {number}
     * @memberof CoreModeloDocumento
     */
    ged_modelo?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreModeloDocumento
     */
    formulario_modelo?: number;
}
/**
 * 
 * @export
 * @interface CoreProcesso
 */
export interface CoreProcesso {
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof CoreProcesso
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreProcesso
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CoreProcesso
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof CoreProcesso
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof CoreProcesso
     */
    numero?: string;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    situacao?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    tipo: number;
    /**
     * 
     * @type {Date}
     * @memberof CoreProcesso
     */
    baixado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    setor_criacao: number;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    setor_atual: number;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    setor_encaminhado?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    classe?: number;
    /**
     * 
     * @type {number}
     * @memberof CoreProcesso
     */
    baixado_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CoreProcesso
     */
    setores_notificados?: Array<number>;
}
/**
 * 
 * @export
 * @interface CustomAuthToken
 */
export interface CustomAuthToken {
    /**
     * 
     * @type {string}
     * @memberof CustomAuthToken
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAuthToken
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof CustomAuthToken
     */
    token?: string;
    /**
     * 
     * @type {Usuario}
     * @memberof CustomAuthToken
     */
    user?: Usuario;
}
/**
 * 
 * @export
 * @interface CustomTokenObtainPair
 */
export interface CustomTokenObtainPair {
    /**
     * 
     * @type {Usuario}
     * @memberof CustomTokenObtainPair
     */
    user?: Usuario;
    /**
     * 
     * @type {string}
     * @memberof CustomTokenObtainPair
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTokenObtainPair
     */
    password: string;
}
/**
 * 
 * @export
 * @interface Defensor
 */
export interface Defensor {
    /**
     * 
     * @type {number}
     * @memberof Defensor
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Defensor
     */
    nome?: string;
    /**
     * 
     * @type {string}
     * @memberof Defensor
     */
    cpf: string;
    /**
     * 
     * @type {number}
     * @memberof Defensor
     */
    servidor: number;
    /**
     * 
     * @type {string}
     * @memberof Defensor
     */
    usuario?: string;
    /**
     * 
     * @type {number}
     * @memberof Defensor
     */
    supervisor?: number;
    /**
     * 
     * @type {Array<DefensorAtuacao>}
     * @memberof Defensor
     */
    atuacoes?: Array<DefensorAtuacao>;
    /**
     * 
     * @type {Date}
     * @memberof Defensor
     */
    data_expiracao_credenciais_mni?: Date;
    /**
     * 
     * @type {string}
     * @memberof Defensor
     */
    credenciais_expiradas?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Defensor
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface DefensorAtendimentoRecepcao
 */
export interface DefensorAtendimentoRecepcao {
    /**
     * 
     * @type {string}
     * @memberof DefensorAtendimentoRecepcao
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof DefensorAtendimentoRecepcao
     */
    username: string;
}
/**
 * 
 * @export
 * @interface DefensorAtuacao
 */
export interface DefensorAtuacao {
    /**
     * 
     * @type {number}
     * @memberof DefensorAtuacao
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensorAtuacao
     */
    tipo?: number;
    /**
     * 
     * @type {Date}
     * @memberof DefensorAtuacao
     */
    data_inicial: Date;
    /**
     * 
     * @type {Date}
     * @memberof DefensorAtuacao
     */
    data_final: Date;
    /**
     * 
     * @type {Generic}
     * @memberof DefensorAtuacao
     */
    defensoria: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof DefensorAtuacao
     */
    titular: Generic;
    /**
     * 
     * @type {AtuacaoDocumento}
     * @memberof DefensorAtuacao
     */
    documento: AtuacaoDocumento;
}
/**
 * 
 * @export
 * @interface DefensorDocumento
 */
export interface DefensorDocumento {
    /**
     * 
     * @type {number}
     * @memberof DefensorDocumento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DefensorDocumento
     */
    arquivo?: string;
    /**
     * 
     * @type {string}
     * @memberof DefensorDocumento
     */
    nome?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DefensorDocumento
     */
    ativo?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof DefensorDocumento
     */
    data_enviado?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DefensorDocumento
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {number}
     * @memberof DefensorDocumento
     */
    pessoa: number;
    /**
     * 
     * @type {number}
     * @memberof DefensorDocumento
     */
    documento?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensorDocumento
     */
    enviado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensorDocumento
     */
    excluido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensorDocumento
     */
    documento_assinado?: number;
}
/**
 * 
 * @export
 * @interface Defensoria
 */
export interface Defensoria {
    /**
     * 
     * @type {number}
     * @memberof Defensoria
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Defensoria
     */
    codigo?: string;
    /**
     * 
     * @type {string}
     * @memberof Defensoria
     */
    nome: string;
    /**
     * 
     * @type {ComarcaBasic}
     * @memberof Defensoria
     */
    comarca: ComarcaBasic;
    /**
     * 
     * @type {number}
     * @memberof Defensoria
     */
    grau?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Defensoria
     */
    pode_vincular_processo_judicial?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Defensoria
     */
    atuacao?: string;
    /**
     * 
     * @type {Array<DefensoriaAtuacao>}
     * @memberof Defensoria
     */
    atuacoes?: Array<DefensoriaAtuacao>;
    /**
     * 
     * @type {Array<Generic>}
     * @memberof Defensoria
     */
    categorias_de_agendas?: Array<Generic>;
    /**
     * 
     * @type {Nucleo}
     * @memberof Defensoria
     */
    nucleo: Nucleo;
    /**
     * 
     * @type {Array<number>}
     * @memberof Defensoria
     */
    tipos_eventos?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Defensoria
     */
    telefone?: string;
    /**
     * 
     * @type {string}
     * @memberof Defensoria
     */
    email?: string;
    /**
     * Para utilizar formatação, utilize tags HTML
     * @type {string}
     * @memberof Defensoria
     */
    cabecalho_documento?: string;
    /**
     * Para utilizar formatação, utilize tags HTML
     * @type {string}
     * @memberof Defensoria
     */
    rodape_documento?: string;
    /**
     * 
     * @type {Predio}
     * @memberof Defensoria
     */
    predio: Predio;
}
/**
 * 
 * @export
 * @interface DefensoriaAtendimentoRecepcao
 */
export interface DefensoriaAtendimentoRecepcao {
    /**
     * 
     * @type {number}
     * @memberof DefensoriaAtendimentoRecepcao
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof DefensoriaAtendimentoRecepcao
     */
    codigo: string;
    /**
     * 
     * @type {string}
     * @memberof DefensoriaAtendimentoRecepcao
     */
    nome: string;
}
/**
 * 
 * @export
 * @interface DefensoriaAtuacao
 */
export interface DefensoriaAtuacao {
    /**
     * 
     * @type {number}
     * @memberof DefensoriaAtuacao
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaAtuacao
     */
    tipo?: number;
    /**
     * 
     * @type {Date}
     * @memberof DefensoriaAtuacao
     */
    data_inicial: Date;
    /**
     * 
     * @type {Date}
     * @memberof DefensoriaAtuacao
     */
    data_final?: Date;
    /**
     * 
     * @type {Generic}
     * @memberof DefensoriaAtuacao
     */
    defensor: Generic;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaAtuacao
     */
    titular?: number;
    /**
     * 
     * @type {AtuacaoDocumento}
     * @memberof DefensoriaAtuacao
     */
    documento: AtuacaoDocumento;
}
/**
 * 
 * @export
 * @interface DefensoriaTipoEvento
 */
export interface DefensoriaTipoEvento {
    /**
     * 
     * @type {number}
     * @memberof DefensoriaTipoEvento
     */
    id?: number;
    /**
     * Conta Estatísticas?
     * @type {boolean}
     * @memberof DefensoriaTipoEvento
     */
    conta_estatistica?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaTipoEvento
     */
    defensoria: number;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaTipoEvento
     */
    tipo_evento: number;
}
/**
 * 
 * @export
 * @interface DefensoriaVara
 */
export interface DefensoriaVara {
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVara
     */
    id?: number;
    /**
     * 
     * @type {Generic}
     * @memberof DefensoriaVara
     */
    defensoria: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof DefensoriaVara
     */
    vara: Generic;
    /**
     * 
     * @type {ContribUser}
     * @memberof DefensoriaVara
     */
    cadastrado_por: ContribUser;
    /**
     * 
     * @type {Date}
     * @memberof DefensoriaVara
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DefensoriaVara
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DefensoriaVara
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVara
     */
    paridade?: number;
    /**
     * 
     * @type {string}
     * @memberof DefensoriaVara
     */
    regex?: string;
    /**
     * 
     * @type {string}
     * @memberof DefensoriaVara
     */
    usuario_webservice?: string;
    /**
     * É o valor default?
     * @type {boolean}
     * @memberof DefensoriaVara
     */
    principal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DefensoriaVara
     */
    distribuicao_automatica?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVara
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVara
     */
    desativado_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DefensoriaVara
     */
    distribuir_por_polo?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DefensoriaVara
     */
    distribuir_por_competencia?: Array<number>;
}
/**
 * 
 * @export
 * @interface DefensoriaVaraCreate
 */
export interface DefensoriaVaraCreate {
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVaraCreate
     */
    id?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DefensoriaVaraCreate
     */
    distribuir_por_polo?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DefensoriaVaraCreate
     */
    distribuir_por_competencia?: Array<number>;
    /**
     * 
     * @type {Date}
     * @memberof DefensoriaVaraCreate
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DefensoriaVaraCreate
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DefensoriaVaraCreate
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVaraCreate
     */
    paridade?: number;
    /**
     * 
     * @type {string}
     * @memberof DefensoriaVaraCreate
     */
    regex?: string;
    /**
     * 
     * @type {string}
     * @memberof DefensoriaVaraCreate
     */
    usuario_webservice?: string;
    /**
     * É o valor default?
     * @type {boolean}
     * @memberof DefensoriaVaraCreate
     */
    principal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DefensoriaVaraCreate
     */
    distribuicao_automatica?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVaraCreate
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVaraCreate
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVaraCreate
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVaraCreate
     */
    defensoria: number;
    /**
     * 
     * @type {number}
     * @memberof DefensoriaVaraCreate
     */
    vara: number;
}
/**
 * 
 * @export
 * @interface Deficiencia
 */
export interface Deficiencia {
    /**
     * 
     * @type {number}
     * @memberof Deficiencia
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Deficiencia
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof Deficiencia
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface Dependente
 */
export interface Dependente {
    /**
     * 
     * @type {number}
     * @memberof Dependente
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Dependente
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Dependente
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Dependente
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Dependente
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof Dependente
     */
    situacao?: number;
    /**
     * 
     * @type {number}
     * @memberof Dependente
     */
    parentesco: number;
    /**
     * Ganhos mensais, em R$, do dependente
     * @type {string}
     * @memberof Dependente
     */
    renda?: string;
    /**
     * 
     * @type {number}
     * @memberof Dependente
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Dependente
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Dependente
     */
    desativado_por?: number;
    /**
     * 
     * @type {string}
     * @memberof Dependente
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof Dependente
     */
    situacao_dependente?: number;
    /**
     * 
     * @type {number}
     * @memberof Dependente
     */
    tipo_renda?: number;
}
/**
 * 
 * @export
 * @interface DocumentoFase
 */
export interface DocumentoFase {
    /**
     * 
     * @type {number}
     * @memberof DocumentoFase
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentoFase
     */
    arquivo?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentoFase
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentoFase
     */
    eproc?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentoFase
     */
    ativo?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof DocumentoFase
     */
    data_enviado?: Date;
    /**
     * 
     * @type {number}
     * @memberof DocumentoFase
     */
    fase: number;
    /**
     * Tipo de Documento
     * @type {number}
     * @memberof DocumentoFase
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentoFase
     */
    documento_atendimento?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentoFase
     */
    enviado_por?: number;
}
/**
 * 
 * @export
 * @interface DocumentoPropac
 */
export interface DocumentoPropac {
    /**
     * 
     * @type {number}
     * @memberof DocumentoPropac
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentoPropac
     */
    tipo_anexo_nome?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentoPropac
     */
    cancelar_doc_propac_url?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentoPropac
     */
    modo?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentoPropac
     */
    nome?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentoPropac
     */
    anexo?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentoPropac
     */
    anexo_original_nome_arquivo?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentoPropac
     */
    ativo?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof DocumentoPropac
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DocumentoPropac
     */
    data_remocao?: Date;
    /**
     * 
     * @type {string}
     * @memberof DocumentoPropac
     */
    motivo_remocao?: string;
    /**
     * 
     * @type {Date}
     * @memberof DocumentoPropac
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {number}
     * @memberof DocumentoPropac
     */
    movimento: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentoPropac
     */
    tipo_anexo?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentoPropac
     */
    documento?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentoPropac
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentoPropac
     */
    removido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentoPropac
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface DocumentoTipo
 */
export interface DocumentoTipo {
    /**
     * 
     * @type {number}
     * @memberof DocumentoTipo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentoTipo
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentoTipo
     */
    grau?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentoTipo
     */
    eproc?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentoTipo
     */
    recurso?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentoTipo
     */
    ativo?: boolean;
    /**
     * Conta Estatísticas?
     * @type {boolean}
     * @memberof DocumentoTipo
     */
    conta_estatistica?: boolean;
}
/**
 * 
 * @export
 * @interface EditalConcorrenciaPlantao
 */
export interface EditalConcorrenciaPlantao {
    /**
     * 
     * @type {number}
     * @memberof EditalConcorrenciaPlantao
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EditalConcorrenciaPlantao
     */
    descricao: string;
    /**
     * 
     * @type {string}
     * @memberof EditalConcorrenciaPlantao
     */
    data_inicio: string;
    /**
     * 
     * @type {string}
     * @memberof EditalConcorrenciaPlantao
     */
    data_final: string;
    /**
     * 
     * @type {string}
     * @memberof EditalConcorrenciaPlantao
     */
    data_abertura_inscricao: string;
    /**
     * 
     * @type {string}
     * @memberof EditalConcorrenciaPlantao
     */
    data_fechamento_inscricao: string;
    /**
     * 
     * @type {number}
     * @memberof EditalConcorrenciaPlantao
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof EditalConcorrenciaPlantao
     */
    tipo?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof EditalConcorrenciaPlantao
     */
    vagas?: Array<number>;
}
/**
 * 
 * @export
 * @interface EmAtendimentoRecepcao
 */
export interface EmAtendimentoRecepcao {
    /**
     * 
     * @type {string}
     * @memberof EmAtendimentoRecepcao
     */
    servidor: string;
    /**
     * 
     * @type {Date}
     * @memberof EmAtendimentoRecepcao
     */
    data_inicio: Date;
}
/**
 * 
 * @export
 * @interface Encaminhamento
 */
export interface Encaminhamento {
    /**
     * 
     * @type {number}
     * @memberof Encaminhamento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Encaminhamento
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Encaminhamento
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Encaminhamento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Encaminhamento
     */
    endereco?: number;
    /**
     * 
     * @type {number}
     * @memberof Encaminhamento
     */
    telefone?: number;
}
/**
 * 
 * @export
 * @interface Endereco
 */
export interface Endereco {
    /**
     * 
     * @type {number}
     * @memberof Endereco
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Endereco
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Endereco
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Endereco
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Endereco
     */
    logradouro?: string;
    /**
     * 
     * @type {string}
     * @memberof Endereco
     */
    numero?: string;
    /**
     * 
     * @type {string}
     * @memberof Endereco
     */
    complemento?: string;
    /**
     * 
     * @type {string}
     * @memberof Endereco
     */
    cep?: string;
    /**
     * 
     * @type {number}
     * @memberof Endereco
     */
    tipo_area?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Endereco
     */
    principal?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Endereco
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof Endereco
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Endereco
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Endereco
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Endereco
     */
    bairro?: number;
    /**
     * 
     * @type {number}
     * @memberof Endereco
     */
    municipio: number;
}
/**
 * 
 * @export
 * @interface EnderecoCreate
 */
export interface EnderecoCreate {
    /**
     * 
     * @type {number}
     * @memberof EnderecoCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EnderecoCreate
     */
    logradouro?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoCreate
     */
    numero?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoCreate
     */
    complemento?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoCreate
     */
    bairro?: string;
    /**
     * 
     * @type {number}
     * @memberof EnderecoCreate
     */
    municipio: number;
    /**
     * 
     * @type {number}
     * @memberof EnderecoCreate
     */
    tipo_area?: number;
    /**
     * 
     * @type {string}
     * @memberof EnderecoCreate
     */
    estado?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoCreate
     */
    cep?: string;
}
/**
 * 
 * @export
 * @interface EnderecoHistorico
 */
export interface EnderecoHistorico {
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EnderecoHistorico
     */
    logradouro?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoHistorico
     */
    numero?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoHistorico
     */
    complemento?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoHistorico
     */
    cep?: string;
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    tipo_area?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EnderecoHistorico
     */
    principal?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    tipo?: number;
    /**
     * 
     * @type {Date}
     * @memberof EnderecoHistorico
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof EnderecoHistorico
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof EnderecoHistorico
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    endereco: number;
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    bairro?: number;
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    municipio: number;
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof EnderecoHistorico
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface EnderecoRetrive
 */
export interface EnderecoRetrive {
    /**
     * 
     * @type {number}
     * @memberof EnderecoRetrive
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EnderecoRetrive
     */
    logradouro?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoRetrive
     */
    numero?: string;
    /**
     * 
     * @type {string}
     * @memberof EnderecoRetrive
     */
    complemento?: string;
    /**
     * 
     * @type {Generic}
     * @memberof EnderecoRetrive
     */
    bairro: Generic;
    /**
     * 
     * @type {MunicipioRetrive}
     * @memberof EnderecoRetrive
     */
    municipio: MunicipioRetrive;
    /**
     * 
     * @type {number}
     * @memberof EnderecoRetrive
     */
    tipo_area?: number;
    /**
     * 
     * @type {string}
     * @memberof EnderecoRetrive
     */
    cep?: string;
}
/**
 * 
 * @export
 * @interface Especializado
 */
export interface Especializado {
    /**
     * 
     * @type {number}
     * @memberof Especializado
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Especializado
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof Especializado
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Especializado
     */
    nucleo?: number;
}
/**
 * 
 * @export
 * @interface EstabelecimentoPenal
 */
export interface EstabelecimentoPenal {
    /**
     * 
     * @type {number}
     * @memberof EstabelecimentoPenal
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof EstabelecimentoPenal
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {string}
     * @memberof EstabelecimentoPenal
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof EstabelecimentoPenal
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof EstabelecimentoPenal
     */
    destinado_ao_sexo?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EstabelecimentoPenal
     */
    inspecionado_pela_dpe?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EstabelecimentoPenal
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EstabelecimentoPenal
     */
    endereco?: number;
    /**
     * 
     * @type {number}
     * @memberof EstabelecimentoPenal
     */
    telefone?: number;
    /**
     * 
     * @type {number}
     * @memberof EstabelecimentoPenal
     */
    tipo: number;
}
/**
 * 
 * @export
 * @interface Estado
 */
export interface Estado {
    /**
     * 
     * @type {number}
     * @memberof Estado
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Estado
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Estado
     */
    uf: string;
}
/**
 * 
 * @export
 * @interface EstruturaMoradia
 */
export interface EstruturaMoradia {
    /**
     * 
     * @type {number}
     * @memberof EstruturaMoradia
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EstruturaMoradia
     */
    nome: string;
}
/**
 * 
 * @export
 * @interface Etiqueta
 */
export interface Etiqueta {
    /**
     * 
     * @type {number}
     * @memberof Etiqueta
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Etiqueta
     */
    defensoria?: number;
    /**
     * 
     * @type {string}
     * @memberof Etiqueta
     */
    defensorias?: string;
    /**
     * 
     * @type {Date}
     * @memberof Etiqueta
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Etiqueta
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Etiqueta
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Etiqueta
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Etiqueta
     */
    cor?: string;
    /**
     * 
     * @type {number}
     * @memberof Etiqueta
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Etiqueta
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Etiqueta
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface EventoDefensoriaCategoria
 */
export interface EventoDefensoriaCategoria {
    /**
     * 
     * @type {number}
     * @memberof EventoDefensoriaCategoria
     */
    defensoria: number;
    /**
     * 
     * @type {number}
     * @memberof EventoDefensoriaCategoria
     */
    categoria: number;
}
/**
 * 
 * @export
 * @interface EventoEvento
 */
export interface EventoEvento {
    /**
     * 
     * @type {number}
     * @memberof EventoEvento
     */
    id?: number;
    /**
     * 
     * @type {Generic}
     * @memberof EventoEvento
     */
    comarca?: Generic;
    /**
     * 
     * @type {Array<number>}
     * @memberof EventoEvento
     */
    comarcas?: Array<number>;
    /**
     * 
     * @type {Generic}
     * @memberof EventoEvento
     */
    defensoria?: Generic;
    /**
     * 
     * @type {Array<number>}
     * @memberof EventoEvento
     */
    defensorias?: Array<number>;
    /**
     * 
     * @type {Generic}
     * @memberof EventoEvento
     */
    categoria_de_agenda?: Generic;
    /**
     * 
     * @type {Array<EventoDefensoriaCategoria>}
     * @memberof EventoEvento
     */
    categorias_de_agenda?: Array<EventoDefensoriaCategoria>;
    /**
     * 
     * @type {string}
     * @memberof EventoEvento
     */
    data_inicial: string;
    /**
     * 
     * @type {string}
     * @memberof EventoEvento
     */
    data_final: string;
    /**
     * 
     * @type {Date}
     * @memberof EventoEvento
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Usuario}
     * @memberof EventoEvento
     */
    cadastrado_por?: Usuario;
    /**
     * 
     * @type {Array<EventoFilho>}
     * @memberof EventoEvento
     */
    filhos?: Array<EventoFilho>;
    /**
     * 
     * @type {string}
     * @memberof EventoEvento
     */
    titulo?: string;
    /**
     * 
     * @type {number}
     * @memberof EventoEvento
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof EventoEvento
     */
    data_validade?: string;
    /**
     * 
     * @type {Date}
     * @memberof EventoEvento
     */
    data_autorizacao?: Date;
    /**
     * 
     * @type {Date}
     * @memberof EventoEvento
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof EventoEvento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EventoEvento
     */
    pai?: number;
    /**
     * 
     * @type {number}
     * @memberof EventoEvento
     */
    defensor?: number;
    /**
     * 
     * @type {number}
     * @memberof EventoEvento
     */
    autorizado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof EventoEvento
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface EventoFilho
 */
export interface EventoFilho {
    /**
     * 
     * @type {number}
     * @memberof EventoFilho
     */
    id?: number;
    /**
     * 
     * @type {Generic}
     * @memberof EventoFilho
     */
    comarca: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof EventoFilho
     */
    defensoria: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof EventoFilho
     */
    categoria_de_agenda: Generic;
}
/**
 * 
 * @export
 * @interface Falta
 */
export interface Falta {
    /**
     * 
     * @type {number}
     * @memberof Falta
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Falta
     */
    data_fato?: Date;
    /**
     * 
     * @type {string}
     * @memberof Falta
     */
    numero_pad: string;
    /**
     * 
     * @type {string}
     * @memberof Falta
     */
    observacao?: string;
    /**
     * 
     * @type {number}
     * @memberof Falta
     */
    resultado?: number;
    /**
     * 
     * @type {Date}
     * @memberof Falta
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Falta
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Falta
     */
    ativo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Falta
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof Falta
     */
    estabelecimento_penal?: number;
    /**
     * 
     * @type {number}
     * @memberof Falta
     */
    processo?: number;
    /**
     * 
     * @type {number}
     * @memberof Falta
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Falta
     */
    excluido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Falta
     */
    evento?: number;
}
/**
 * 
 * @export
 * @interface Fase
 */
export interface Fase {
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Fase
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Fase
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Fase
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {string}
     * @memberof Fase
     */
    descricao?: string;
    /**
     * 
     * @type {Date}
     * @memberof Fase
     */
    data_protocolo?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Fase
     */
    data_termino_protocolo?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Fase
     */
    ativo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Fase
     */
    automatico?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    atividade?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Fase
     */
    plantao?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    evento_eproc?: number;
    /**
     * 
     * @type {string}
     * @memberof Fase
     */
    usuario_eproc?: string;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    excluido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    processo: number;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    parte?: number;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    defensoria?: number;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    defensor_cadastro?: number;
    /**
     * 
     * @type {number}
     * @memberof Fase
     */
    defensor_substituto?: number;
}
/**
 * 
 * @export
 * @interface FaseTipo
 */
export interface FaseTipo {
    /**
     * 
     * @type {number}
     * @memberof FaseTipo
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof FaseTipo
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FaseTipo
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FaseTipo
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof FaseTipo
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof FaseTipo
     */
    nome_norm?: string;
    /**
     * 
     * @type {string}
     * @memberof FaseTipo
     */
    descricao?: string;
    /**
     * 
     * @type {string}
     * @memberof FaseTipo
     */
    codigo_eproc?: string;
    /**
     * Código Nacional do Movimento (para mais detalhes, acesse o SGT/CNJ)
     * @type {string}
     * @memberof FaseTipo
     */
    codigo_cnj?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FaseTipo
     */
    audiencia?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FaseTipo
     */
    juri?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FaseTipo
     */
    sentenca?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FaseTipo
     */
    recurso?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FaseTipo
     */
    judicial?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FaseTipo
     */
    extrajudicial?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FaseTipo
     */
    peticao_inicial?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FaseTipo
     */
    habeas_corpus?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FaseTipo
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof FaseTipo
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof FaseTipo
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface Filiacao
 */
export interface Filiacao {
    /**
     * 
     * @type {number}
     * @memberof Filiacao
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Filiacao
     */
    tipo_str?: string;
    /**
     * 
     * @type {string}
     * @memberof Filiacao
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof Filiacao
     */
    tipo: number;
}
/**
 * 
 * @export
 * @interface FormaAtendimento
 */
export interface FormaAtendimento {
    /**
     * 
     * @type {number}
     * @memberof FormaAtendimento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof FormaAtendimento
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FormaAtendimento
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FormaAtendimento
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof FormaAtendimento
     */
    nome: string;
    /**
     * 
     * @type {Date}
     * @memberof FormaAtendimento
     */
    data_inicial: Date;
    /**
     * 
     * @type {Date}
     * @memberof FormaAtendimento
     */
    data_final?: Date;
    /**
     * Conta Estatística?
     * @type {boolean}
     * @memberof FormaAtendimento
     */
    conta_estatistica?: boolean;
    /**
     * Aparece para o defensor?
     * @type {boolean}
     * @memberof FormaAtendimento
     */
    aparece_defensor?: boolean;
    /**
     * Aparece para a recepção?
     * @type {boolean}
     * @memberof FormaAtendimento
     */
    aparece_recepcao?: boolean;
    /**
     * O atendimento foi por e-mail?
     * @type {boolean}
     * @memberof FormaAtendimento
     */
    por_email?: boolean;
    /**
     * O atendimento foi por WhatsApp/Telegram/RocketChat?
     * @type {boolean}
     * @memberof FormaAtendimento
     */
    por_app_mensagem?: boolean;
    /**
     * O atendimento foi por ligação?
     * @type {boolean}
     * @memberof FormaAtendimento
     */
    por_ligacao?: boolean;
    /**
     * O atendimento foi presencial?
     * @type {boolean}
     * @memberof FormaAtendimento
     */
    presencial?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FormaAtendimento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof FormaAtendimento
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof FormaAtendimento
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface Formulario
 */
export interface Formulario {
    /**
     * 
     * @type {number}
     * @memberof Formulario
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Formulario
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Formulario
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Formulario
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof Formulario
     */
    posicao?: number;
    /**
     * 
     * @type {string}
     * @memberof Formulario
     */
    texto: string;
    /**
     * 
     * @type {boolean}
     * @memberof Formulario
     */
    publico?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Formulario
     */
    exibir_em_atendimento?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Formulario
     */
    exibir_em_atividade_extraordinaria?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Formulario
     */
    gerar_alerta_em_atendimento?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Formulario
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Formulario
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Formulario
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Formulario
     */
    nucleo: number;
}
/**
 * 
 * @export
 * @interface FormularioPergunta
 */
export interface FormularioPergunta {
    /**
     * 
     * @type {number}
     * @memberof FormularioPergunta
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof FormularioPergunta
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FormularioPergunta
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FormularioPergunta
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof FormularioPergunta
     */
    posicao?: number;
    /**
     * 
     * @type {string}
     * @memberof FormularioPergunta
     */
    texto: string;
    /**
     * 
     * @type {string}
     * @memberof FormularioPergunta
     */
    texto_complementar?: string;
    /**
     * 
     * @type {number}
     * @memberof FormularioPergunta
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof FormularioPergunta
     */
    lista?: string;
    /**
     * 
     * @type {string}
     * @memberof FormularioPergunta
     */
    lista_url?: string;
    /**
     * Classe CSS (Ex: input-xxlarge)
     * @type {string}
     * @memberof FormularioPergunta
     */
    classe_css?: string;
    /**
     * 
     * @type {number}
     * @memberof FormularioPergunta
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof FormularioPergunta
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof FormularioPergunta
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof FormularioPergunta
     */
    formulario: number;
    /**
     * 
     * @type {number}
     * @memberof FormularioPergunta
     */
    sessao?: number;
}
/**
 * 
 * @export
 * @interface Generic
 */
export interface Generic {
    /**
     * 
     * @type {number}
     * @memberof Generic
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Generic
     */
    nome?: string;
}
/**
 * 
 * @export
 * @interface GenericIdNome
 */
export interface GenericIdNome {
    /**
     * 
     * @type {number}
     * @memberof GenericIdNome
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof GenericIdNome
     */
    nome: string;
}
/**
 * 
 * @export
 * @interface GrupoDeDefensoriasParaAgendamento
 */
export interface GrupoDeDefensoriasParaAgendamento {
    /**
     * 
     * @type {number}
     * @memberof GrupoDeDefensoriasParaAgendamento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof GrupoDeDefensoriasParaAgendamento
     */
    nome: string;
    /**
     * Permitir que as defensorias do grupo e o disk 129 agendem na pauta
     * @type {boolean}
     * @memberof GrupoDeDefensoriasParaAgendamento
     */
    aceitar_agend_pauta?: boolean;
    /**
     * Permitir que as defensorias do grupo e o disk 129 agendem extra-pauta
     * @type {boolean}
     * @memberof GrupoDeDefensoriasParaAgendamento
     */
    aceitar_agend_extrapauta?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GrupoDeDefensoriasParaAgendamento
     */
    ativo?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof GrupoDeDefensoriasParaAgendamento
     */
    defensorias?: Array<number>;
}
/**
 * 
 * @export
 * @interface Guiche
 */
export interface Guiche {
    /**
     * 
     * @type {number}
     * @memberof Guiche
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Guiche
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof Guiche
     */
    numero?: number;
    /**
     * 
     * @type {number}
     * @memberof Guiche
     */
    andar?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Guiche
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Guiche
     */
    comarca: number;
    /**
     * 
     * @type {number}
     * @memberof Guiche
     */
    predio?: number;
    /**
     * 
     * @type {number}
     * @memberof Guiche
     */
    defensoria?: number;
    /**
     * 
     * @type {number}
     * @memberof Guiche
     */
    usuario?: number;
}
/**
 * 
 * @export
 * @interface Historico
 */
export interface Historico {
    /**
     * 
     * @type {number}
     * @memberof Historico
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Historico
     */
    data_registro: string;
    /**
     * 
     * @type {number}
     * @memberof Historico
     */
    evento: number;
    /**
     * 
     * @type {string}
     * @memberof Historico
     */
    historico?: string;
    /**
     * 
     * @type {Date}
     * @memberof Historico
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Historico
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Historico
     */
    ativo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Historico
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof Historico
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Historico
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface HistoricoLogin
 */
export interface HistoricoLogin {
    /**
     * 
     * @type {number}
     * @memberof HistoricoLogin
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof HistoricoLogin
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof HistoricoLogin
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof HistoricoLogin
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof HistoricoLogin
     */
    endereco_ip: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricoLogin
     */
    info_navegador?: string;
    /**
     * 
     * @type {Date}
     * @memberof HistoricoLogin
     */
    logout?: Date;
    /**
     * 
     * @type {number}
     * @memberof HistoricoLogin
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof HistoricoLogin
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof HistoricoLogin
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface Honorario
 */
export interface Honorario {
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Honorario
     */
    numero_recurso_gerado?: string;
    /**
     * Ao finalizar o Recurso, deve ser marcado como True para liberar as movimentacoes.
     * @type {boolean}
     * @memberof Honorario
     */
    recurso_finalizado?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Honorario
     */
    possivel?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    situacao?: number;
    /**
     * 
     * @type {Date}
     * @memberof Honorario
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Honorario
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Honorario
     */
    modificado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Honorario
     */
    valor_estimado?: string;
    /**
     * 
     * @type {string}
     * @memberof Honorario
     */
    valor_efetivo?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Honorario
     */
    suspenso?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Honorario
     */
    suspenso_ate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Honorario
     */
    baixado?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Honorario
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    honorario_origem?: number;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    recurso_vinculado?: number;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    fase: number;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    defensor?: number;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    defensoria?: number;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    excluido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Honorario
     */
    modificado_por?: number;
    /**
     * 
     * @type {string}
     * @memberof Honorario
     */
    atendimento?: string;
}
/**
 * 
 * @export
 * @interface HonorariosDocumento
 */
export interface HonorariosDocumento {
    /**
     * 
     * @type {number}
     * @memberof HonorariosDocumento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof HonorariosDocumento
     */
    anexo?: string;
    /**
     * 
     * @type {string}
     * @memberof HonorariosDocumento
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof HonorariosDocumento
     */
    visivel?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HonorariosDocumento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof HonorariosDocumento
     */
    movimento?: number;
}
/**
 * 
 * @export
 * @interface IdentidadeGenero
 */
export interface IdentidadeGenero {
    /**
     * 
     * @type {number}
     * @memberof IdentidadeGenero
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof IdentidadeGenero
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof IdentidadeGenero
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof IdentidadeGenero
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof IdentidadeGenero
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof IdentidadeGenero
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof IdentidadeGenero
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof IdentidadeGenero
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface Imovel
 */
export interface Imovel {
    /**
     * 
     * @type {number}
     * @memberof Imovel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Imovel
     */
    pagamento: number;
    /**
     * 
     * @type {string}
     * @memberof Imovel
     */
    banco?: string;
    /**
     * 
     * @type {number}
     * @memberof Imovel
     */
    parcelas: number;
    /**
     * 
     * @type {string}
     * @memberof Imovel
     */
    valor_parcela: string;
    /**
     * 
     * @type {string}
     * @memberof Imovel
     */
    valor_total: string;
    /**
     * 
     * @type {boolean}
     * @memberof Imovel
     */
    uso_proprio: boolean;
    /**
     * 
     * @type {number}
     * @memberof Imovel
     */
    patrimonio: number;
}
/**
 * 
 * @export
 * @interface Impedimento
 */
export interface Impedimento {
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Impedimento
     */
    medida_pretendida?: string;
    /**
     * 
     * @type {string}
     * @memberof Impedimento
     */
    justificativa?: string;
    /**
     * 
     * @type {Date}
     * @memberof Impedimento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Impedimento
     */
    data_recurso?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Impedimento
     */
    data_recebimento?: Date;
    /**
     * 
     * @type {string}
     * @memberof Impedimento
     */
    anotacao_comunicacao?: string;
    /**
     * 
     * @type {Date}
     * @memberof Impedimento
     */
    data_comunicacao?: Date;
    /**
     * 
     * @type {string}
     * @memberof Impedimento
     */
    anotacao_verificacao?: string;
    /**
     * 
     * @type {Date}
     * @memberof Impedimento
     */
    data_verificacao?: Date;
    /**
     * 
     * @type {string}
     * @memberof Impedimento
     */
    anotacao_avaliacao?: string;
    /**
     * 
     * @type {Date}
     * @memberof Impedimento
     */
    data_avaliacao?: Date;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    resultado?: number;
    /**
     * 
     * @type {string}
     * @memberof Impedimento
     */
    anotacao_baixa?: string;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    tipo_baixa?: number;
    /**
     * 
     * @type {Date}
     * @memberof Impedimento
     */
    data_baixa?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Impedimento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    defensor: number;
    /**
     * 
     * @type {string}
     * @memberof Impedimento
     */
    pessoa: string;
    /**
     * 
     * @type {string}
     * @memberof Impedimento
     */
    atendimento?: string;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    razao?: number;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    recorrido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    recebido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    comunicado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    verificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    avaliado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Impedimento
     */
    baixado_por?: number;
}
/**
 * 
 * @export
 * @interface Indeferimento
 */
export interface Indeferimento {
    /**
     * 
     * @type {number}
     * @memberof Indeferimento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Indeferimento
     */
    medida_pretendida?: string;
    /**
     * 
     * @type {string}
     * @memberof Indeferimento
     */
    justificativa?: string;
    /**
     * 
     * @type {number}
     * @memberof Indeferimento
     */
    resultado?: number;
    /**
     * 
     * @type {number}
     * @memberof Indeferimento
     */
    tipo_baixa?: number;
    /**
     * 
     * @type {number}
     * @memberof Indeferimento
     */
    processo: number;
    /**
     * 
     * @type {string}
     * @memberof Indeferimento
     */
    atendimento: string;
    /**
     * 
     * @type {string}
     * @memberof Indeferimento
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof Indeferimento
     */
    defensor: number;
    /**
     * 
     * @type {number}
     * @memberof Indeferimento
     */
    defensoria?: number;
}
/**
 * 
 * @export
 * @interface Informacao
 */
export interface Informacao {
    /**
     * 
     * @type {number}
     * @memberof Informacao
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Informacao
     */
    titulo: string;
    /**
     * 
     * @type {string}
     * @memberof Informacao
     */
    texto: string;
    /**
     * 
     * @type {boolean}
     * @memberof Informacao
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    previous?: string;
    /**
     * 
     * @type {Array<Acordo>}
     * @memberof InlineResponse200
     */
    results: Array<Acordo>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    previous?: string;
    /**
     * 
     * @type {Array<Agenda>}
     * @memberof InlineResponse2001
     */
    results: Array<Agenda>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    previous?: string;
    /**
     * 
     * @type {Array<Pessoa>}
     * @memberof InlineResponse20010
     */
    results: Array<Pessoa>;
}
/**
 * 
 * @export
 * @interface InlineResponse200100
 */
export interface InlineResponse200100 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200100
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200100
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200100
     */
    previous?: string;
    /**
     * 
     * @type {Array<Procedimento>}
     * @memberof InlineResponse200100
     */
    results: Array<Procedimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse200101
 */
export interface InlineResponse200101 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200101
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200101
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200101
     */
    previous?: string;
    /**
     * 
     * @type {Array<ProcessoApenso>}
     * @memberof InlineResponse200101
     */
    results: Array<ProcessoApenso>;
}
/**
 * 
 * @export
 * @interface InlineResponse200102
 */
export interface InlineResponse200102 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200102
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200102
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200102
     */
    previous?: string;
    /**
     * 
     * @type {Array<ProcessosAssuntos>}
     * @memberof InlineResponse200102
     */
    results: Array<ProcessosAssuntos>;
}
/**
 * 
 * @export
 * @interface InlineResponse200103
 */
export interface InlineResponse200103 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200103
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200103
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200103
     */
    previous?: string;
    /**
     * 
     * @type {Array<Acao>}
     * @memberof InlineResponse200103
     */
    results: Array<Acao>;
}
/**
 * 
 * @export
 * @interface InlineResponse200104
 */
export interface InlineResponse200104 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200104
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200104
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200104
     */
    previous?: string;
    /**
     * 
     * @type {Array<DocumentoFase>}
     * @memberof InlineResponse200104
     */
    results: Array<DocumentoFase>;
}
/**
 * 
 * @export
 * @interface InlineResponse200105
 */
export interface InlineResponse200105 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200105
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200105
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200105
     */
    previous?: string;
    /**
     * 
     * @type {Array<Fase>}
     * @memberof InlineResponse200105
     */
    results: Array<Fase>;
}
/**
 * 
 * @export
 * @interface InlineResponse200106
 */
export interface InlineResponse200106 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200106
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200106
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200106
     */
    previous?: string;
    /**
     * 
     * @type {Array<OutroParametro>}
     * @memberof InlineResponse200106
     */
    results: Array<OutroParametro>;
}
/**
 * 
 * @export
 * @interface InlineResponse200107
 */
export interface InlineResponse200107 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200107
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200107
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200107
     */
    previous?: string;
    /**
     * 
     * @type {Array<ProcessoPoloDestinatario>}
     * @memberof InlineResponse200107
     */
    results: Array<ProcessoPoloDestinatario>;
}
/**
 * 
 * @export
 * @interface InlineResponse200108
 */
export interface InlineResponse200108 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200108
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200108
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200108
     */
    previous?: string;
    /**
     * 
     * @type {Array<DocumentoTipo>}
     * @memberof InlineResponse200108
     */
    results: Array<DocumentoTipo>;
}
/**
 * 
 * @export
 * @interface InlineResponse200109
 */
export interface InlineResponse200109 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200109
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200109
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200109
     */
    previous?: string;
    /**
     * 
     * @type {Array<FaseTipo>}
     * @memberof InlineResponse200109
     */
    results: Array<FaseTipo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    previous?: string;
    /**
     * 
     * @type {Array<AtendimentoParticipante>}
     * @memberof InlineResponse20011
     */
    results: Array<AtendimentoParticipante>;
}
/**
 * 
 * @export
 * @interface InlineResponse200110
 */
export interface InlineResponse200110 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200110
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200110
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200110
     */
    previous?: string;
    /**
     * 
     * @type {Array<Processo>}
     * @memberof InlineResponse200110
     */
    results: Array<Processo>;
}
/**
 * 
 * @export
 * @interface InlineResponse200111
 */
export interface InlineResponse200111 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200111
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200111
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200111
     */
    previous?: string;
    /**
     * 
     * @type {Array<Profissao>}
     * @memberof InlineResponse200111
     */
    results: Array<Profissao>;
}
/**
 * 
 * @export
 * @interface InlineResponse200112
 */
export interface InlineResponse200112 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200112
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200112
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200112
     */
    previous?: string;
    /**
     * 
     * @type {Array<DocumentoPropac>}
     * @memberof InlineResponse200112
     */
    results: Array<DocumentoPropac>;
}
/**
 * 
 * @export
 * @interface InlineResponse200113
 */
export interface InlineResponse200113 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200113
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200113
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200113
     */
    previous?: string;
    /**
     * 
     * @type {Array<PropacMovimento>}
     * @memberof InlineResponse200113
     */
    results: Array<PropacMovimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse200114
 */
export interface InlineResponse200114 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200114
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200114
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200114
     */
    previous?: string;
    /**
     * 
     * @type {Array<SituacaoProcedimento>}
     * @memberof InlineResponse200114
     */
    results: Array<SituacaoProcedimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse200115
 */
export interface InlineResponse200115 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200115
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200115
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200115
     */
    previous?: string;
    /**
     * 
     * @type {Array<TipoAnexoDocumentoPropac>}
     * @memberof InlineResponse200115
     */
    results: Array<TipoAnexoDocumentoPropac>;
}
/**
 * 
 * @export
 * @interface InlineResponse200116
 */
export interface InlineResponse200116 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200116
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200116
     */
    previous?: string;
    /**
     * 
     * @type {Array<MovimentoTipo>}
     * @memberof InlineResponse200116
     */
    results: Array<MovimentoTipo>;
}
/**
 * 
 * @export
 * @interface InlineResponse200117
 */
export interface InlineResponse200117 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200117
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200117
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200117
     */
    previous?: string;
    /**
     * 
     * @type {Array<PropacProcedimento>}
     * @memberof InlineResponse200117
     */
    results: Array<PropacProcedimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse200118
 */
export interface InlineResponse200118 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200118
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200118
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200118
     */
    previous?: string;
    /**
     * 
     * @type {Array<QualificacaoAssunto>}
     * @memberof InlineResponse200118
     */
    results: Array<QualificacaoAssunto>;
}
/**
 * 
 * @export
 * @interface InlineResponse200119
 */
export interface InlineResponse200119 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200119
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200119
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200119
     */
    previous?: string;
    /**
     * 
     * @type {Array<Qualificacao>}
     * @memberof InlineResponse200119
     */
    results: Array<Qualificacao>;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    previous?: string;
    /**
     * 
     * @type {Array<AtendimentoTotalSerializar>}
     * @memberof InlineResponse20012
     */
    results: Array<AtendimentoTotalSerializar>;
}
/**
 * 
 * @export
 * @interface InlineResponse200120
 */
export interface InlineResponse200120 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200120
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200120
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200120
     */
    previous?: string;
    /**
     * 
     * @type {Array<Relatorio>}
     * @memberof InlineResponse200120
     */
    results: Array<Relatorio>;
}
/**
 * 
 * @export
 * @interface InlineResponse200121
 */
export interface InlineResponse200121 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200121
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200121
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200121
     */
    previous?: string;
    /**
     * 
     * @type {Array<Remissao>}
     * @memberof InlineResponse200121
     */
    results: Array<Remissao>;
}
/**
 * 
 * @export
 * @interface InlineResponse200122
 */
export interface InlineResponse200122 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200122
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200122
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200122
     */
    previous?: string;
    /**
     * 
     * @type {Array<Renda>}
     * @memberof InlineResponse200122
     */
    results: Array<Renda>;
}
/**
 * 
 * @export
 * @interface InlineResponse200123
 */
export interface InlineResponse200123 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200123
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200123
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200123
     */
    previous?: string;
    /**
     * 
     * @type {Array<RestricaoPrestacaoServico>}
     * @memberof InlineResponse200123
     */
    results: Array<RestricaoPrestacaoServico>;
}
/**
 * 
 * @export
 * @interface InlineResponse200124
 */
export interface InlineResponse200124 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200124
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200124
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200124
     */
    previous?: string;
    /**
     * 
     * @type {Array<Salario>}
     * @memberof InlineResponse200124
     */
    results: Array<Salario>;
}
/**
 * 
 * @export
 * @interface InlineResponse200125
 */
export interface InlineResponse200125 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200125
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200125
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200125
     */
    previous?: string;
    /**
     * 
     * @type {Array<Semovente>}
     * @memberof InlineResponse200125
     */
    results: Array<Semovente>;
}
/**
 * 
 * @export
 * @interface InlineResponse200126
 */
export interface InlineResponse200126 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200126
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200126
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200126
     */
    previous?: string;
    /**
     * 
     * @type {Array<ServidorV2>}
     * @memberof InlineResponse200126
     */
    results: Array<ServidorV2>;
}
/**
 * 
 * @export
 * @interface InlineResponse200127
 */
export interface InlineResponse200127 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200127
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200127
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200127
     */
    previous?: string;
    /**
     * 
     * @type {Array<Situacao>}
     * @memberof InlineResponse200127
     */
    results: Array<Situacao>;
}
/**
 * 
 * @export
 * @interface InlineResponse200128
 */
export interface InlineResponse200128 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200128
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200128
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200128
     */
    previous?: string;
    /**
     * 
     * @type {Array<Soltura>}
     * @memberof InlineResponse200128
     */
    results: Array<Soltura>;
}
/**
 * 
 * @export
 * @interface InlineResponse200129
 */
export interface InlineResponse200129 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200129
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200129
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200129
     */
    previous?: string;
    /**
     * 
     * @type {Array<Tarefa>}
     * @memberof InlineResponse200129
     */
    results: Array<Tarefa>;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20013
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    previous?: string;
    /**
     * 
     * @type {Array<AtividadeExtraordinaria>}
     * @memberof InlineResponse20013
     */
    results: Array<AtividadeExtraordinaria>;
}
/**
 * 
 * @export
 * @interface InlineResponse200130
 */
export interface InlineResponse200130 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200130
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200130
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200130
     */
    previous?: string;
    /**
     * 
     * @type {Array<ContribTelefone>}
     * @memberof InlineResponse200130
     */
    results: Array<ContribTelefone>;
}
/**
 * 
 * @export
 * @interface InlineResponse200131
 */
export interface InlineResponse200131 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200131
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200131
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200131
     */
    previous?: string;
    /**
     * 
     * @type {Array<TermoResposta>}
     * @memberof InlineResponse200131
     */
    results: Array<TermoResposta>;
}
/**
 * 
 * @export
 * @interface InlineResponse200132
 */
export interface InlineResponse200132 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200132
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200132
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200132
     */
    previous?: string;
    /**
     * 
     * @type {Array<Termo>}
     * @memberof InlineResponse200132
     */
    results: Array<Termo>;
}
/**
 * 
 * @export
 * @interface InlineResponse200133
 */
export interface InlineResponse200133 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200133
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200133
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200133
     */
    previous?: string;
    /**
     * 
     * @type {Array<Tipificacao>}
     * @memberof InlineResponse200133
     */
    results: Array<Tipificacao>;
}
/**
 * 
 * @export
 * @interface InlineResponse200134
 */
export interface InlineResponse200134 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200134
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200134
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200134
     */
    previous?: string;
    /**
     * 
     * @type {Array<AtividadeExtraordinariaTipo>}
     * @memberof InlineResponse200134
     */
    results: Array<AtividadeExtraordinariaTipo>;
}
/**
 * 
 * @export
 * @interface InlineResponse200135
 */
export interface InlineResponse200135 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200135
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200135
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200135
     */
    previous?: string;
    /**
     * 
     * @type {Array<TipoColetividade>}
     * @memberof InlineResponse200135
     */
    results: Array<TipoColetividade>;
}
/**
 * 
 * @export
 * @interface InlineResponse200136
 */
export interface InlineResponse200136 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200136
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200136
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200136
     */
    previous?: string;
    /**
     * 
     * @type {Array<TipoEstabelecimentoPenal>}
     * @memberof InlineResponse200136
     */
    results: Array<TipoEstabelecimentoPenal>;
}
/**
 * 
 * @export
 * @interface InlineResponse200137
 */
export interface InlineResponse200137 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200137
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200137
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200137
     */
    previous?: string;
    /**
     * 
     * @type {Array<PatrimonialTipo>}
     * @memberof InlineResponse200137
     */
    results: Array<PatrimonialTipo>;
}
/**
 * 
 * @export
 * @interface InlineResponse200138
 */
export interface InlineResponse200138 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200138
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200138
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200138
     */
    previous?: string;
    /**
     * 
     * @type {Array<TipoRenda>}
     * @memberof InlineResponse200138
     */
    results: Array<TipoRenda>;
}
/**
 * 
 * @export
 * @interface InlineResponse200139
 */
export interface InlineResponse200139 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200139
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200139
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200139
     */
    previous?: string;
    /**
     * 
     * @type {Array<TipoVulnerabilidade>}
     * @memberof InlineResponse200139
     */
    results: Array<TipoVulnerabilidade>;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    previous?: string;
    /**
     * 
     * @type {Array<Atuacao>}
     * @memberof InlineResponse20014
     */
    results: Array<Atuacao>;
}
/**
 * 
 * @export
 * @interface InlineResponse200140
 */
export interface InlineResponse200140 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200140
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200140
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200140
     */
    previous?: string;
    /**
     * 
     * @type {Array<VagaEditalPlantao>}
     * @memberof InlineResponse200140
     */
    results: Array<VagaEditalPlantao>;
}
/**
 * 
 * @export
 * @interface InlineResponse200141
 */
export interface InlineResponse200141 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200141
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200141
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200141
     */
    previous?: string;
    /**
     * 
     * @type {Array<Vara>}
     * @memberof InlineResponse200141
     */
    results: Array<Vara>;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015
     */
    previous?: string;
    /**
     * 
     * @type {Array<Atualizacao>}
     * @memberof InlineResponse20015
     */
    results: Array<Atualizacao>;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20016
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    previous?: string;
    /**
     * 
     * @type {Array<AudienciaTotal>}
     * @memberof InlineResponse20016
     */
    results: Array<AudienciaTotal>;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20017
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    previous?: string;
    /**
     * 
     * @type {Array<Audiencia>}
     * @memberof InlineResponse20017
     */
    results: Array<Audiencia>;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20018
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018
     */
    previous?: string;
    /**
     * 
     * @type {Array<Bairro>}
     * @memberof InlineResponse20018
     */
    results: Array<Bairro>;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20019
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019
     */
    previous?: string;
    /**
     * 
     * @type {Array<CalculoExecucaoPenal>}
     * @memberof InlineResponse20019
     */
    results: Array<CalculoExecucaoPenal>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    previous?: string;
    /**
     * 
     * @type {Array<Aprisionamento>}
     * @memberof InlineResponse2002
     */
    results: Array<Aprisionamento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20020
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20020
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20020
     */
    previous?: string;
    /**
     * 
     * @type {Array<Cargo>}
     * @memberof InlineResponse20020
     */
    results: Array<Cargo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20021
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20021
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20021
     */
    previous?: string;
    /**
     * 
     * @type {Array<CategoriaDeAgenda>}
     * @memberof InlineResponse20021
     */
    results: Array<CategoriaDeAgenda>;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20022
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20022
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20022
     */
    previous?: string;
    /**
     * 
     * @type {Array<CEP>}
     * @memberof InlineResponse20022
     */
    results: Array<CEP>;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20023
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20023
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20023
     */
    previous?: string;
    /**
     * 
     * @type {Array<Comarca>}
     * @memberof InlineResponse20023
     */
    results: Array<Comarca>;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20024
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024
     */
    previous?: string;
    /**
     * 
     * @type {Array<SistemaWebService>}
     * @memberof InlineResponse20024
     */
    results: Array<SistemaWebService>;
}
/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20025
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20025
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20025
     */
    previous?: string;
    /**
     * 
     * @type {Array<ContribDocumento>}
     * @memberof InlineResponse20025
     */
    results: Array<ContribDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20026
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026
     */
    previous?: string;
    /**
     * 
     * @type {Array<Classe>}
     * @memberof InlineResponse20026
     */
    results: Array<Classe>;
}
/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20027
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20027
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20027
     */
    previous?: string;
    /**
     * 
     * @type {Array<CoreDocumento>}
     * @memberof InlineResponse20027
     */
    results: Array<CoreDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20028
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028
     */
    previous?: string;
    /**
     * 
     * @type {Array<CoreEvento>}
     * @memberof InlineResponse20028
     */
    results: Array<CoreEvento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20029
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20029
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20029
     */
    previous?: string;
    /**
     * 
     * @type {Array<CoreModeloDocumento>}
     * @memberof InlineResponse20029
     */
    results: Array<CoreModeloDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    previous?: string;
    /**
     * 
     * @type {Array<Area>}
     * @memberof InlineResponse2003
     */
    results: Array<Area>;
}
/**
 * 
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030
     */
    previous?: string;
    /**
     * 
     * @type {Array<Parte>}
     * @memberof InlineResponse20030
     */
    results: Array<Parte>;
}
/**
 * 
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031
     */
    previous?: string;
    /**
     * 
     * @type {Array<CoreProcesso>}
     * @memberof InlineResponse20031
     */
    results: Array<CoreProcesso>;
}
/**
 * 
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032
     */
    previous?: string;
    /**
     * 
     * @type {Array<TipoDocumento>}
     * @memberof InlineResponse20032
     */
    results: Array<TipoDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20033
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033
     */
    previous?: string;
    /**
     * 
     * @type {Array<TipoEvento>}
     * @memberof InlineResponse20033
     */
    results: Array<TipoEvento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20034
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034
     */
    previous?: string;
    /**
     * 
     * @type {Array<Defensor>}
     * @memberof InlineResponse20034
     */
    results: Array<Defensor>;
}
/**
 * 
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20035
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035
     */
    previous?: string;
    /**
     * 
     * @type {Array<DefensoriaTipoEvento>}
     * @memberof InlineResponse20035
     */
    results: Array<DefensoriaTipoEvento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20036
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20036
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20036
     */
    previous?: string;
    /**
     * 
     * @type {Array<DefensoriaVara>}
     * @memberof InlineResponse20036
     */
    results: Array<DefensoriaVara>;
}
/**
 * 
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20037
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20037
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20037
     */
    previous?: string;
    /**
     * 
     * @type {Array<Defensoria>}
     * @memberof InlineResponse20037
     */
    results: Array<Defensoria>;
}
/**
 * 
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20038
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038
     */
    previous?: string;
    /**
     * 
     * @type {Array<Deficiencia>}
     * @memberof InlineResponse20038
     */
    results: Array<Deficiencia>;
}
/**
 * 
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20039
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20039
     */
    previous?: string;
    /**
     * 
     * @type {Array<Dependente>}
     * @memberof InlineResponse20039
     */
    results: Array<Dependente>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    previous?: string;
    /**
     * 
     * @type {Array<DefensorDocumento>}
     * @memberof InlineResponse2004
     */
    results: Array<DefensorDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20040
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040
     */
    previous?: string;
    /**
     * 
     * @type {Array<EditalConcorrenciaPlantao>}
     * @memberof InlineResponse20040
     */
    results: Array<EditalConcorrenciaPlantao>;
}
/**
 * 
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20041
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041
     */
    previous?: string;
    /**
     * 
     * @type {Array<Encaminhamento>}
     * @memberof InlineResponse20041
     */
    results: Array<Encaminhamento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20042
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042
     */
    previous?: string;
    /**
     * 
     * @type {Array<EnderecoHistorico>}
     * @memberof InlineResponse20042
     */
    results: Array<EnderecoHistorico>;
}
/**
 * 
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20043
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20043
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20043
     */
    previous?: string;
    /**
     * 
     * @type {Array<ContribEndereco>}
     * @memberof InlineResponse20043
     */
    results: Array<ContribEndereco>;
}
/**
 * 
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20044
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20044
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20044
     */
    previous?: string;
    /**
     * 
     * @type {Array<Especializado>}
     * @memberof InlineResponse20044
     */
    results: Array<Especializado>;
}
/**
 * 
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20045
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045
     */
    previous?: string;
    /**
     * 
     * @type {Array<EstabelecimentoPenal>}
     * @memberof InlineResponse20045
     */
    results: Array<EstabelecimentoPenal>;
}
/**
 * 
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20046
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20046
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20046
     */
    previous?: string;
    /**
     * 
     * @type {Array<Estado>}
     * @memberof InlineResponse20046
     */
    results: Array<Estado>;
}
/**
 * 
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047
     */
    previous?: string;
    /**
     * 
     * @type {Array<EstruturaMoradia>}
     * @memberof InlineResponse20047
     */
    results: Array<EstruturaMoradia>;
}
/**
 * 
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20048
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048
     */
    previous?: string;
    /**
     * 
     * @type {Array<Etiqueta>}
     * @memberof InlineResponse20048
     */
    results: Array<Etiqueta>;
}
/**
 * 
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20049
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20049
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20049
     */
    previous?: string;
    /**
     * 
     * @type {Array<EventoEvento>}
     * @memberof InlineResponse20049
     */
    results: Array<EventoEvento>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    previous?: string;
    /**
     * 
     * @type {Array<PessoaAssistida>}
     * @memberof InlineResponse2005
     */
    results: Array<PessoaAssistida>;
}
/**
 * 
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20050
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20050
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20050
     */
    previous?: string;
    /**
     * 
     * @type {Array<Falta>}
     * @memberof InlineResponse20050
     */
    results: Array<Falta>;
}
/**
 * 
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20051
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20051
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20051
     */
    previous?: string;
    /**
     * 
     * @type {Array<Filiacao>}
     * @memberof InlineResponse20051
     */
    results: Array<Filiacao>;
}
/**
 * 
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20052
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052
     */
    previous?: string;
    /**
     * 
     * @type {Array<FormaAtendimento>}
     * @memberof InlineResponse20052
     */
    results: Array<FormaAtendimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053
     */
    previous?: string;
    /**
     * 
     * @type {Array<FormularioPergunta>}
     * @memberof InlineResponse20053
     */
    results: Array<FormularioPergunta>;
}
/**
 * 
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20054
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20054
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20054
     */
    previous?: string;
    /**
     * 
     * @type {Array<Resposta>}
     * @memberof InlineResponse20054
     */
    results: Array<Resposta>;
}
/**
 * 
 * @export
 * @interface InlineResponse20055
 */
export interface InlineResponse20055 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20055
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20055
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20055
     */
    previous?: string;
    /**
     * 
     * @type {Array<Formulario>}
     * @memberof InlineResponse20055
     */
    results: Array<Formulario>;
}
/**
 * 
 * @export
 * @interface InlineResponse20056
 */
export interface InlineResponse20056 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20056
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056
     */
    previous?: string;
    /**
     * 
     * @type {Array<GrupoDeDefensoriasParaAgendamento>}
     * @memberof InlineResponse20056
     */
    results: Array<GrupoDeDefensoriasParaAgendamento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20057
 */
export interface InlineResponse20057 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20057
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057
     */
    previous?: string;
    /**
     * 
     * @type {Array<Guiche>}
     * @memberof InlineResponse20057
     */
    results: Array<Guiche>;
}
/**
 * 
 * @export
 * @interface InlineResponse20058
 */
export interface InlineResponse20058 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058
     */
    previous?: string;
    /**
     * 
     * @type {Array<ParteHistoricoTransferencia>}
     * @memberof InlineResponse20058
     */
    results: Array<ParteHistoricoTransferencia>;
}
/**
 * 
 * @export
 * @interface InlineResponse20059
 */
export interface InlineResponse20059 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20059
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059
     */
    previous?: string;
    /**
     * 
     * @type {Array<Historico>}
     * @memberof InlineResponse20059
     */
    results: Array<Historico>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    previous?: string;
    /**
     * 
     * @type {Array<Assunto>}
     * @memberof InlineResponse2006
     */
    results: Array<Assunto>;
}
/**
 * 
 * @export
 * @interface InlineResponse20060
 */
export interface InlineResponse20060 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20060
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060
     */
    previous?: string;
    /**
     * 
     * @type {Array<AlertaProcessoMovimento>}
     * @memberof InlineResponse20060
     */
    results: Array<AlertaProcessoMovimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20061
 */
export interface InlineResponse20061 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20061
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061
     */
    previous?: string;
    /**
     * 
     * @type {Array<Analise>}
     * @memberof InlineResponse20061
     */
    results: Array<Analise>;
}
/**
 * 
 * @export
 * @interface InlineResponse20062
 */
export interface InlineResponse20062 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20062
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062
     */
    previous?: string;
    /**
     * 
     * @type {Array<HonorariosDocumento>}
     * @memberof InlineResponse20062
     */
    results: Array<HonorariosDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20063
 */
export interface InlineResponse20063 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20063
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063
     */
    previous?: string;
    /**
     * 
     * @type {Array<Movimento>}
     * @memberof InlineResponse20063
     */
    results: Array<Movimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20064
 */
export interface InlineResponse20064 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20064
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20064
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20064
     */
    previous?: string;
    /**
     * 
     * @type {Array<Honorario>}
     * @memberof InlineResponse20064
     */
    results: Array<Honorario>;
}
/**
 * 
 * @export
 * @interface InlineResponse20065
 */
export interface InlineResponse20065 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20065
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20065
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20065
     */
    previous?: string;
    /**
     * 
     * @type {Array<IdentidadeGenero>}
     * @memberof InlineResponse20065
     */
    results: Array<IdentidadeGenero>;
}
/**
 * 
 * @export
 * @interface InlineResponse20066
 */
export interface InlineResponse20066 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20066
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20066
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20066
     */
    previous?: string;
    /**
     * 
     * @type {Array<Imovel>}
     * @memberof InlineResponse20066
     */
    results: Array<Imovel>;
}
/**
 * 
 * @export
 * @interface InlineResponse20067
 */
export interface InlineResponse20067 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20067
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20067
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20067
     */
    previous?: string;
    /**
     * 
     * @type {Array<Impedimento>}
     * @memberof InlineResponse20067
     */
    results: Array<Impedimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20068
 */
export interface InlineResponse20068 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20068
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20068
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20068
     */
    previous?: string;
    /**
     * 
     * @type {Array<Indeferimento>}
     * @memberof InlineResponse20068
     */
    results: Array<Indeferimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20069
 */
export interface InlineResponse20069 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20069
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20069
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20069
     */
    previous?: string;
    /**
     * 
     * @type {Array<Informacao>}
     * @memberof InlineResponse20069
     */
    results: Array<Informacao>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    previous?: string;
    /**
     * 
     * @type {Array<Coletivo>}
     * @memberof InlineResponse2007
     */
    results: Array<Coletivo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20070
 */
export interface InlineResponse20070 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20070
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20070
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20070
     */
    previous?: string;
    /**
     * 
     * @type {Array<Interrupcao>}
     * @memberof InlineResponse20070
     */
    results: Array<Interrupcao>;
}
/**
 * 
 * @export
 * @interface InlineResponse20071
 */
export interface InlineResponse20071 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20071
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20071
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20071
     */
    previous?: string;
    /**
     * 
     * @type {Array<ItineranteEvento>}
     * @memberof InlineResponse20071
     */
    results: Array<ItineranteEvento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20072
 */
export interface InlineResponse20072 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20072
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20072
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20072
     */
    previous?: string;
    /**
     * 
     * @type {Array<Justificativa>}
     * @memberof InlineResponse20072
     */
    results: Array<Justificativa>;
}
/**
 * 
 * @export
 * @interface InlineResponse20073
 */
export interface InlineResponse20073 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20073
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20073
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20073
     */
    previous?: string;
    /**
     * 
     * @type {Array<Local>}
     * @memberof InlineResponse20073
     */
    results: Array<Local>;
}
/**
 * 
 * @export
 * @interface InlineResponse20074
 */
export interface InlineResponse20074 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20074
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20074
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20074
     */
    previous?: string;
    /**
     * 
     * @type {Array<HistoricoLogin>}
     * @memberof InlineResponse20074
     */
    results: Array<HistoricoLogin>;
}
/**
 * 
 * @export
 * @interface InlineResponse20075
 */
export interface InlineResponse20075 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20075
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20075
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20075
     */
    previous?: string;
    /**
     * 
     * @type {Array<ManifestacaoAviso>}
     * @memberof InlineResponse20075
     */
    results: Array<ManifestacaoAviso>;
}
/**
 * 
 * @export
 * @interface InlineResponse20076
 */
export interface InlineResponse20076 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20076
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20076
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20076
     */
    previous?: string;
    /**
     * 
     * @type {Array<ManifestacaoDocumento>}
     * @memberof InlineResponse20076
     */
    results: Array<ManifestacaoDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20077
 */
export interface InlineResponse20077 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20077
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20077
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20077
     */
    previous?: string;
    /**
     * 
     * @type {Array<Manifestacao>}
     * @memberof InlineResponse20077
     */
    results: Array<Manifestacao>;
}
/**
 * 
 * @export
 * @interface InlineResponse20078
 */
export interface InlineResponse20078 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20078
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20078
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20078
     */
    previous?: string;
    /**
     * 
     * @type {Array<MenuExtra>}
     * @memberof InlineResponse20078
     */
    results: Array<MenuExtra>;
}
/**
 * 
 * @export
 * @interface InlineResponse20079
 */
export interface InlineResponse20079 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20079
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20079
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20079
     */
    previous?: string;
    /**
     * 
     * @type {Array<AtendimentoModeloDocumento>}
     * @memberof InlineResponse20079
     */
    results: Array<AtendimentoModeloDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    previous?: string;
    /**
     * 
     * @type {Array<AtendimentoDocumento>}
     * @memberof InlineResponse2008
     */
    results: Array<AtendimentoDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20080
 */
export interface InlineResponse20080 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20080
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20080
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20080
     */
    previous?: string;
    /**
     * 
     * @type {Array<MotivoExclusao>}
     * @memberof InlineResponse20080
     */
    results: Array<MotivoExclusao>;
}
/**
 * 
 * @export
 * @interface InlineResponse20081
 */
export interface InlineResponse20081 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20081
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20081
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20081
     */
    previous?: string;
    /**
     * 
     * @type {Array<MotivoBaixaPrisao>}
     * @memberof InlineResponse20081
     */
    results: Array<MotivoBaixaPrisao>;
}
/**
 * 
 * @export
 * @interface InlineResponse20082
 */
export interface InlineResponse20082 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20082
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20082
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20082
     */
    previous?: string;
    /**
     * 
     * @type {Array<Movel>}
     * @memberof InlineResponse20082
     */
    results: Array<Movel>;
}
/**
 * 
 * @export
 * @interface InlineResponse20083
 */
export interface InlineResponse20083 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20083
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20083
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20083
     */
    previous?: string;
    /**
     * 
     * @type {Array<MudancaRegime>}
     * @memberof InlineResponse20083
     */
    results: Array<MudancaRegime>;
}
/**
 * 
 * @export
 * @interface InlineResponse20084
 */
export interface InlineResponse20084 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20084
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20084
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20084
     */
    previous?: string;
    /**
     * 
     * @type {Array<Municipio>}
     * @memberof InlineResponse20084
     */
    results: Array<Municipio>;
}
/**
 * 
 * @export
 * @interface InlineResponse20085
 */
export interface InlineResponse20085 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20085
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20085
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20085
     */
    previous?: string;
    /**
     * 
     * @type {Array<Nucleo>}
     * @memberof InlineResponse20085
     */
    results: Array<Nucleo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20086
 */
export interface InlineResponse20086 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20086
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20086
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20086
     */
    previous?: string;
    /**
     * 
     * @type {Array<OrientacaoSexual>}
     * @memberof InlineResponse20086
     */
    results: Array<OrientacaoSexual>;
}
/**
 * 
 * @export
 * @interface InlineResponse20087
 */
export interface InlineResponse20087 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20087
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20087
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20087
     */
    previous?: string;
    /**
     * 
     * @type {Array<Pais>}
     * @memberof InlineResponse20087
     */
    results: Array<Pais>;
}
/**
 * 
 * @export
 * @interface InlineResponse20088
 */
export interface InlineResponse20088 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20088
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20088
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20088
     */
    previous?: string;
    /**
     * 
     * @type {Array<Papel>}
     * @memberof InlineResponse20088
     */
    results: Array<Papel>;
}
/**
 * 
 * @export
 * @interface InlineResponse20089
 */
export interface InlineResponse20089 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20089
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20089
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20089
     */
    previous?: string;
    /**
     * 
     * @type {Array<PastaDocumento>}
     * @memberof InlineResponse20089
     */
    results: Array<PastaDocumento>;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2009
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    previous?: string;
    /**
     * 
     * @type {Array<Atendimento>}
     * @memberof InlineResponse2009
     */
    results: Array<Atendimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20090
 */
export interface InlineResponse20090 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20090
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20090
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20090
     */
    previous?: string;
    /**
     * 
     * @type {Array<Patrimonial>}
     * @memberof InlineResponse20090
     */
    results: Array<Patrimonial>;
}
/**
 * 
 * @export
 * @interface InlineResponse20091
 */
export interface InlineResponse20091 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20091
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20091
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20091
     */
    previous?: string;
    /**
     * 
     * @type {Array<Patrimonio>}
     * @memberof InlineResponse20091
     */
    results: Array<Patrimonio>;
}
/**
 * 
 * @export
 * @interface InlineResponse20092
 */
export interface InlineResponse20092 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20092
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20092
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20092
     */
    previous?: string;
    /**
     * 
     * @type {Array<PenaRestritiva>}
     * @memberof InlineResponse20092
     */
    results: Array<PenaRestritiva>;
}
/**
 * 
 * @export
 * @interface InlineResponse20093
 */
export interface InlineResponse20093 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20093
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20093
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20093
     */
    previous?: string;
    /**
     * 
     * @type {Array<Generic>}
     * @memberof InlineResponse20093
     */
    results: Array<Generic>;
}
/**
 * 
 * @export
 * @interface InlineResponse20094
 */
export interface InlineResponse20094 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20094
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20094
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20094
     */
    previous?: string;
    /**
     * 
     * @type {Array<PerfilCamposObrigatorios>}
     * @memberof InlineResponse20094
     */
    results: Array<PerfilCamposObrigatorios>;
}
/**
 * 
 * @export
 * @interface InlineResponse20095
 */
export interface InlineResponse20095 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20095
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20095
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20095
     */
    previous?: string;
    /**
     * 
     * @type {Array<PerguntaAtendimento>}
     * @memberof InlineResponse20095
     */
    results: Array<PerguntaAtendimento>;
}
/**
 * 
 * @export
 * @interface InlineResponse20096
 */
export interface InlineResponse20096 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20096
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20096
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20096
     */
    previous?: string;
    /**
     * 
     * @type {Array<PeticaoTotalMensalSerializar>}
     * @memberof InlineResponse20096
     */
    results: Array<PeticaoTotalMensalSerializar>;
}
/**
 * 
 * @export
 * @interface InlineResponse20097
 */
export interface InlineResponse20097 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20097
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20097
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20097
     */
    previous?: string;
    /**
     * 
     * @type {Array<PredioList>}
     * @memberof InlineResponse20097
     */
    results: Array<PredioList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20098
 */
export interface InlineResponse20098 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20098
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20098
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20098
     */
    previous?: string;
    /**
     * 
     * @type {Array<ParteProcesso>}
     * @memberof InlineResponse20098
     */
    results: Array<ParteProcesso>;
}
/**
 * 
 * @export
 * @interface InlineResponse20099
 */
export interface InlineResponse20099 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20099
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20099
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20099
     */
    previous?: string;
    /**
     * 
     * @type {Array<Prisao>}
     * @memberof InlineResponse20099
     */
    results: Array<Prisao>;
}
/**
 * 
 * @export
 * @interface Interrupcao
 */
export interface Interrupcao {
    /**
     * 
     * @type {number}
     * @memberof Interrupcao
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Interrupcao
     */
    data_inicial: string;
    /**
     * 
     * @type {string}
     * @memberof Interrupcao
     */
    data_final?: string;
    /**
     * 
     * @type {string}
     * @memberof Interrupcao
     */
    observacao?: string;
    /**
     * 
     * @type {Date}
     * @memberof Interrupcao
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Interrupcao
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Interrupcao
     */
    ativo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Interrupcao
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof Interrupcao
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Interrupcao
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface ItineranteEvento
 */
export interface ItineranteEvento {
    /**
     * 
     * @type {number}
     * @memberof ItineranteEvento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ItineranteEvento
     */
    titulo?: string;
    /**
     * 
     * @type {string}
     * @memberof ItineranteEvento
     */
    data_inicial: string;
    /**
     * 
     * @type {string}
     * @memberof ItineranteEvento
     */
    data_final: string;
    /**
     * 
     * @type {Date}
     * @memberof ItineranteEvento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ItineranteEvento
     */
    data_autorizacao?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ItineranteEvento
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ItineranteEvento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItineranteEvento
     */
    municipio: number;
    /**
     * 
     * @type {number}
     * @memberof ItineranteEvento
     */
    defensoria: number;
    /**
     * 
     * @type {number}
     * @memberof ItineranteEvento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ItineranteEvento
     */
    autorizado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ItineranteEvento
     */
    excluido_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ItineranteEvento
     */
    participantes: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ItineranteEvento
     */
    atuacoes: Array<number>;
}
/**
 * 
 * @export
 * @interface Justificativa
 */
export interface Justificativa {
    /**
     * 
     * @type {number}
     * @memberof Justificativa
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Justificativa
     */
    justificativa?: string;
    /**
     * 
     * @type {number}
     * @memberof Justificativa
     */
    atendimento: number;
}
/**
 * 
 * @export
 * @interface Local
 */
export interface Local {
    /**
     * 
     * @type {number}
     * @memberof Local
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Local
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Local
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Local
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Local
     */
    pagina: Local.PaginaEnum;
    /**
     * 
     * @type {number}
     * @memberof Local
     */
    posicao?: number;
    /**
     * 
     * @type {string}
     * @memberof Local
     */
    titulo: string;
    /**
     * 
     * @type {string}
     * @memberof Local
     */
    parametros?: string;
    /**
     * Classe CSS (Ex: fas fa-chart-pie text-success)
     * @type {string}
     * @memberof Local
     */
    classe_css?: string;
    /**
     * 
     * @type {number}
     * @memberof Local
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Local
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Local
     */
    desativado_por?: number;
}

/**
 * @export
 * @namespace Local
 */
export namespace Local {
    /**
     * @export
     * @enum {string}
     */
    export enum PaginaEnum {
        RelatorioListar = <any> 'relatorio_listar',
        AgendamentoConfirmar = <any> 'agendamento_confirmar',
        AssistidoCadastrar = <any> 'assistido_cadastrar',
        AtendimentoAtender = <any> 'atendimento_atender',
        AtendimentoAtenderBtnRequerente = <any> 'atendimento_atender_btn_requerente',
        AtendimentoAtenderBtnRequerido = <any> 'atendimento_atender_btn_requerido',
        AtendimentoConflitosCorrigidos = <any> 'atendimento_conflitos_corrigidos',
        DiligenciaIndex = <any> 'diligencia_index',
        ItineranteIndex = <any> 'itinerante_index',
        LivreDetalhesBtnCalculoHoras = <any> 'livre_detalhes_btn_calculo_horas',
        MultidisciplinarIndex = <any> 'multidisciplinar_index',
        PrecadastroIndex = <any> 'precadastro_index',
        RecepcaoDetalhesBtnCartaConvite = <any> 'recepcao_detalhes_btn_carta_convite',
        RecepcaoDetalhesBtnRequerente = <any> 'recepcao_detalhes_btn_requerente',
        RecepcaoDetalhesBtnRequerido = <any> 'recepcao_detalhes_btn_requerido',
        PropacDetalhes = <any> 'propac_detalhes'
    }
}
/**
 * 
 * @export
 * @interface Manifestacao
 */
export interface Manifestacao {
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Manifestacao
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Manifestacao
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Manifestacao
     */
    desativado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Manifestacao
     */
    enviado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Manifestacao
     */
    respondido_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Manifestacao
     */
    protocolo_resposta?: string;
    /**
     * 
     * @type {string}
     * @memberof Manifestacao
     */
    mensagem_resposta?: string;
    /**
     * Código Identificador da Manifestação no ProcAPI
     * @type {string}
     * @memberof Manifestacao
     */
    codigo_procapi?: string;
    /**
     * Identificador do Sistema Webservice no ProcAPI
     * @type {string}
     * @memberof Manifestacao
     */
    sistema_webservice?: string;
    /**
     * Identificador do Usuário Webservice no ProcAPI
     * @type {string}
     * @memberof Manifestacao
     */
    usuario_webservice?: string;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    tipo?: number;
    /**
     * Tipo do Evento no MNI
     * @type {number}
     * @memberof Manifestacao
     */
    tipo_evento?: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    situacao?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Manifestacao
     */
    enviando?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Manifestacao
     */
    enviado?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    parte: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    defensoria?: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    defensor?: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    manifestante?: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    enviado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Manifestacao
     */
    fase?: number;
}
/**
 * 
 * @export
 * @interface ManifestacaoAviso
 */
export interface ManifestacaoAviso {
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoAviso
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ManifestacaoAviso
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ManifestacaoAviso
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ManifestacaoAviso
     */
    desativado_em?: Date;
    /**
     * Número do Aviso no Tribunal de Justiça
     * @type {string}
     * @memberof ManifestacaoAviso
     */
    numero?: string;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoAviso
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoAviso
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoAviso
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoAviso
     */
    manifestacao: number;
}
/**
 * 
 * @export
 * @interface ManifestacaoDocumento
 */
export interface ManifestacaoDocumento {
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ManifestacaoDocumento
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ManifestacaoDocumento
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ManifestacaoDocumento
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    origem?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    origem_id: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    posicao?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    tipo_mni?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    nivel_sigilo?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ManifestacaoDocumento
     */
    manifestacao: number;
}
/**
 * 
 * @export
 * @interface Menu
 */
export interface Menu {
    /**
     * 
     * @type {string}
     * @memberof Menu
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Menu
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof Menu
     */
    icon: string;
    /**
     * 
     * @type {Array<SubMenu>}
     * @memberof Menu
     */
    submenus?: Array<SubMenu>;
}
/**
 * 
 * @export
 * @interface MenuExtra
 */
export interface MenuExtra {
    /**
     * 
     * @type {number}
     * @memberof MenuExtra
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof MenuExtra
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MenuExtra
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MenuExtra
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof MenuExtra
     */
    local?: MenuExtra.LocalEnum;
    /**
     * 
     * @type {number}
     * @memberof MenuExtra
     */
    posicao: number;
    /**
     * 
     * @type {string}
     * @memberof MenuExtra
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof MenuExtra
     */
    descricao: string;
    /**
     * 
     * @type {string}
     * @memberof MenuExtra
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof MenuExtra
     */
    icone: string;
    /**
     * 
     * @type {number}
     * @memberof MenuExtra
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof MenuExtra
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof MenuExtra
     */
    desativado_por?: number;
}

/**
 * @export
 * @namespace MenuExtra
 */
export namespace MenuExtra {
    /**
     * @export
     * @enum {string}
     */
    export enum LocalEnum {
        Root = <any> 'root',
        Ajuda = <any> 'ajuda',
        Convenios = <any> 'convenios'
    }
}
/**
 * 
 * @export
 * @interface Moradia
 */
export interface Moradia {
    /**
     * 
     * @type {number}
     * @memberof Moradia
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Moradia
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof Moradia
     */
    num_comodos?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Moradia
     */
    estrutura?: Array<number>;
}
/**
 * 
 * @export
 * @interface MotivoBaixaPrisao
 */
export interface MotivoBaixaPrisao {
    /**
     * 
     * @type {number}
     * @memberof MotivoBaixaPrisao
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof MotivoBaixaPrisao
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MotivoBaixaPrisao
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MotivoBaixaPrisao
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof MotivoBaixaPrisao
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof MotivoBaixaPrisao
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof MotivoBaixaPrisao
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof MotivoBaixaPrisao
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface MotivoExclusao
 */
export interface MotivoExclusao {
    /**
     * 
     * @type {number}
     * @memberof MotivoExclusao
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof MotivoExclusao
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MotivoExclusao
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MotivoExclusao
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof MotivoExclusao
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof MotivoExclusao
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof MotivoExclusao
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof MotivoExclusao
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface Movel
 */
export interface Movel {
    /**
     * 
     * @type {number}
     * @memberof Movel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Movel
     */
    marca?: string;
    /**
     * 
     * @type {string}
     * @memberof Movel
     */
    modelo?: string;
    /**
     * 
     * @type {number}
     * @memberof Movel
     */
    pagamento: number;
    /**
     * 
     * @type {string}
     * @memberof Movel
     */
    banco?: string;
    /**
     * 
     * @type {number}
     * @memberof Movel
     */
    parcelas: number;
    /**
     * 
     * @type {string}
     * @memberof Movel
     */
    valor_parcela: string;
    /**
     * 
     * @type {string}
     * @memberof Movel
     */
    valor_total: string;
    /**
     * 
     * @type {number}
     * @memberof Movel
     */
    patrimonio: number;
}
/**
 * 
 * @export
 * @interface Movimento
 */
export interface Movimento {
    /**
     * 
     * @type {number}
     * @memberof Movimento
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Movimento
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof Movimento
     */
    anotacao?: string;
    /**
     * 
     * @type {string}
     * @memberof Movimento
     */
    anexo?: string;
    /**
     * 
     * @type {string}
     * @memberof Movimento
     */
    valor_estimado?: string;
    /**
     * 
     * @type {string}
     * @memberof Movimento
     */
    valor_efetivo?: string;
    /**
     * 
     * @type {string}
     * @memberof Movimento
     */
    valor_atualizado?: string;
    /**
     * 
     * @type {Date}
     * @memberof Movimento
     */
    data_atualizacao_valor?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Movimento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Movimento
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Movimento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Movimento
     */
    honorario?: number;
    /**
     * 
     * @type {number}
     * @memberof Movimento
     */
    defensor?: number;
    /**
     * 
     * @type {number}
     * @memberof Movimento
     */
    defensoria?: number;
    /**
     * 
     * @type {number}
     * @memberof Movimento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Movimento
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface MovimentoTipo
 */
export interface MovimentoTipo {
    /**
     * 
     * @type {number}
     * @memberof MovimentoTipo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MovimentoTipo
     */
    nome?: string;
    /**
     * 
     * @type {string}
     * @memberof MovimentoTipo
     */
    codigo?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MovimentoTipo
     */
    instauracao?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MovimentoTipo
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface MudancaRegime
 */
export interface MudancaRegime {
    /**
     * 
     * @type {number}
     * @memberof MudancaRegime
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof MudancaRegime
     */
    tipo: number;
    /**
     * 
     * @type {number}
     * @memberof MudancaRegime
     */
    regime: number;
    /**
     * 
     * @type {Date}
     * @memberof MudancaRegime
     */
    data_registro: Date;
    /**
     * 
     * @type {Date}
     * @memberof MudancaRegime
     */
    data_base: Date;
    /**
     * 
     * @type {string}
     * @memberof MudancaRegime
     */
    historico?: string;
    /**
     * 
     * @type {Date}
     * @memberof MudancaRegime
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MudancaRegime
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof MudancaRegime
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MudancaRegime
     */
    prisao: number;
    /**
     * 
     * @type {number}
     * @memberof MudancaRegime
     */
    estabelecimento_penal?: number;
    /**
     * 
     * @type {number}
     * @memberof MudancaRegime
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof MudancaRegime
     */
    excluido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof MudancaRegime
     */
    evento?: number;
}
/**
 * 
 * @export
 * @interface Municipio
 */
export interface Municipio {
    /**
     * 
     * @type {number}
     * @memberof Municipio
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Municipio
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof Municipio
     */
    estado: number;
    /**
     * 
     * @type {number}
     * @memberof Municipio
     */
    comarca?: number;
}
/**
 * 
 * @export
 * @interface MunicipioRetrive
 */
export interface MunicipioRetrive {
    /**
     * 
     * @type {number}
     * @memberof MunicipioRetrive
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MunicipioRetrive
     */
    nome: string;
    /**
     * 
     * @type {Generic}
     * @memberof MunicipioRetrive
     */
    estado: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof MunicipioRetrive
     */
    comarca: Generic;
}
/**
 * 
 * @export
 * @interface Nucleo
 */
export interface Nucleo {
    /**
     * 
     * @type {number}
     * @memberof Nucleo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Nucleo
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof Nucleo
     */
    nivel?: number;
    /**
     * Aceita receber pedidos de apoio?
     * @type {boolean}
     * @memberof Nucleo
     */
    apoio?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Nucleo
     */
    apoio_pode_registrar_atividades?: boolean;
    /**
     * Aceita receber agendamentos (inicial/retorno)?
     * @type {boolean}
     * @memberof Nucleo
     */
    agendamento?: boolean;
    /**
     * Aceita receber agendamentos via encaminhamento?
     * @type {boolean}
     * @memberof Nucleo
     */
    encaminhamento?: boolean;
    /**
     * Aceita registrar atendimentos de acordo?
     * @type {boolean}
     * @memberof Nucleo
     */
    acordo?: boolean;
    /**
     * Aceita registrar atendimentos coletivos?
     * @type {boolean}
     * @memberof Nucleo
     */
    coletivo?: boolean;
    /**
     * Os assessores/estagiários só verão os atendimentos a que lhe forem distribuídos
     * @type {boolean}
     * @memberof Nucleo
     */
    supervisionado?: boolean;
    /**
     * É um núcleo Recursal?
     * @type {boolean}
     * @memberof Nucleo
     */
    recursal?: boolean;
    /**
     * É um núcleo Itinerante/Multirão?
     * @type {boolean}
     * @memberof Nucleo
     */
    itinerante?: boolean;
    /**
     * É um núcleo de Plantão?
     * @type {boolean}
     * @memberof Nucleo
     */
    plantao?: boolean;
    /**
     * É um núcleo Multidisciplinar?
     * @type {boolean}
     * @memberof Nucleo
     */
    multidisciplinar?: boolean;
    /**
     * É um núcleo de Diligências?
     * @type {boolean}
     * @memberof Nucleo
     */
    diligencia?: boolean;
    /**
     * Tem acesso ao módulo Honorários?
     * @type {boolean}
     * @memberof Nucleo
     */
    honorario?: boolean;
    /**
     * Tem acesso ao módulo Propacs?
     * @type {boolean}
     * @memberof Nucleo
     */
    propac?: boolean;
    /**
     * Tem acesso ao módulo Livre?
     * @type {boolean}
     * @memberof Nucleo
     */
    livre?: boolean;
    /**
     * Tem acesso ao módulo Indeferimento?
     * @type {boolean}
     * @memberof Nucleo
     */
    indeferimento?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Nucleo
     */
    indeferimento_pode_receber_negacao?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Nucleo
     */
    indeferimento_pode_receber_suspeicao?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Nucleo
     */
    indeferimento_pode_receber_impedimento?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Nucleo
     */
    indeferimento_pode_registrar_decisao?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Nucleo
     */
    indeferimento_pode_registrar_baixa?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Nucleo
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Nucleo
     */
    nucleo?: number;
}
/**
 * 
 * @export
 * @interface OrientacaoSexual
 */
export interface OrientacaoSexual {
    /**
     * 
     * @type {number}
     * @memberof OrientacaoSexual
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof OrientacaoSexual
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof OrientacaoSexual
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof OrientacaoSexual
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof OrientacaoSexual
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof OrientacaoSexual
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof OrientacaoSexual
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof OrientacaoSexual
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface OutroParametro
 */
export interface OutroParametro {
    /**
     * 
     * @type {number}
     * @memberof OutroParametro
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof OutroParametro
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof OutroParametro
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof OutroParametro
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof OutroParametro
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof OutroParametro
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof OutroParametro
     */
    lista?: string;
    /**
     * 
     * @type {string}
     * @memberof OutroParametro
     */
    codigo_mni: string;
    /**
     * 
     * @type {number}
     * @memberof OutroParametro
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof OutroParametro
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof OutroParametro
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface PainelDeAviso
 */
export interface PainelDeAviso {
    /**
     * 
     * @type {number}
     * @memberof PainelDeAviso
     */
    total_geral: number;
    /**
     * 
     * @type {Array<PainelDeAvisoGrupo>}
     * @memberof PainelDeAviso
     */
    prateleiras: Array<PainelDeAvisoGrupo>;
}
/**
 * 
 * @export
 * @interface PainelDeAvisoGrupo
 */
export interface PainelDeAvisoGrupo {
    /**
     * 
     * @type {string}
     * @memberof PainelDeAvisoGrupo
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PainelDeAvisoGrupo
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof PainelDeAvisoGrupo
     */
    total: number;
    /**
     * 
     * @type {Array<PainelDeAvisoItem>}
     * @memberof PainelDeAvisoGrupo
     */
    itens: Array<PainelDeAvisoItem>;
}
/**
 * 
 * @export
 * @interface PainelDeAvisoItem
 */
export interface PainelDeAvisoItem {
    /**
     * 
     * @type {number}
     * @memberof PainelDeAvisoItem
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PainelDeAvisoItem
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof PainelDeAvisoItem
     */
    total: number;
}
/**
 * 
 * @export
 * @interface Pais
 */
export interface Pais {
    /**
     * 
     * @type {number}
     * @memberof Pais
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Pais
     */
    iso: string;
    /**
     * 
     * @type {string}
     * @memberof Pais
     */
    iso3: string;
    /**
     * 
     * @type {string}
     * @memberof Pais
     */
    numero?: string;
    /**
     * 
     * @type {string}
     * @memberof Pais
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof Pais
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface Papel
 */
export interface Papel {
    /**
     * 
     * @type {number}
     * @memberof Papel
     */
    id?: number;
    /**
     * 
     * @type {Array<Generic>}
     * @memberof Papel
     */
    grupos?: Array<Generic>;
    /**
     * 
     * @type {string}
     * @memberof Papel
     */
    nome: string;
    /**
     * Exige informar um supervisor no cadastro do servidor?
     * @type {boolean}
     * @memberof Papel
     */
    requer_supervisor?: boolean;
    /**
     * Exige informar a matrícula no cadastro do servidor?
     * @type {boolean}
     * @memberof Papel
     */
    requer_matricula?: boolean;
    /**
     * Disponível apenas para superusuários?
     * @type {boolean}
     * @memberof Papel
     */
    requer_superusuario?: boolean;
    /**
     * Marcar usuário como defensor?
     * @type {boolean}
     * @memberof Papel
     */
    marcar_usuario_como_defensor?: boolean;
    /**
     * Usado para definir a cor de labels
     * @type {string}
     * @memberof Papel
     */
    css_label_class?: Papel.CssLabelClassEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Papel
     */
    ativo?: boolean;
}

/**
 * @export
 * @namespace Papel
 */
export namespace Papel {
    /**
     * @export
     * @enum {string}
     */
    export enum CssLabelClassEnum {
        Empty = <any> '',
        LabelSuccess = <any> 'label-success',
        LabelWarning = <any> 'label-warning',
        LabelImportant = <any> 'label-important',
        LabelInfo = <any> 'label-info',
        LabelInverse = <any> 'label-inverse'
    }
}
/**
 * 
 * @export
 * @interface Parte
 */
export interface Parte {
    /**
     * 
     * @type {number}
     * @memberof Parte
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Parte
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Parte
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Parte
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof Parte
     */
    tipo: number;
    /**
     * 
     * @type {number}
     * @memberof Parte
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Parte
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Parte
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Parte
     */
    processo: number;
    /**
     * 
     * @type {number}
     * @memberof Parte
     */
    pessoa: number;
}
/**
 * 
 * @export
 * @interface ParteAtendimentoRecepcao
 */
export interface ParteAtendimentoRecepcao {
    /**
     * 
     * @type {number}
     * @memberof ParteAtendimentoRecepcao
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ParteAtendimentoRecepcao
     */
    pessoa_id: number;
    /**
     * 
     * @type {string}
     * @memberof ParteAtendimentoRecepcao
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof ParteAtendimentoRecepcao
     */
    nome_social: string;
    /**
     * 
     * @type {string}
     * @memberof ParteAtendimentoRecepcao
     */
    apelido: string;
    /**
     * 
     * @type {string}
     * @memberof ParteAtendimentoRecepcao
     */
    cpf: string;
    /**
     * 
     * @type {number}
     * @memberof ParteAtendimentoRecepcao
     */
    tipo: number;
}
/**
 * 
 * @export
 * @interface ParteHistoricoTransferencia
 */
export interface ParteHistoricoTransferencia {
    /**
     * 
     * @type {number}
     * @memberof ParteHistoricoTransferencia
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ParteHistoricoTransferencia
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ParteHistoricoTransferencia
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ParteHistoricoTransferencia
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof ParteHistoricoTransferencia
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ParteHistoricoTransferencia
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ParteHistoricoTransferencia
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ParteHistoricoTransferencia
     */
    parte: number;
    /**
     * 
     * @type {string}
     * @memberof ParteHistoricoTransferencia
     */
    atendimento_antigo: string;
    /**
     * 
     * @type {string}
     * @memberof ParteHistoricoTransferencia
     */
    atendimento_novo: string;
}
/**
 * 
 * @export
 * @interface ParteProcesso
 */
export interface ParteProcesso {
    /**
     * 
     * @type {number}
     * @memberof ParteProcesso
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ParteProcesso
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ParteProcesso
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ParteProcesso
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof ParteProcesso
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof ParteProcesso
     */
    codigo_mni: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParteProcesso
     */
    disponivel_para_peticionamento?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ParteProcesso
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ParteProcesso
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ParteProcesso
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface PastaDocumento
 */
export interface PastaDocumento {
    /**
     * 
     * @type {number}
     * @memberof PastaDocumento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PastaDocumento
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof PastaDocumento
     */
    descricao?: string;
    /**
     * 
     * @type {number}
     * @memberof PastaDocumento
     */
    atendimento: number;
}
/**
 * 
 * @export
 * @interface Patrimonial
 */
export interface Patrimonial {
    /**
     * 
     * @type {number}
     * @memberof Patrimonial
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Patrimonial
     */
    eh_bem_familia?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Patrimonial
     */
    pessoa?: number;
    /**
     * 
     * @type {PatrimonialTipo}
     * @memberof Patrimonial
     */
    tipo: PatrimonialTipo;
    /**
     * 
     * @type {string}
     * @memberof Patrimonial
     */
    descricao?: string;
    /**
     * 
     * @type {string}
     * @memberof Patrimonial
     */
    valor?: string;
}
/**
 * 
 * @export
 * @interface PatrimonialTipo
 */
export interface PatrimonialTipo {
    /**
     * 
     * @type {number}
     * @memberof PatrimonialTipo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatrimonialTipo
     */
    grupo_nome?: string;
    /**
     * 
     * @type {Date}
     * @memberof PatrimonialTipo
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PatrimonialTipo
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PatrimonialTipo
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof PatrimonialTipo
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof PatrimonialTipo
     */
    grupo?: number;
    /**
     * 
     * @type {number}
     * @memberof PatrimonialTipo
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PatrimonialTipo
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PatrimonialTipo
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface Patrimonio
 */
export interface Patrimonio {
    /**
     * 
     * @type {number}
     * @memberof Patrimonio
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Patrimonio
     */
    tem_imoveis?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Patrimonio
     */
    quantidade_imoveis?: number;
    /**
     * Valor total, em R$, dos bens imóveis
     * @type {string}
     * @memberof Patrimonio
     */
    valor_imoveis?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Patrimonio
     */
    tem_moveis?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Patrimonio
     */
    quantidade_moveis?: number;
    /**
     * Valor total, em R$, dos bens móveis
     * @type {string}
     * @memberof Patrimonio
     */
    valor_moveis?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Patrimonio
     */
    tem_outros_bens?: boolean;
    /**
     * Valor total, em R$, de outros bens e direitos
     * @type {string}
     * @memberof Patrimonio
     */
    valor_outros_bens?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Patrimonio
     */
    tem_investimentos?: boolean;
    /**
     * Valor total, em R$, de aplicações ou investimentos financeiros
     * @type {string}
     * @memberof Patrimonio
     */
    valor_investimentos?: string;
    /**
     * 
     * @type {number}
     * @memberof Patrimonio
     */
    pessoa?: number;
}
/**
 * 
 * @export
 * @interface PenaRestritiva
 */
export interface PenaRestritiva {
    /**
     * 
     * @type {number}
     * @memberof PenaRestritiva
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PenaRestritiva
     */
    restricao: number;
    /**
     * 
     * @type {boolean}
     * @memberof PenaRestritiva
     */
    ativo?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof PenaRestritiva
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PenaRestritiva
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {number}
     * @memberof PenaRestritiva
     */
    prisao: number;
    /**
     * 
     * @type {number}
     * @memberof PenaRestritiva
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PenaRestritiva
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface PerfilCamposObrigatorios
 */
export interface PerfilCamposObrigatorios {
    /**
     * 
     * @type {number}
     * @memberof PerfilCamposObrigatorios
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PerfilCamposObrigatorios
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof PerfilCamposObrigatorios
     */
    tipo_processo?: number;
    /**
     * 
     * @type {number}
     * @memberof PerfilCamposObrigatorios
     */
    tipo_parte?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PerfilCamposObrigatorios
     */
    parte_principal?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PerfilCamposObrigatorios
     */
    configuracao: string;
    /**
     * 
     * @type {number}
     * @memberof PerfilCamposObrigatorios
     */
    tipo_pessoa?: number;
}
/**
 * 
 * @export
 * @interface PerguntaAtendimento
 */
export interface PerguntaAtendimento {
    /**
     * 
     * @type {number}
     * @memberof PerguntaAtendimento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PerguntaAtendimento
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof PerguntaAtendimento
     */
    texto?: string;
    /**
     * 
     * @type {string}
     * @memberof PerguntaAtendimento
     */
    dica?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PerguntaAtendimento
     */
    obrigatorio?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PerguntaAtendimento
     */
    qualificacao: number;
}
/**
 * 
 * @export
 * @interface Pessoa
 */
export interface Pessoa {
    /**
     * 
     * @type {number}
     * @memberof Pessoa
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Pessoa
     */
    representante_modalidade?: Pessoa.RepresentanteModalidadeEnum;
    /**
     * 
     * @type {number}
     * @memberof Pessoa
     */
    tipo: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pessoa
     */
    responsavel?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pessoa
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Pessoa
     */
    atendimento: number;
    /**
     * 
     * @type {string}
     * @memberof Pessoa
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof Pessoa
     */
    representante?: number;
}

/**
 * @export
 * @namespace Pessoa
 */
export namespace Pessoa {
    /**
     * @export
     * @enum {string}
     */
    export enum RepresentanteModalidadeEnum {
        P = <any> 'P',
        AP = <any> 'AP',
        SP = <any> 'SP',
        T = <any> 'T',
        C = <any> 'C'
    }
}
/**
 * 
 * @export
 * @interface PessoaAssistida
 */
export interface PessoaAssistida {
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    id?: number;
    /**
     * 
     * @type {Array<Filiacao>}
     * @memberof PessoaAssistida
     */
    filiacoes: Array<Filiacao>;
    /**
     * 
     * @type {Array<Telefone>}
     * @memberof PessoaAssistida
     */
    telefones: Array<Telefone>;
    /**
     * 
     * @type {Array<Endereco>}
     * @memberof PessoaAssistida
     */
    enderecos: Array<Endereco>;
    /**
     * 
     * @type {Array<PessoaPatrimonial>}
     * @memberof PessoaAssistida
     */
    patrimonios?: Array<PessoaPatrimonial>;
    /**
     * 
     * @type {Array<PessoaDependente>}
     * @memberof PessoaAssistida
     */
    dependentes?: Array<PessoaDependente>;
    /**
     * 
     * @type {Renda}
     * @memberof PessoaAssistida
     */
    renda: Renda;
    /**
     * 
     * @type {Moradia}
     * @memberof PessoaAssistida
     */
    moradia: Moradia;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    hipossuficiente?: string;
    /**
     * 
     * @type {Date}
     * @memberof PessoaAssistida
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PessoaAssistida
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PessoaAssistida
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    apelido?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    data_nascimento?: string;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    sexo?: number;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    cpf?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    rg_numero?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    rg_orgao?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    rg_data_expedicao?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    certidao_tipo?: PessoaAssistida.CertidaoTipoEnum;
    /**
     * Novo modelo (32 dígitos)
     * @type {string}
     * @memberof PessoaAssistida
     */
    certidao_numero?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    nome_social?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    declara_orientacao_sexual?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    declara_identidade_genero?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    cadastro_protegido?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    aderiu_zap_defensoria?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    aderiu_luna_chatbot?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    aderiu_sms?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    aderiu_edefensor?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    estado_civil?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    qtd_filhos?: number;
    /**
     * Quantidade de pessoas que morando junto, incluido assistido
     * @type {number}
     * @memberof PessoaAssistida
     */
    qtd_pessoas?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    escolaridade?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    tipo_trabalho?: number;
    /**
     * Quantidade de anos que reside no Estado em que vive
     * @type {number}
     * @memberof PessoaAssistida
     */
    qtd_estado?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    raca?: number;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    naturalidade?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    naturalidade_estado?: string;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    nacionalidade?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    cartao_sus?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaAssistida
     */
    plano_saude?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PessoaAssistida
     */
    foto?: string;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    orientacao_sexual?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    identidade_genero?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    genero?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    naturalidade_pais?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaAssistida
     */
    profissao?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof PessoaAssistida
     */
    situacoes?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof PessoaAssistida
     */
    deficiencias?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof PessoaAssistida
     */
    bens?: Array<number>;
}

/**
 * @export
 * @namespace PessoaAssistida
 */
export namespace PessoaAssistida {
    /**
     * @export
     * @enum {string}
     */
    export enum CertidaoTipoEnum {
        CN = <any> 'CN',
        CC = <any> 'CC'
    }
}
/**
 * 
 * @export
 * @interface PessoaDependente
 */
export interface PessoaDependente {
    /**
     * 
     * @type {number}
     * @memberof PessoaDependente
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PessoaDependente
     */
    situacao_str?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaDependente
     */
    parentesco_str?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaDependente
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof PessoaDependente
     */
    situacao?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaDependente
     */
    parentesco: number;
    /**
     * Ganhos mensais, em R$, do dependente
     * @type {string}
     * @memberof PessoaDependente
     */
    renda?: string;
    /**
     * 
     * @type {number}
     * @memberof PessoaDependente
     */
    situacao_dependente?: number;
    /**
     * 
     * @type {number}
     * @memberof PessoaDependente
     */
    tipo_renda?: number;
}
/**
 * 
 * @export
 * @interface PessoaPatrimonial
 */
export interface PessoaPatrimonial {
    /**
     * 
     * @type {number}
     * @memberof PessoaPatrimonial
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PessoaPatrimonial
     */
    tipo_str?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaPatrimonial
     */
    grupo_str?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaPatrimonial
     */
    valor?: string;
    /**
     * 
     * @type {string}
     * @memberof PessoaPatrimonial
     */
    descricao?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PessoaPatrimonial
     */
    eh_bem_familia?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PessoaPatrimonial
     */
    tipo?: number;
}
/**
 * 
 * @export
 * @interface PeticaoTotalMensalSerializar
 */
export interface PeticaoTotalMensalSerializar {
    /**
     * 
     * @type {string}
     * @memberof PeticaoTotalMensalSerializar
     */
    tipo: string;
    /**
     * 
     * @type {number}
     * @memberof PeticaoTotalMensalSerializar
     */
    area_id: number;
    /**
     * 
     * @type {number}
     * @memberof PeticaoTotalMensalSerializar
     */
    quantidade: number;
}
/**
 * 
 * @export
 * @interface Predio
 */
export interface Predio {
    /**
     * 
     * @type {number}
     * @memberof Predio
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Predio
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof Predio
     */
    visao_comarca?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Predio
     */
    recepcao_por_atuacao?: boolean;
    /**
     * Deixar zero caso tenha somente o térreo
     * @type {number}
     * @memberof Predio
     */
    qtd_andares?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Predio
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Predio
     */
    comarca: number;
    /**
     * 
     * @type {number}
     * @memberof Predio
     */
    endereco?: number;
    /**
     * 
     * @type {number}
     * @memberof Predio
     */
    telefone?: number;
}
/**
 * 
 * @export
 * @interface PredioCreate
 */
export interface PredioCreate {
    /**
     * 
     * @type {number}
     * @memberof PredioCreate
     */
    id?: number;
    /**
     * 
     * @type {TelefoneSerializer}
     * @memberof PredioCreate
     */
    telefone: TelefoneSerializer;
    /**
     * 
     * @type {number}
     * @memberof PredioCreate
     */
    comarca: number;
    /**
     * 
     * @type {EnderecoCreate}
     * @memberof PredioCreate
     */
    endereco: EnderecoCreate;
    /**
     * 
     * @type {string}
     * @memberof PredioCreate
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof PredioCreate
     */
    visao_comarca?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PredioCreate
     */
    recepcao_por_atuacao?: boolean;
    /**
     * Deixar zero caso tenha somente o térreo
     * @type {number}
     * @memberof PredioCreate
     */
    qtd_andares?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PredioCreate
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface PredioList
 */
export interface PredioList {
    /**
     * 
     * @type {number}
     * @memberof PredioList
     */
    id?: number;
    /**
     * 
     * @type {Generic}
     * @memberof PredioList
     */
    telefone: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof PredioList
     */
    comarca: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof PredioList
     */
    endereco: Generic;
    /**
     * 
     * @type {string}
     * @memberof PredioList
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof PredioList
     */
    visao_comarca?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PredioList
     */
    recepcao_por_atuacao?: boolean;
    /**
     * Deixar zero caso tenha somente o térreo
     * @type {number}
     * @memberof PredioList
     */
    qtd_andares?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PredioList
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface PredioRetrieve
 */
export interface PredioRetrieve {
    /**
     * 
     * @type {number}
     * @memberof PredioRetrieve
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PredioRetrieve
     */
    nome: string;
    /**
     * Deixar zero caso tenha somente o térreo
     * @type {number}
     * @memberof PredioRetrieve
     */
    qtd_andares?: number;
    /**
     * 
     * @type {number}
     * @memberof PredioRetrieve
     */
    comarca: number;
    /**
     * 
     * @type {EnderecoRetrive}
     * @memberof PredioRetrieve
     */
    endereco: EnderecoRetrive;
    /**
     * 
     * @type {TelefoneSerializer}
     * @memberof PredioRetrieve
     */
    telefone: TelefoneSerializer;
}
/**
 * 
 * @export
 * @interface Prisao
 */
export interface Prisao {
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    pena?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    infopen?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_fato?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_prisao?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_termino?: string;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    tentado_consumado?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    situacao?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    regime_inicial?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    regime_atual?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    duracao_pena_anos?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    duracao_pena_meses?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    duracao_pena_dias?: number;
    /**
     * Formato DD HH:mm:ss ou HHH:mm:ss
     * @type {string}
     * @memberof Prisao
     */
    duracao_pena_horas?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    prestacao_pecuniaria?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    multa?: string;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    fracao_pr?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    fracao_lc?: number;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_recebimento_denuncia?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_pronuncia?: string;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    resultado_pronuncia?: number;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    historico_pronuncia?: string;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    resultado_sentenca?: number;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_sentenca_condenatoria?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_transito_defensor?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_transito_acusacao?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_transito_apenado?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_liquidacao?: string;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_base?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Prisao
     */
    reicidente?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    data_baixa?: string;
    /**
     * 
     * @type {Date}
     * @memberof Prisao
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Prisao
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Prisao
     */
    ativo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Prisao
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    processo?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    parte?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    origem?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    local_prisao?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    estabelecimento_penal?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    tipificacao?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    motivo_baixa?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    baixado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Prisao
     */
    excluido_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Prisao
     */
    eventos?: Array<number>;
}
/**
 * 
 * @export
 * @interface Procedimento
 */
export interface Procedimento {
    /**
     * 
     * @type {number}
     * @memberof Procedimento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Procedimento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {number}
     * @memberof Procedimento
     */
    tipo: number;
    /**
     * 
     * @type {number}
     * @memberof Procedimento
     */
    ligacao: number;
    /**
     * 
     * @type {string}
     * @memberof Procedimento
     */
    agendamento?: string;
    /**
     * 
     * @type {number}
     * @memberof Procedimento
     */
    informacao?: number;
    /**
     * 
     * @type {number}
     * @memberof Procedimento
     */
    encaminhamento?: number;
    /**
     * 
     * @type {number}
     * @memberof Procedimento
     */
    attprocedimento?: number;
    /**
     * 
     * @type {number}
     * @memberof Procedimento
     */
    atendente?: number;
}
/**
 * 
 * @export
 * @interface Processo
 */
export interface Processo {
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    id?: number;
    /**
     * 
     * @type {Generic}
     * @memberof Processo
     */
    comarca: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof Processo
     */
    area: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof Processo
     */
    vara: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof Processo
     */
    acao: Generic;
    /**
     * 
     * @type {Array<ParteProcesso>}
     * @memberof Processo
     */
    partes?: Array<ParteProcesso>;
    /**
     * 
     * @type {string}
     * @memberof Processo
     */
    numero?: string;
    /**
     * 
     * @type {string}
     * @memberof Processo
     */
    numero_puro: string;
    /**
     * 
     * @type {string}
     * @memberof Processo
     */
    chave?: string;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    grau?: number;
    /**
     * 
     * @type {string}
     * @memberof Processo
     */
    credencial_mni_cadastro?: string;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    nivel_sigilo?: number;
    /**
     * Intervenção do Ministério Público?
     * @type {boolean}
     * @memberof Processo
     */
    intervencao_mp?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    valor_causa?: number;
    /**
     * 
     * @type {string}
     * @memberof Processo
     */
    calculo_judicial?: string;
    /**
     * 
     * @type {string}
     * @memberof Processo
     */
    competencia_mni?: string;
    /**
     * 
     * @type {string}
     * @memberof Processo
     */
    acao_cnj?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Processo
     */
    pre_cadastro?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Processo
     */
    parte_pre_cadastro?: string;
    /**
     * 
     * @type {Date}
     * @memberof Processo
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Processo
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Processo
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Processo
     */
    ultima_modificacao?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Processo
     */
    ultima_consulta?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Processo
     */
    atualizando?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Processo
     */
    atualizado?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    situacao?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Processo
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    originario?: number;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    peticao_inicial?: number;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Processo
     */
    excluido_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Processo
     */
    assuntos?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Processo
     */
    prioridades?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Processo
     */
    outros_parametros?: Array<number>;
}
/**
 * 
 * @export
 * @interface ProcessoApenso
 */
export interface ProcessoApenso {
    /**
     * 
     * @type {number}
     * @memberof ProcessoApenso
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ProcessoApenso
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ProcessoApenso
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProcessoApenso
     */
    pai?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessoApenso
     */
    apensado?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessoApenso
     */
    apensado_por?: number;
}
/**
 * 
 * @export
 * @interface ProcessoPoloDestinatario
 */
export interface ProcessoPoloDestinatario {
    /**
     * 
     * @type {number}
     * @memberof ProcessoPoloDestinatario
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ProcessoPoloDestinatario
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ProcessoPoloDestinatario
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ProcessoPoloDestinatario
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof ProcessoPoloDestinatario
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessoPoloDestinatario
     */
    sigla_sistema_webservice: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessoPoloDestinatario
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessoPoloDestinatario
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessoPoloDestinatario
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface ProcessosAssuntos
 */
export interface ProcessosAssuntos {
    /**
     * 
     * @type {number}
     * @memberof ProcessosAssuntos
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessosAssuntos
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessosAssuntos
     */
    codigo_eproc?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessosAssuntos
     */
    codigo_cnj?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProcessosAssuntos
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface Profissao
 */
export interface Profissao {
    /**
     * 
     * @type {number}
     * @memberof Profissao
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Profissao
     */
    codigo: string;
    /**
     * 
     * @type {string}
     * @memberof Profissao
     */
    nome: string;
}
/**
 * 
 * @export
 * @interface PropacMovimento
 */
export interface PropacMovimento {
    /**
     * 
     * @type {number}
     * @memberof PropacMovimento
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PropacMovimento
     */
    eh_precadastro?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof PropacMovimento
     */
    data_movimento?: Date;
    /**
     * 
     * @type {number}
     * @memberof PropacMovimento
     */
    volume: number;
    /**
     * 
     * @type {number}
     * @memberof PropacMovimento
     */
    ordem_volume: number;
    /**
     * 
     * @type {boolean}
     * @memberof PropacMovimento
     */
    ativo?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof PropacMovimento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PropacMovimento
     */
    data_remocao?: Date;
    /**
     * 
     * @type {string}
     * @memberof PropacMovimento
     */
    motivo_remocao?: string;
    /**
     * 
     * @type {Date}
     * @memberof PropacMovimento
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {string}
     * @memberof PropacMovimento
     */
    historico?: string;
    /**
     * 
     * @type {number}
     * @memberof PropacMovimento
     */
    procedimento?: number;
    /**
     * 
     * @type {number}
     * @memberof PropacMovimento
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof PropacMovimento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PropacMovimento
     */
    removido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PropacMovimento
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface PropacProcedimento
 */
export interface PropacProcedimento {
    /**
     * 
     * @type {number}
     * @memberof PropacProcedimento
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PropacProcedimento
     */
    defensor_responsavel_nome?: string;
    /**
     * 
     * @type {string}
     * @memberof PropacProcedimento
     */
    defensoria_responsavel_nome?: string;
    /**
     * 
     * @type {string}
     * @memberof PropacProcedimento
     */
    representante?: string;
    /**
     * 
     * @type {string}
     * @memberof PropacProcedimento
     */
    representado?: string;
    /**
     * 
     * @type {number}
     * @memberof PropacProcedimento
     */
    acesso?: number;
    /**
     * 
     * @type {string}
     * @memberof PropacProcedimento
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof PropacProcedimento
     */
    numero?: string;
    /**
     * 
     * @type {string}
     * @memberof PropacProcedimento
     */
    assunto?: string;
    /**
     * 
     * @type {number}
     * @memberof PropacProcedimento
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof PropacProcedimento
     */
    situacao?: number;
    /**
     * 
     * @type {Date}
     * @memberof PropacProcedimento
     */
    data_ultima_movimentacao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof PropacProcedimento
     */
    ativo?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof PropacProcedimento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {number}
     * @memberof PropacProcedimento
     */
    defensor_responsavel?: number;
    /**
     * 
     * @type {number}
     * @memberof PropacProcedimento
     */
    defensoria_responsavel?: number;
    /**
     * 
     * @type {number}
     * @memberof PropacProcedimento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof PropacProcedimento
     */
    area?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof PropacProcedimento
     */
    atendimentos?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof PropacProcedimento
     */
    defensorias_acesso?: Array<number>;
}
/**
 * 
 * @export
 * @interface Qualificacao
 */
export interface Qualificacao {
    /**
     * 
     * @type {number}
     * @memberof Qualificacao
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Qualificacao
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof Qualificacao
     */
    tipo_nome?: string;
    /**
     * 
     * @type {string}
     * @memberof Qualificacao
     */
    titulo: string;
    /**
     * 
     * @type {Generic}
     * @memberof Qualificacao
     */
    area: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof Qualificacao
     */
    nucleo: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof Qualificacao
     */
    especializado: Generic;
    /**
     * 
     * @type {number}
     * @memberof Qualificacao
     */
    numero?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Qualificacao
     */
    disponivel_para_agendamento_via_app?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Qualificacao
     */
    orgao_encaminhamento?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Qualificacao
     */
    defensorias?: Array<number>;
}
/**
 * 
 * @export
 * @interface QualificacaoAssunto
 */
export interface QualificacaoAssunto {
    /**
     * 
     * @type {number}
     * @memberof QualificacaoAssunto
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof QualificacaoAssunto
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof QualificacaoAssunto
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof QualificacaoAssunto
     */
    desativado_em?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof QualificacaoAssunto
     */
    principal?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QualificacaoAssunto
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificacaoAssunto
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificacaoAssunto
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificacaoAssunto
     */
    qualificacao: number;
    /**
     * 
     * @type {number}
     * @memberof QualificacaoAssunto
     */
    assunto: number;
}
/**
 * 
 * @export
 * @interface Relatorio
 */
export interface Relatorio {
    /**
     * 
     * @type {number}
     * @memberof Relatorio
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Relatorio
     */
    parametros: string;
    /**
     * 
     * @type {string}
     * @memberof Relatorio
     */
    iframe_url?: string;
    /**
     * 
     * @type {Date}
     * @memberof Relatorio
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Relatorio
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Relatorio
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof Relatorio
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof Relatorio
     */
    titulo: string;
    /**
     * 
     * @type {string}
     * @memberof Relatorio
     */
    caminho: string;
    /**
     * 
     * @type {number}
     * @memberof Relatorio
     */
    metabase_dashboard_id?: number;
    /**
     * 
     * @type {number}
     * @memberof Relatorio
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Relatorio
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Relatorio
     */
    desativado_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Relatorio
     */
    locais: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Relatorio
     */
    papeis: Array<number>;
}
/**
 * 
 * @export
 * @interface Remissao
 */
export interface Remissao {
    /**
     * 
     * @type {number}
     * @memberof Remissao
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Remissao
     */
    data_inicial: string;
    /**
     * 
     * @type {string}
     * @memberof Remissao
     */
    data_final: string;
    /**
     * 
     * @type {number}
     * @memberof Remissao
     */
    dias_registro: number;
    /**
     * 
     * @type {string}
     * @memberof Remissao
     */
    dias_remissao: string;
    /**
     * 
     * @type {number}
     * @memberof Remissao
     */
    tipo?: number;
    /**
     * 
     * @type {Date}
     * @memberof Remissao
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Remissao
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Remissao
     */
    para_progressao?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Remissao
     */
    ativo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Remissao
     */
    pessoa: string;
    /**
     * 
     * @type {number}
     * @memberof Remissao
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Remissao
     */
    excluido_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Remissao
     */
    falta?: number;
}
/**
 * 
 * @export
 * @interface Renda
 */
export interface Renda {
    /**
     * 
     * @type {number}
     * @memberof Renda
     */
    id?: number;
    /**
     * Número de membros na entidade familiar
     * @type {number}
     * @memberof Renda
     */
    numero_membros?: number;
    /**
     * Número de membros na entidade familiar economicamente ativos
     * @type {number}
     * @memberof Renda
     */
    numero_membros_economicamente_ativos?: number;
    /**
     * 
     * @type {number}
     * @memberof Renda
     */
    numero_dependentes?: number;
    /**
     * Ganhos mensais, em R$, do declarante
     * @type {string}
     * @memberof Renda
     */
    ganho_mensal?: string;
    /**
     * Ganhos mensais, em R$, da entidade familiar
     * @type {string}
     * @memberof Renda
     */
    ganho_mensal_membros?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Renda
     */
    tem_gastos_tratamento?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Renda
     */
    valor_tratamento?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Renda
     */
    tem_plano_saude?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Renda
     */
    nome_plano_saude?: string;
    /**
     * 
     * @type {string}
     * @memberof Renda
     */
    valor_nome_saude?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Renda
     */
    tem_beneficio_assistencial?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Renda
     */
    valor_beneficio_assistencial?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Renda
     */
    tem_educacao_particular_filhos?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Renda
     */
    valor_educacao_particular_filhos?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Renda
     */
    declarante_ir?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Renda
     */
    isento_ir?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Renda
     */
    previdencia?: boolean;
    /**
     * Selecione caso seja Pessoa Júridica e tenha fins lucrativos
     * @type {boolean}
     * @memberof Renda
     */
    tem_fins_lucrativos?: boolean;
    /**
     * Preencha com a maior remuneração paga mensalmente
     * @type {string}
     * @memberof Renda
     */
    salario_funcionario?: string;
    /**
     * 
     * @type {Date}
     * @memberof Renda
     */
    triagem_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Renda
     */
    triagem_data_expiracao?: string;
    /**
     * Tipo da renda individual do assistido
     * @type {number}
     * @memberof Renda
     */
    tipo_renda?: number;
    /**
     * 
     * @type {number}
     * @memberof Renda
     */
    triagem_por?: number;
}
/**
 * 
 * @export
 * @interface Resposta
 */
export interface Resposta {
    /**
     * 
     * @type {number}
     * @memberof Resposta
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Resposta
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Resposta
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Resposta
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Resposta
     */
    texto?: string;
    /**
     * 
     * @type {number}
     * @memberof Resposta
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Resposta
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Resposta
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Resposta
     */
    pergunta: number;
    /**
     * 
     * @type {number}
     * @memberof Resposta
     */
    atendimento?: number;
    /**
     * 
     * @type {number}
     * @memberof Resposta
     */
    evento?: number;
}
/**
 * 
 * @export
 * @interface RestricaoPrestacaoServico
 */
export interface RestricaoPrestacaoServico {
    /**
     * 
     * @type {number}
     * @memberof RestricaoPrestacaoServico
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RestricaoPrestacaoServico
     */
    data_referencia: string;
    /**
     * Formato DD HH:mm:ss ou HHH:mm:ss
     * @type {string}
     * @memberof RestricaoPrestacaoServico
     */
    horas_trabalhadas: string;
    /**
     * 
     * @type {boolean}
     * @memberof RestricaoPrestacaoServico
     */
    ativo?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof RestricaoPrestacaoServico
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RestricaoPrestacaoServico
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {number}
     * @memberof RestricaoPrestacaoServico
     */
    prisao: number;
    /**
     * 
     * @type {number}
     * @memberof RestricaoPrestacaoServico
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof RestricaoPrestacaoServico
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface Salario
 */
export interface Salario {
    /**
     * 
     * @type {number}
     * @memberof Salario
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Salario
     */
    vigencia: string;
    /**
     * 
     * @type {string}
     * @memberof Salario
     */
    valor: string;
    /**
     * 
     * @type {string}
     * @memberof Salario
     */
    indice_renda_individual?: string;
    /**
     * 
     * @type {string}
     * @memberof Salario
     */
    indice_renda_familiar?: string;
    /**
     * 
     * @type {string}
     * @memberof Salario
     */
    indice_renda_per_capita?: string;
    /**
     * 
     * @type {string}
     * @memberof Salario
     */
    indice_valor_bens?: string;
    /**
     * 
     * @type {string}
     * @memberof Salario
     */
    indice_valor_investimentos?: string;
    /**
     * 
     * @type {number}
     * @memberof Salario
     */
    tipo_pessoa?: number;
    /**
     * 
     * @type {string}
     * @memberof Salario
     */
    indice_valor_salario_funcionario?: string;
}
/**
 * 
 * @export
 * @interface Semovente
 */
export interface Semovente {
    /**
     * 
     * @type {number}
     * @memberof Semovente
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Semovente
     */
    tipo: number;
    /**
     * 
     * @type {number}
     * @memberof Semovente
     */
    quantidade: number;
    /**
     * 
     * @type {string}
     * @memberof Semovente
     */
    valor_aproximado: string;
    /**
     * 
     * @type {number}
     * @memberof Semovente
     */
    patrimonio: number;
}
/**
 * 
 * @export
 * @interface ServidorBasic
 */
export interface ServidorBasic {
    /**
     * 
     * @type {number}
     * @memberof ServidorBasic
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ServidorBasic
     */
    nome?: string;
    /**
     * 
     * @type {string}
     * @memberof ServidorBasic
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ServidorBasic
     */
    eh_defensor?: string;
}
/**
 * 
 * @export
 * @interface ServidorV2
 */
export interface ServidorV2 {
    /**
     * 
     * @type {number}
     * @memberof ServidorV2
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ServidorV2
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof ServidorV2
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof ServidorV2
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof ServidorV2
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof ServidorV2
     */
    cpf: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServidorV2
     */
    ativo: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServidorV2
     */
    uso_interno?: boolean;
    /**
     * 
     * @type {Generic}
     * @memberof ServidorV2
     */
    comarca: Generic;
    /**
     * 
     * @type {Generic}
     * @memberof ServidorV2
     */
    papel: Generic;
    /**
     * 
     * @type {ContribUser}
     * @memberof ServidorV2
     */
    usuario?: ContribUser;
    /**
     * 
     * @type {number}
     * @memberof ServidorV2
     */
    sexo?: number;
    /**
     * 
     * @type {string}
     * @memberof ServidorV2
     */
    matricula?: string;
    /**
     * 
     * @type {string}
     * @memberof ServidorV2
     */
    foto?: string;
}
/**
 * 
 * @export
 * @interface SistemaWebService
 */
export interface SistemaWebService {
    /**
     * 
     * @type {number}
     * @memberof SistemaWebService
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof SistemaWebService
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SistemaWebService
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SistemaWebService
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof SistemaWebService
     */
    nome?: string;
    /**
     * 
     * @type {number}
     * @memberof SistemaWebService
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof SistemaWebService
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof SistemaWebService
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface Situacao
 */
export interface Situacao {
    /**
     * 
     * @type {number}
     * @memberof Situacao
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Situacao
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Situacao
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Situacao
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Situacao
     */
    codigo: string;
    /**
     * 
     * @type {string}
     * @memberof Situacao
     */
    nome: string;
    /**
     * 
     * @type {boolean}
     * @memberof Situacao
     */
    eh_situacao_deducao?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Situacao
     */
    disponivel_via_app?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Situacao
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Situacao
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Situacao
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface SituacaoProcedimento
 */
export interface SituacaoProcedimento {
    /**
     * 
     * @type {number}
     * @memberof SituacaoProcedimento
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SituacaoProcedimento
     */
    situacao?: number;
    /**
     * 
     * @type {string}
     * @memberof SituacaoProcedimento
     */
    motivo?: string;
    /**
     * 
     * @type {Date}
     * @memberof SituacaoProcedimento
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof SituacaoProcedimento
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SituacaoProcedimento
     */
    procedimento?: number;
    /**
     * 
     * @type {number}
     * @memberof SituacaoProcedimento
     */
    cadastrado_por?: number;
}
/**
 * 
 * @export
 * @interface Soltura
 */
export interface Soltura {
    /**
     * 
     * @type {number}
     * @memberof Soltura
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Soltura
     */
    tipo: number;
    /**
     * 
     * @type {string}
     * @memberof Soltura
     */
    historico?: string;
    /**
     * 
     * @type {Date}
     * @memberof Soltura
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Soltura
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Soltura
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Soltura
     */
    aprisionamento: number;
    /**
     * 
     * @type {number}
     * @memberof Soltura
     */
    processo?: number;
    /**
     * 
     * @type {number}
     * @memberof Soltura
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Soltura
     */
    excluido_por?: number;
}
/**
 * 
 * @export
 * @interface SubMenu
 */
export interface SubMenu {
    /**
     * 
     * @type {string}
     * @memberof SubMenu
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof SubMenu
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof SubMenu
     */
    icon: string;
}
/**
 * 
 * @export
 * @interface Tarefa
 */
export interface Tarefa {
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Tarefa
     */
    tarefa_oficio?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    prioridade?: number;
    /**
     * 
     * @type {string}
     * @memberof Tarefa
     */
    titulo?: string;
    /**
     * 
     * @type {string}
     * @memberof Tarefa
     */
    descricao?: string;
    /**
     * 
     * @type {string}
     * @memberof Tarefa
     */
    data_inicial?: string;
    /**
     * 
     * @type {string}
     * @memberof Tarefa
     */
    data_final?: string;
    /**
     * 
     * @type {Date}
     * @memberof Tarefa
     */
    data_finalizado?: Date;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    status?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Tarefa
     */
    ativo?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof Tarefa
     */
    data_cadastro?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Tarefa
     */
    data_exclusao?: Date;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    origem?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    documento?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    atendimento?: number;
    /**
     * Movimento de Propac ou Procedimento.
     * @type {number}
     * @memberof Tarefa
     */
    movimento?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    processo?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    resposta_para?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    setor_responsavel?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    responsavel?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    finalizado?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Tarefa
     */
    excluido_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Tarefa
     */
    documentos?: Array<number>;
}
/**
 * 
 * @export
 * @interface Telefone
 */
export interface Telefone {
    /**
     * 
     * @type {number}
     * @memberof Telefone
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Telefone
     */
    tipo_str?: string;
    /**
     * 
     * @type {number}
     * @memberof Telefone
     */
    ddd?: number;
    /**
     * 
     * @type {string}
     * @memberof Telefone
     */
    numero: string;
    /**
     * 
     * @type {number}
     * @memberof Telefone
     */
    tipo: number;
    /**
     * 
     * @type {string}
     * @memberof Telefone
     */
    nome?: string;
}
/**
 * 
 * @export
 * @interface TelefoneSerializer
 */
export interface TelefoneSerializer {
    /**
     * 
     * @type {number}
     * @memberof TelefoneSerializer
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TelefoneSerializer
     */
    ddd?: number;
    /**
     * 
     * @type {string}
     * @memberof TelefoneSerializer
     */
    numero: string;
    /**
     * 
     * @type {number}
     * @memberof TelefoneSerializer
     */
    tipo: number;
    /**
     * 
     * @type {string}
     * @memberof TelefoneSerializer
     */
    nome?: string;
}
/**
 * 
 * @export
 * @interface Termo
 */
export interface Termo {
    /**
     * 
     * @type {number}
     * @memberof Termo
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Termo
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Termo
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Termo
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof Termo
     */
    titulo: string;
    /**
     * 
     * @type {string}
     * @memberof Termo
     */
    descricao: string;
    /**
     * 
     * @type {string}
     * @memberof Termo
     */
    tipo_resposta: Termo.TipoRespostaEnum;
    /**
     * 
     * @type {string}
     * @memberof Termo
     */
    tipo_descricao?: Termo.TipoDescricaoEnum;
    /**
     * 
     * @type {string}
     * @memberof Termo
     */
    data_inicio?: string;
    /**
     * 
     * @type {string}
     * @memberof Termo
     */
    data_finalizacao?: string;
    /**
     * 
     * @type {number}
     * @memberof Termo
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Termo
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Termo
     */
    desativado_por?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Termo
     */
    servidores?: Array<number>;
}

/**
 * @export
 * @namespace Termo
 */
export namespace Termo {
    /**
     * @export
     * @enum {string}
     */
    export enum TipoRespostaEnum {
        Un = <any> 'un',
        Mu = <any> 'mu'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TipoDescricaoEnum {
        Txt = <any> 'txt',
        Html = <any> 'html'
    }
}
/**
 * 
 * @export
 * @interface TermoResposta
 */
export interface TermoResposta {
    /**
     * 
     * @type {number}
     * @memberof TermoResposta
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof TermoResposta
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TermoResposta
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TermoResposta
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof TermoResposta
     */
    titulo_termo?: string;
    /**
     * 
     * @type {string}
     * @memberof TermoResposta
     */
    descricao_termo?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TermoResposta
     */
    aceite: boolean;
    /**
     * 
     * @type {Date}
     * @memberof TermoResposta
     */
    data_resposta?: Date;
    /**
     * 
     * @type {number}
     * @memberof TermoResposta
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TermoResposta
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TermoResposta
     */
    desativado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TermoResposta
     */
    termo: number;
    /**
     * 
     * @type {number}
     * @memberof TermoResposta
     */
    servidor: number;
}
/**
 * 
 * @export
 * @interface Tipificacao
 */
export interface Tipificacao {
    /**
     * 
     * @type {number}
     * @memberof Tipificacao
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Tipificacao
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Tipificacao
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Tipificacao
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof Tipificacao
     */
    tipo?: number;
    /**
     * 
     * @type {string}
     * @memberof Tipificacao
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Tipificacao
     */
    numero_lei?: string;
    /**
     * 
     * @type {string}
     * @memberof Tipificacao
     */
    artigo_lei?: string;
    /**
     * 
     * @type {string}
     * @memberof Tipificacao
     */
    paragrafo_lei?: string;
    /**
     * 
     * @type {number}
     * @memberof Tipificacao
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Tipificacao
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof Tipificacao
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface TipoAnexoDocumentoPropac
 */
export interface TipoAnexoDocumentoPropac {
    /**
     * 
     * @type {number}
     * @memberof TipoAnexoDocumentoPropac
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TipoAnexoDocumentoPropac
     */
    nome?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TipoAnexoDocumentoPropac
     */
    ativo?: boolean;
}
/**
 * 
 * @export
 * @interface TipoColetividade
 */
export interface TipoColetividade {
    /**
     * 
     * @type {number}
     * @memberof TipoColetividade
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TipoColetividade
     */
    nome: string;
}
/**
 * 
 * @export
 * @interface TipoDocumento
 */
export interface TipoDocumento {
    /**
     * 
     * @type {number}
     * @memberof TipoDocumento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof TipoDocumento
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TipoDocumento
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TipoDocumento
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof TipoDocumento
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof TipoDocumento
     */
    nome_norm: string;
    /**
     * 
     * @type {number}
     * @memberof TipoDocumento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoDocumento
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoDocumento
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface TipoEstabelecimentoPenal
 */
export interface TipoEstabelecimentoPenal {
    /**
     * 
     * @type {number}
     * @memberof TipoEstabelecimentoPenal
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof TipoEstabelecimentoPenal
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TipoEstabelecimentoPenal
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TipoEstabelecimentoPenal
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof TipoEstabelecimentoPenal
     */
    nome: string;
    /**
     * 
     * @type {number}
     * @memberof TipoEstabelecimentoPenal
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoEstabelecimentoPenal
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoEstabelecimentoPenal
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface TipoEvento
 */
export interface TipoEvento {
    /**
     * 
     * @type {number}
     * @memberof TipoEvento
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof TipoEvento
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TipoEvento
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TipoEvento
     */
    desativado_em?: Date;
    /**
     * 
     * @type {number}
     * @memberof TipoEvento
     */
    tipo?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoEvento
     */
    tipo_processo?: number;
    /**
     * 
     * @type {string}
     * @memberof TipoEvento
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof TipoEvento
     */
    nome_norm: string;
    /**
     * 
     * @type {number}
     * @memberof TipoEvento
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoEvento
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoEvento
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface TipoRenda
 */
export interface TipoRenda {
    /**
     * 
     * @type {number}
     * @memberof TipoRenda
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TipoRenda
     */
    nome: string;
    /**
     * Caso marcado, deve-se deixar em branco o valor máximo de dedução abaixo e será utilizado o valor da tabela salários
     * @type {boolean}
     * @memberof TipoRenda
     */
    eh_deducao_salario_minimo?: boolean;
    /**
     * Valor máximo em R$ que será deduzido para este tipo de renda (caso não seja o salário mínimo)
     * @type {string}
     * @memberof TipoRenda
     */
    valor_maximo_deducao?: string;
}
/**
 * 
 * @export
 * @interface TipoVulnerabilidade
 */
export interface TipoVulnerabilidade {
    /**
     * 
     * @type {number}
     * @memberof TipoVulnerabilidade
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof TipoVulnerabilidade
     */
    cadastrado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TipoVulnerabilidade
     */
    modificado_em?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TipoVulnerabilidade
     */
    desativado_em?: Date;
    /**
     * 
     * @type {string}
     * @memberof TipoVulnerabilidade
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof TipoVulnerabilidade
     */
    descricao?: string;
    /**
     * 
     * @type {number}
     * @memberof TipoVulnerabilidade
     */
    cadastrado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoVulnerabilidade
     */
    modificado_por?: number;
    /**
     * 
     * @type {number}
     * @memberof TipoVulnerabilidade
     */
    desativado_por?: number;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    refresh: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    access?: string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    token: string;
}
/**
 * 
 * @export
 * @interface Usuario
 */
export interface Usuario {
    /**
     * 
     * @type {number}
     * @memberof Usuario
     */
    id?: number;
    /**
     * Obrigatório. 150 caracteres ou menos. Letras, números e @/./+/-/_ apenas.
     * @type {string}
     * @memberof Usuario
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof Usuario
     */
    nome?: string;
}
/**
 * 
 * @export
 * @interface UsuarioMenus
 */
export interface UsuarioMenus {
    /**
     * 
     * @type {Usuario}
     * @memberof UsuarioMenus
     */
    usuario: Usuario;
    /**
     * 
     * @type {Array<Menu>}
     * @memberof UsuarioMenus
     */
    menus: Array<Menu>;
}
/**
 * 
 * @export
 * @interface UsuarioPermissoes
 */
export interface UsuarioPermissoes {
    /**
     * 
     * @type {Usuario}
     * @memberof UsuarioPermissoes
     */
    usuario: Usuario;
    /**
     * 
     * @type {Array<string>}
     * @memberof UsuarioPermissoes
     */
    permissoes: Array<string>;
}
/**
 * 
 * @export
 * @interface VagaEditalPlantao
 */
export interface VagaEditalPlantao {
    /**
     * 
     * @type {number}
     * @memberof VagaEditalPlantao
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VagaEditalPlantao
     */
    data_inicio: string;
    /**
     * 
     * @type {string}
     * @memberof VagaEditalPlantao
     */
    data_final: string;
}
/**
 * 
 * @export
 * @interface Vara
 */
export interface Vara {
    /**
     * 
     * @type {number}
     * @memberof Vara
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Vara
     */
    data_cadastro?: string;
    /**
     * 
     * @type {string}
     * @memberof Vara
     */
    data_atualizacao?: string;
    /**
     * 
     * @type {string}
     * @memberof Vara
     */
    nome: string;
    /**
     * 
     * @type {string}
     * @memberof Vara
     */
    codigo_eproc?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Vara
     */
    ativo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Vara
     */
    grau?: number;
    /**
     * 
     * @type {number}
     * @memberof Vara
     */
    comarca: number;
}
/**
 * AcordosApi - fetch parameter creator
 * @export
 */
export const AcordosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Acordo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosCreate(body: Acordo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling acordosCreate.');
            }
            const localVarPath = `/acordos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Acordo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling acordosDelete.');
            }
            const localVarPath = `/acordos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/acordos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Acordo} body 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosPartialUpdate(body: Acordo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling acordosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling acordosPartialUpdate.');
            }
            const localVarPath = `/acordos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Acordo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling acordosRead.');
            }
            const localVarPath = `/acordos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Acordo} body 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosUpdate(body: Acordo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling acordosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling acordosUpdate.');
            }
            const localVarPath = `/acordos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Acordo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AcordosApi - functional programming interface
 * @export
 */
export const AcordosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Acordo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosCreate(body: Acordo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Acordo> {
            const localVarFetchArgs = AcordosApiFetchParamCreator(configuration).acordosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AcordosApiFetchParamCreator(configuration).acordosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = AcordosApiFetchParamCreator(configuration).acordosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Acordo} body 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosPartialUpdate(body: Acordo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Acordo> {
            const localVarFetchArgs = AcordosApiFetchParamCreator(configuration).acordosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Acordo> {
            const localVarFetchArgs = AcordosApiFetchParamCreator(configuration).acordosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Acordo} body 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosUpdate(body: Acordo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Acordo> {
            const localVarFetchArgs = AcordosApiFetchParamCreator(configuration).acordosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AcordosApi - factory interface
 * @export
 */
export const AcordosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Acordo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosCreate(body: Acordo, options?: any) {
            return AcordosApiFp(configuration).acordosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosDelete(id: number, options?: any) {
            return AcordosApiFp(configuration).acordosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosList(limit?: number, offset?: number, options?: any) {
            return AcordosApiFp(configuration).acordosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Acordo} body 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosPartialUpdate(body: Acordo, id: number, options?: any) {
            return AcordosApiFp(configuration).acordosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosRead(id: number, options?: any) {
            return AcordosApiFp(configuration).acordosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Acordo} body 
         * @param {number} id A unique integer value identifying this acordo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acordosUpdate(body: Acordo, id: number, options?: any) {
            return AcordosApiFp(configuration).acordosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AcordosApi - object-oriented interface
 * @export
 * @class AcordosApi
 * @extends {BaseAPI}
 */
export class AcordosApi extends BaseAPI {
    /**
     * 
     * @param {Acordo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcordosApi
     */
    public acordosCreate(body: Acordo, options?: any) {
        return AcordosApiFp(this.configuration).acordosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this acordo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcordosApi
     */
    public acordosDelete(id: number, options?: any) {
        return AcordosApiFp(this.configuration).acordosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcordosApi
     */
    public acordosList(limit?: number, offset?: number, options?: any) {
        return AcordosApiFp(this.configuration).acordosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Acordo} body 
     * @param {number} id A unique integer value identifying this acordo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcordosApi
     */
    public acordosPartialUpdate(body: Acordo, id: number, options?: any) {
        return AcordosApiFp(this.configuration).acordosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this acordo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcordosApi
     */
    public acordosRead(id: number, options?: any) {
        return AcordosApiFp(this.configuration).acordosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Acordo} body 
     * @param {number} id A unique integer value identifying this acordo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcordosApi
     */
    public acordosUpdate(body: Acordo, id: number, options?: any) {
        return AcordosApiFp(this.configuration).acordosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AgendasApi - fetch parameter creator
 * @export
 */
export const AgendasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Agenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasCreate(body: Agenda, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling agendasCreate.');
            }
            const localVarPath = `/agendas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Agenda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this agenda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling agendasDelete.');
            }
            const localVarPath = `/agendas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [defensor] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasList(defensor?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/agendas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (defensor !== undefined) {
                localVarQueryParameter['defensor'] = defensor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this agenda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling agendasRead.');
            }
            const localVarPath = `/agendas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgendasApi - functional programming interface
 * @export
 */
export const AgendasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Agenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasCreate(body: Agenda, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Agenda> {
            const localVarFetchArgs = AgendasApiFetchParamCreator(configuration).agendasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this agenda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AgendasApiFetchParamCreator(configuration).agendasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [defensor] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasList(defensor?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = AgendasApiFetchParamCreator(configuration).agendasList(defensor, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this agenda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AgendaDetail> {
            const localVarFetchArgs = AgendasApiFetchParamCreator(configuration).agendasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AgendasApi - factory interface
 * @export
 */
export const AgendasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Agenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasCreate(body: Agenda, options?: any) {
            return AgendasApiFp(configuration).agendasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this agenda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasDelete(id: number, options?: any) {
            return AgendasApiFp(configuration).agendasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [defensor] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasList(defensor?: string, limit?: number, offset?: number, options?: any) {
            return AgendasApiFp(configuration).agendasList(defensor, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this agenda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agendasRead(id: number, options?: any) {
            return AgendasApiFp(configuration).agendasRead(id, options)(fetch, basePath);
        },
    };
};

/**
 * AgendasApi - object-oriented interface
 * @export
 * @class AgendasApi
 * @extends {BaseAPI}
 */
export class AgendasApi extends BaseAPI {
    /**
     * 
     * @param {Agenda} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendasApi
     */
    public agendasCreate(body: Agenda, options?: any) {
        return AgendasApiFp(this.configuration).agendasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this agenda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendasApi
     */
    public agendasDelete(id: number, options?: any) {
        return AgendasApiFp(this.configuration).agendasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [defensor] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendasApi
     */
    public agendasList(defensor?: string, limit?: number, offset?: number, options?: any) {
        return AgendasApiFp(this.configuration).agendasList(defensor, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this agenda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendasApi
     */
    public agendasRead(id: number, options?: any) {
        return AgendasApiFp(this.configuration).agendasRead(id, options)(this.fetch, this.basePath);
    }

}
/**
 * AprisionamentosApi - fetch parameter creator
 * @export
 */
export const AprisionamentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosCreate(body: Aprisionamento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling aprisionamentosCreate.');
            }
            const localVarPath = `/aprisionamentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Aprisionamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling aprisionamentosDelete.');
            }
            const localVarPath = `/aprisionamentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/aprisionamentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosPartialUpdate(body: Aprisionamento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling aprisionamentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling aprisionamentosPartialUpdate.');
            }
            const localVarPath = `/aprisionamentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Aprisionamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling aprisionamentosRead.');
            }
            const localVarPath = `/aprisionamentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosUpdate(body: Aprisionamento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling aprisionamentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling aprisionamentosUpdate.');
            }
            const localVarPath = `/aprisionamentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Aprisionamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AprisionamentosApi - functional programming interface
 * @export
 */
export const AprisionamentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosCreate(body: Aprisionamento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Aprisionamento> {
            const localVarFetchArgs = AprisionamentosApiFetchParamCreator(configuration).aprisionamentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AprisionamentosApiFetchParamCreator(configuration).aprisionamentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = AprisionamentosApiFetchParamCreator(configuration).aprisionamentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosPartialUpdate(body: Aprisionamento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Aprisionamento> {
            const localVarFetchArgs = AprisionamentosApiFetchParamCreator(configuration).aprisionamentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Aprisionamento> {
            const localVarFetchArgs = AprisionamentosApiFetchParamCreator(configuration).aprisionamentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosUpdate(body: Aprisionamento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Aprisionamento> {
            const localVarFetchArgs = AprisionamentosApiFetchParamCreator(configuration).aprisionamentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AprisionamentosApi - factory interface
 * @export
 */
export const AprisionamentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosCreate(body: Aprisionamento, options?: any) {
            return AprisionamentosApiFp(configuration).aprisionamentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosDelete(id: number, options?: any) {
            return AprisionamentosApiFp(configuration).aprisionamentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosList(limit?: number, offset?: number, options?: any) {
            return AprisionamentosApiFp(configuration).aprisionamentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosPartialUpdate(body: Aprisionamento, id: number, options?: any) {
            return AprisionamentosApiFp(configuration).aprisionamentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosRead(id: number, options?: any) {
            return AprisionamentosApiFp(configuration).aprisionamentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Aprisionamento} body 
         * @param {number} id A unique integer value identifying this aprisionamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aprisionamentosUpdate(body: Aprisionamento, id: number, options?: any) {
            return AprisionamentosApiFp(configuration).aprisionamentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AprisionamentosApi - object-oriented interface
 * @export
 * @class AprisionamentosApi
 * @extends {BaseAPI}
 */
export class AprisionamentosApi extends BaseAPI {
    /**
     * 
     * @param {Aprisionamento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AprisionamentosApi
     */
    public aprisionamentosCreate(body: Aprisionamento, options?: any) {
        return AprisionamentosApiFp(this.configuration).aprisionamentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this aprisionamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AprisionamentosApi
     */
    public aprisionamentosDelete(id: number, options?: any) {
        return AprisionamentosApiFp(this.configuration).aprisionamentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AprisionamentosApi
     */
    public aprisionamentosList(limit?: number, offset?: number, options?: any) {
        return AprisionamentosApiFp(this.configuration).aprisionamentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Aprisionamento} body 
     * @param {number} id A unique integer value identifying this aprisionamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AprisionamentosApi
     */
    public aprisionamentosPartialUpdate(body: Aprisionamento, id: number, options?: any) {
        return AprisionamentosApiFp(this.configuration).aprisionamentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this aprisionamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AprisionamentosApi
     */
    public aprisionamentosRead(id: number, options?: any) {
        return AprisionamentosApiFp(this.configuration).aprisionamentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Aprisionamento} body 
     * @param {number} id A unique integer value identifying this aprisionamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AprisionamentosApi
     */
    public aprisionamentosUpdate(body: Aprisionamento, id: number, options?: any) {
        return AprisionamentosApiFp(this.configuration).aprisionamentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AreasApi - fetch parameter creator
 * @export
 */
export const AreasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Area} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasCreate(body: Area, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling areasCreate.');
            }
            const localVarPath = `/areas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Area" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling areasDelete.');
            }
            const localVarPath = `/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/areas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Area} body 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasPartialUpdate(body: Area, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling areasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling areasPartialUpdate.');
            }
            const localVarPath = `/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Area" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling areasRead.');
            }
            const localVarPath = `/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Area} body 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasUpdate(body: Area, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling areasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling areasUpdate.');
            }
            const localVarPath = `/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Area" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AreasApi - functional programming interface
 * @export
 */
export const AreasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Area} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasCreate(body: Area, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Area} body 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasPartialUpdate(body: Area, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Area} body 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasUpdate(body: Area, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AreasApi - factory interface
 * @export
 */
export const AreasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Area} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasCreate(body: Area, options?: any) {
            return AreasApiFp(configuration).areasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasDelete(id: number, options?: any) {
            return AreasApiFp(configuration).areasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasList(limit?: number, offset?: number, options?: any) {
            return AreasApiFp(configuration).areasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Area} body 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasPartialUpdate(body: Area, id: number, options?: any) {
            return AreasApiFp(configuration).areasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasRead(id: number, options?: any) {
            return AreasApiFp(configuration).areasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Area} body 
         * @param {number} id A unique integer value identifying this Área.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasUpdate(body: Area, id: number, options?: any) {
            return AreasApiFp(configuration).areasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AreasApi - object-oriented interface
 * @export
 * @class AreasApi
 * @extends {BaseAPI}
 */
export class AreasApi extends BaseAPI {
    /**
     * 
     * @param {Area} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasCreate(body: Area, options?: any) {
        return AreasApiFp(this.configuration).areasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Área.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasDelete(id: number, options?: any) {
        return AreasApiFp(this.configuration).areasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasList(limit?: number, offset?: number, options?: any) {
        return AreasApiFp(this.configuration).areasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Area} body 
     * @param {number} id A unique integer value identifying this Área.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasPartialUpdate(body: Area, id: number, options?: any) {
        return AreasApiFp(this.configuration).areasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Área.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasRead(id: number, options?: any) {
        return AreasApiFp(this.configuration).areasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Area} body 
     * @param {number} id A unique integer value identifying this Área.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasUpdate(body: Area, id: number, options?: any) {
        return AreasApiFp(this.configuration).areasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AssistidosApi - fetch parameter creator
 * @export
 */
export const AssistidosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosConfirmaTriagem(body: PessoaAssistida, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assistidosConfirmaTriagem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosConfirmaTriagem.');
            }
            const localVarPath = `/assistidos/{id}/confirma_triagem/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PessoaAssistida" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosCreate(body: PessoaAssistida, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assistidosCreate.');
            }
            const localVarPath = `/assistidos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PessoaAssistida" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosDelete.');
            }
            const localVarPath = `/assistidos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/assistidos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosPartialUpdate(body: PessoaAssistida, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assistidosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosPartialUpdate.');
            }
            const localVarPath = `/assistidos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PessoaAssistida" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosRead.');
            }
            const localVarPath = `/assistidos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosUpdate(body: PessoaAssistida, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assistidosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosUpdate.');
            }
            const localVarPath = `/assistidos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PessoaAssistida" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssistidosApi - functional programming interface
 * @export
 */
export const AssistidosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosConfirmaTriagem(body: PessoaAssistida, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PessoaAssistida> {
            const localVarFetchArgs = AssistidosApiFetchParamCreator(configuration).assistidosConfirmaTriagem(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosCreate(body: PessoaAssistida, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PessoaAssistida> {
            const localVarFetchArgs = AssistidosApiFetchParamCreator(configuration).assistidosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssistidosApiFetchParamCreator(configuration).assistidosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = AssistidosApiFetchParamCreator(configuration).assistidosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosPartialUpdate(body: PessoaAssistida, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PessoaAssistida> {
            const localVarFetchArgs = AssistidosApiFetchParamCreator(configuration).assistidosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PessoaAssistida> {
            const localVarFetchArgs = AssistidosApiFetchParamCreator(configuration).assistidosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosUpdate(body: PessoaAssistida, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PessoaAssistida> {
            const localVarFetchArgs = AssistidosApiFetchParamCreator(configuration).assistidosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssistidosApi - factory interface
 * @export
 */
export const AssistidosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosConfirmaTriagem(body: PessoaAssistida, id: number, options?: any) {
            return AssistidosApiFp(configuration).assistidosConfirmaTriagem(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosCreate(body: PessoaAssistida, options?: any) {
            return AssistidosApiFp(configuration).assistidosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDelete(id: number, options?: any) {
            return AssistidosApiFp(configuration).assistidosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosList(limit?: number, offset?: number, options?: any) {
            return AssistidosApiFp(configuration).assistidosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosPartialUpdate(body: PessoaAssistida, id: number, options?: any) {
            return AssistidosApiFp(configuration).assistidosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosRead(id: number, options?: any) {
            return AssistidosApiFp(configuration).assistidosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PessoaAssistida} body 
         * @param {number} id A unique integer value identifying this Assistido.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosUpdate(body: PessoaAssistida, id: number, options?: any) {
            return AssistidosApiFp(configuration).assistidosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AssistidosApi - object-oriented interface
 * @export
 * @class AssistidosApi
 * @extends {BaseAPI}
 */
export class AssistidosApi extends BaseAPI {
    /**
     * 
     * @param {PessoaAssistida} body 
     * @param {number} id A unique integer value identifying this Assistido.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosApi
     */
    public assistidosConfirmaTriagem(body: PessoaAssistida, id: number, options?: any) {
        return AssistidosApiFp(this.configuration).assistidosConfirmaTriagem(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PessoaAssistida} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosApi
     */
    public assistidosCreate(body: PessoaAssistida, options?: any) {
        return AssistidosApiFp(this.configuration).assistidosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Assistido.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosApi
     */
    public assistidosDelete(id: number, options?: any) {
        return AssistidosApiFp(this.configuration).assistidosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosApi
     */
    public assistidosList(limit?: number, offset?: number, options?: any) {
        return AssistidosApiFp(this.configuration).assistidosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PessoaAssistida} body 
     * @param {number} id A unique integer value identifying this Assistido.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosApi
     */
    public assistidosPartialUpdate(body: PessoaAssistida, id: number, options?: any) {
        return AssistidosApiFp(this.configuration).assistidosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Assistido.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosApi
     */
    public assistidosRead(id: number, options?: any) {
        return AssistidosApiFp(this.configuration).assistidosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PessoaAssistida} body 
     * @param {number} id A unique integer value identifying this Assistido.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosApi
     */
    public assistidosUpdate(body: PessoaAssistida, id: number, options?: any) {
        return AssistidosApiFp(this.configuration).assistidosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AssistidosDocumentosApi - fetch parameter creator
 * @export
 */
export const AssistidosDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosCreate(body: DefensorDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assistidosDocumentosCreate.');
            }
            const localVarPath = `/assistidos-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensorDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosDocumentosDelete.');
            }
            const localVarPath = `/assistidos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [assistido_id] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosList(assistido_id?: number, ativo?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/assistidos-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (assistido_id !== undefined) {
                localVarQueryParameter['assistido_id'] = assistido_id;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosPartialUpdate(body: DefensorDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assistidosDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosDocumentosPartialUpdate.');
            }
            const localVarPath = `/assistidos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensorDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosDocumentosRead.');
            }
            const localVarPath = `/assistidos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosUpdate(body: DefensorDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assistidosDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assistidosDocumentosUpdate.');
            }
            const localVarPath = `/assistidos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensorDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssistidosDocumentosApi - functional programming interface
 * @export
 */
export const AssistidosDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosCreate(body: DefensorDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensorDocumento> {
            const localVarFetchArgs = AssistidosDocumentosApiFetchParamCreator(configuration).assistidosDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssistidosDocumentosApiFetchParamCreator(configuration).assistidosDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [assistido_id] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosList(assistido_id?: number, ativo?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = AssistidosDocumentosApiFetchParamCreator(configuration).assistidosDocumentosList(assistido_id, ativo, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosPartialUpdate(body: DefensorDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensorDocumento> {
            const localVarFetchArgs = AssistidosDocumentosApiFetchParamCreator(configuration).assistidosDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensorDocumento> {
            const localVarFetchArgs = AssistidosDocumentosApiFetchParamCreator(configuration).assistidosDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosUpdate(body: DefensorDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensorDocumento> {
            const localVarFetchArgs = AssistidosDocumentosApiFetchParamCreator(configuration).assistidosDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssistidosDocumentosApi - factory interface
 * @export
 */
export const AssistidosDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosCreate(body: DefensorDocumento, options?: any) {
            return AssistidosDocumentosApiFp(configuration).assistidosDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosDelete(id: number, options?: any) {
            return AssistidosDocumentosApiFp(configuration).assistidosDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [assistido_id] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosList(assistido_id?: number, ativo?: string, limit?: number, offset?: number, options?: any) {
            return AssistidosDocumentosApiFp(configuration).assistidosDocumentosList(assistido_id, ativo, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosPartialUpdate(body: DefensorDocumento, id: number, options?: any) {
            return AssistidosDocumentosApiFp(configuration).assistidosDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosRead(id: number, options?: any) {
            return AssistidosDocumentosApiFp(configuration).assistidosDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assistidosDocumentosUpdate(body: DefensorDocumento, id: number, options?: any) {
            return AssistidosDocumentosApiFp(configuration).assistidosDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AssistidosDocumentosApi - object-oriented interface
 * @export
 * @class AssistidosDocumentosApi
 * @extends {BaseAPI}
 */
export class AssistidosDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {DefensorDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosDocumentosApi
     */
    public assistidosDocumentosCreate(body: DefensorDocumento, options?: any) {
        return AssistidosDocumentosApiFp(this.configuration).assistidosDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosDocumentosApi
     */
    public assistidosDocumentosDelete(id: number, options?: any) {
        return AssistidosDocumentosApiFp(this.configuration).assistidosDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [assistido_id] 
     * @param {string} [ativo] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosDocumentosApi
     */
    public assistidosDocumentosList(assistido_id?: number, ativo?: string, limit?: number, offset?: number, options?: any) {
        return AssistidosDocumentosApiFp(this.configuration).assistidosDocumentosList(assistido_id, ativo, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DefensorDocumento} body 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosDocumentosApi
     */
    public assistidosDocumentosPartialUpdate(body: DefensorDocumento, id: number, options?: any) {
        return AssistidosDocumentosApiFp(this.configuration).assistidosDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosDocumentosApi
     */
    public assistidosDocumentosRead(id: number, options?: any) {
        return AssistidosDocumentosApiFp(this.configuration).assistidosDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DefensorDocumento} body 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssistidosDocumentosApi
     */
    public assistidosDocumentosUpdate(body: DefensorDocumento, id: number, options?: any) {
        return AssistidosDocumentosApiFp(this.configuration).assistidosDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AssuntosApi - fetch parameter creator
 * @export
 */
export const AssuntosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Assunto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosCreate(body: Assunto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assuntosCreate.');
            }
            const localVarPath = `/assuntos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Assunto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assuntosDelete.');
            }
            const localVarPath = `/assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/assuntos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Assunto} body 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosPartialUpdate(body: Assunto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assuntosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assuntosPartialUpdate.');
            }
            const localVarPath = `/assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Assunto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assuntosRead.');
            }
            const localVarPath = `/assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Assunto} body 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosUpdate(body: Assunto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assuntosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assuntosUpdate.');
            }
            const localVarPath = `/assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Assunto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssuntosApi - functional programming interface
 * @export
 */
export const AssuntosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Assunto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosCreate(body: Assunto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Assunto> {
            const localVarFetchArgs = AssuntosApiFetchParamCreator(configuration).assuntosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssuntosApiFetchParamCreator(configuration).assuntosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = AssuntosApiFetchParamCreator(configuration).assuntosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Assunto} body 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosPartialUpdate(body: Assunto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Assunto> {
            const localVarFetchArgs = AssuntosApiFetchParamCreator(configuration).assuntosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Assunto> {
            const localVarFetchArgs = AssuntosApiFetchParamCreator(configuration).assuntosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Assunto} body 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosUpdate(body: Assunto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Assunto> {
            const localVarFetchArgs = AssuntosApiFetchParamCreator(configuration).assuntosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssuntosApi - factory interface
 * @export
 */
export const AssuntosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Assunto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosCreate(body: Assunto, options?: any) {
            return AssuntosApiFp(configuration).assuntosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosDelete(id: number, options?: any) {
            return AssuntosApiFp(configuration).assuntosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosList(limit?: number, offset?: number, options?: any) {
            return AssuntosApiFp(configuration).assuntosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Assunto} body 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosPartialUpdate(body: Assunto, id: number, options?: any) {
            return AssuntosApiFp(configuration).assuntosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosRead(id: number, options?: any) {
            return AssuntosApiFp(configuration).assuntosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Assunto} body 
         * @param {number} id A unique integer value identifying this assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assuntosUpdate(body: Assunto, id: number, options?: any) {
            return AssuntosApiFp(configuration).assuntosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AssuntosApi - object-oriented interface
 * @export
 * @class AssuntosApi
 * @extends {BaseAPI}
 */
export class AssuntosApi extends BaseAPI {
    /**
     * 
     * @param {Assunto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssuntosApi
     */
    public assuntosCreate(body: Assunto, options?: any) {
        return AssuntosApiFp(this.configuration).assuntosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this assunto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssuntosApi
     */
    public assuntosDelete(id: number, options?: any) {
        return AssuntosApiFp(this.configuration).assuntosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssuntosApi
     */
    public assuntosList(limit?: number, offset?: number, options?: any) {
        return AssuntosApiFp(this.configuration).assuntosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Assunto} body 
     * @param {number} id A unique integer value identifying this assunto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssuntosApi
     */
    public assuntosPartialUpdate(body: Assunto, id: number, options?: any) {
        return AssuntosApiFp(this.configuration).assuntosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this assunto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssuntosApi
     */
    public assuntosRead(id: number, options?: any) {
        return AssuntosApiFp(this.configuration).assuntosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Assunto} body 
     * @param {number} id A unique integer value identifying this assunto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssuntosApi
     */
    public assuntosUpdate(body: Assunto, id: number, options?: any) {
        return AssuntosApiFp(this.configuration).assuntosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtendimentosApi - fetch parameter creator
 * @export
 */
export const AtendimentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Atendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosCreate(body: Atendimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosCreate.');
            }
            const localVarPath = `/atendimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosDelete.');
            }
            const localVarPath = `/atendimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atendimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartialUpdate(body: Atendimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosPartialUpdate.');
            }
            const localVarPath = `/atendimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosRead.');
            }
            const localVarPath = `/atendimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosUpdate(body: Atendimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosUpdate.');
            }
            const localVarPath = `/atendimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtendimentosApi - functional programming interface
 * @export
 */
export const AtendimentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Atendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosCreate(body: Atendimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atendimento> {
            const localVarFetchArgs = AtendimentosApiFetchParamCreator(configuration).atendimentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtendimentosApiFetchParamCreator(configuration).atendimentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = AtendimentosApiFetchParamCreator(configuration).atendimentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartialUpdate(body: Atendimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atendimento> {
            const localVarFetchArgs = AtendimentosApiFetchParamCreator(configuration).atendimentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atendimento> {
            const localVarFetchArgs = AtendimentosApiFetchParamCreator(configuration).atendimentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosUpdate(body: Atendimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atendimento> {
            const localVarFetchArgs = AtendimentosApiFetchParamCreator(configuration).atendimentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtendimentosApi - factory interface
 * @export
 */
export const AtendimentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Atendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosCreate(body: Atendimento, options?: any) {
            return AtendimentosApiFp(configuration).atendimentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDelete(id: number, options?: any) {
            return AtendimentosApiFp(configuration).atendimentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosList(limit?: number, offset?: number, options?: any) {
            return AtendimentosApiFp(configuration).atendimentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartialUpdate(body: Atendimento, id: number, options?: any) {
            return AtendimentosApiFp(configuration).atendimentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosRead(id: number, options?: any) {
            return AtendimentosApiFp(configuration).atendimentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosUpdate(body: Atendimento, id: number, options?: any) {
            return AtendimentosApiFp(configuration).atendimentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtendimentosApi - object-oriented interface
 * @export
 * @class AtendimentosApi
 * @extends {BaseAPI}
 */
export class AtendimentosApi extends BaseAPI {
    /**
     * 
     * @param {Atendimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosApi
     */
    public atendimentosCreate(body: Atendimento, options?: any) {
        return AtendimentosApiFp(this.configuration).atendimentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosApi
     */
    public atendimentosDelete(id: number, options?: any) {
        return AtendimentosApiFp(this.configuration).atendimentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosApi
     */
    public atendimentosList(limit?: number, offset?: number, options?: any) {
        return AtendimentosApiFp(this.configuration).atendimentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Atendimento} body 
     * @param {number} id A unique integer value identifying this Atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosApi
     */
    public atendimentosPartialUpdate(body: Atendimento, id: number, options?: any) {
        return AtendimentosApiFp(this.configuration).atendimentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosApi
     */
    public atendimentosRead(id: number, options?: any) {
        return AtendimentosApiFp(this.configuration).atendimentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Atendimento} body 
     * @param {number} id A unique integer value identifying this Atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosApi
     */
    public atendimentosUpdate(body: Atendimento, id: number, options?: any) {
        return AtendimentosApiFp(this.configuration).atendimentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtendimentosColetivosApi - fetch parameter creator
 * @export
 */
export const AtendimentosColetivosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Coletivo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosCreate(body: Coletivo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosColetivosCreate.');
            }
            const localVarPath = `/atendimentos-coletivos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Coletivo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosColetivosDelete.');
            }
            const localVarPath = `/atendimentos-coletivos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atendimentos-coletivos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Coletivo} body 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosPartialUpdate(body: Coletivo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosColetivosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosColetivosPartialUpdate.');
            }
            const localVarPath = `/atendimentos-coletivos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Coletivo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosColetivosRead.');
            }
            const localVarPath = `/atendimentos-coletivos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Coletivo} body 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosUpdate(body: Coletivo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosColetivosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosColetivosUpdate.');
            }
            const localVarPath = `/atendimentos-coletivos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Coletivo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtendimentosColetivosApi - functional programming interface
 * @export
 */
export const AtendimentosColetivosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Coletivo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosCreate(body: Coletivo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Coletivo> {
            const localVarFetchArgs = AtendimentosColetivosApiFetchParamCreator(configuration).atendimentosColetivosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtendimentosColetivosApiFetchParamCreator(configuration).atendimentosColetivosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = AtendimentosColetivosApiFetchParamCreator(configuration).atendimentosColetivosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Coletivo} body 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosPartialUpdate(body: Coletivo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Coletivo> {
            const localVarFetchArgs = AtendimentosColetivosApiFetchParamCreator(configuration).atendimentosColetivosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Coletivo> {
            const localVarFetchArgs = AtendimentosColetivosApiFetchParamCreator(configuration).atendimentosColetivosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Coletivo} body 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosUpdate(body: Coletivo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Coletivo> {
            const localVarFetchArgs = AtendimentosColetivosApiFetchParamCreator(configuration).atendimentosColetivosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtendimentosColetivosApi - factory interface
 * @export
 */
export const AtendimentosColetivosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Coletivo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosCreate(body: Coletivo, options?: any) {
            return AtendimentosColetivosApiFp(configuration).atendimentosColetivosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosDelete(id: number, options?: any) {
            return AtendimentosColetivosApiFp(configuration).atendimentosColetivosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosList(limit?: number, offset?: number, options?: any) {
            return AtendimentosColetivosApiFp(configuration).atendimentosColetivosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Coletivo} body 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosPartialUpdate(body: Coletivo, id: number, options?: any) {
            return AtendimentosColetivosApiFp(configuration).atendimentosColetivosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosRead(id: number, options?: any) {
            return AtendimentosColetivosApiFp(configuration).atendimentosColetivosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Coletivo} body 
         * @param {number} id A unique integer value identifying this Atendimento Coletivo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosColetivosUpdate(body: Coletivo, id: number, options?: any) {
            return AtendimentosColetivosApiFp(configuration).atendimentosColetivosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtendimentosColetivosApi - object-oriented interface
 * @export
 * @class AtendimentosColetivosApi
 * @extends {BaseAPI}
 */
export class AtendimentosColetivosApi extends BaseAPI {
    /**
     * 
     * @param {Coletivo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosColetivosApi
     */
    public atendimentosColetivosCreate(body: Coletivo, options?: any) {
        return AtendimentosColetivosApiFp(this.configuration).atendimentosColetivosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atendimento Coletivo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosColetivosApi
     */
    public atendimentosColetivosDelete(id: number, options?: any) {
        return AtendimentosColetivosApiFp(this.configuration).atendimentosColetivosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosColetivosApi
     */
    public atendimentosColetivosList(limit?: number, offset?: number, options?: any) {
        return AtendimentosColetivosApiFp(this.configuration).atendimentosColetivosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Coletivo} body 
     * @param {number} id A unique integer value identifying this Atendimento Coletivo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosColetivosApi
     */
    public atendimentosColetivosPartialUpdate(body: Coletivo, id: number, options?: any) {
        return AtendimentosColetivosApiFp(this.configuration).atendimentosColetivosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atendimento Coletivo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosColetivosApi
     */
    public atendimentosColetivosRead(id: number, options?: any) {
        return AtendimentosColetivosApiFp(this.configuration).atendimentosColetivosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Coletivo} body 
     * @param {number} id A unique integer value identifying this Atendimento Coletivo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosColetivosApi
     */
    public atendimentosColetivosUpdate(body: Coletivo, id: number, options?: any) {
        return AtendimentosColetivosApiFp(this.configuration).atendimentosColetivosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtendimentosDocumentosApi - fetch parameter creator
 * @export
 */
export const AtendimentosDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosCreate(body: AtendimentoDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosDocumentosCreate.');
            }
            const localVarPath = `/atendimentos-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosDocumentosDelete.');
            }
            const localVarPath = `/atendimentos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atendimentos-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosPartialUpdate(body: AtendimentoDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosDocumentosPartialUpdate.');
            }
            const localVarPath = `/atendimentos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosDocumentosRead.');
            }
            const localVarPath = `/atendimentos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosUpdate(body: AtendimentoDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosDocumentosUpdate.');
            }
            const localVarPath = `/atendimentos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtendimentosDocumentosApi - functional programming interface
 * @export
 */
export const AtendimentosDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosCreate(body: AtendimentoDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoDocumento> {
            const localVarFetchArgs = AtendimentosDocumentosApiFetchParamCreator(configuration).atendimentosDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtendimentosDocumentosApiFetchParamCreator(configuration).atendimentosDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = AtendimentosDocumentosApiFetchParamCreator(configuration).atendimentosDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosPartialUpdate(body: AtendimentoDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoDocumento> {
            const localVarFetchArgs = AtendimentosDocumentosApiFetchParamCreator(configuration).atendimentosDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoDocumento> {
            const localVarFetchArgs = AtendimentosDocumentosApiFetchParamCreator(configuration).atendimentosDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosUpdate(body: AtendimentoDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoDocumento> {
            const localVarFetchArgs = AtendimentosDocumentosApiFetchParamCreator(configuration).atendimentosDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtendimentosDocumentosApi - factory interface
 * @export
 */
export const AtendimentosDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosCreate(body: AtendimentoDocumento, options?: any) {
            return AtendimentosDocumentosApiFp(configuration).atendimentosDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosDelete(id: number, options?: any) {
            return AtendimentosDocumentosApiFp(configuration).atendimentosDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosList(limit?: number, offset?: number, options?: any) {
            return AtendimentosDocumentosApiFp(configuration).atendimentosDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosPartialUpdate(body: AtendimentoDocumento, id: number, options?: any) {
            return AtendimentosDocumentosApiFp(configuration).atendimentosDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosRead(id: number, options?: any) {
            return AtendimentosDocumentosApiFp(configuration).atendimentosDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtendimentoDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosDocumentosUpdate(body: AtendimentoDocumento, id: number, options?: any) {
            return AtendimentosDocumentosApiFp(configuration).atendimentosDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtendimentosDocumentosApi - object-oriented interface
 * @export
 * @class AtendimentosDocumentosApi
 * @extends {BaseAPI}
 */
export class AtendimentosDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {AtendimentoDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosDocumentosApi
     */
    public atendimentosDocumentosCreate(body: AtendimentoDocumento, options?: any) {
        return AtendimentosDocumentosApiFp(this.configuration).atendimentosDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosDocumentosApi
     */
    public atendimentosDocumentosDelete(id: number, options?: any) {
        return AtendimentosDocumentosApiFp(this.configuration).atendimentosDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosDocumentosApi
     */
    public atendimentosDocumentosList(limit?: number, offset?: number, options?: any) {
        return AtendimentosDocumentosApiFp(this.configuration).atendimentosDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtendimentoDocumento} body 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosDocumentosApi
     */
    public atendimentosDocumentosPartialUpdate(body: AtendimentoDocumento, id: number, options?: any) {
        return AtendimentosDocumentosApiFp(this.configuration).atendimentosDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosDocumentosApi
     */
    public atendimentosDocumentosRead(id: number, options?: any) {
        return AtendimentosDocumentosApiFp(this.configuration).atendimentosDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtendimentoDocumento} body 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosDocumentosApi
     */
    public atendimentosDocumentosUpdate(body: AtendimentoDocumento, id: number, options?: any) {
        return AtendimentosDocumentosApiFp(this.configuration).atendimentosDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtendimentosGeraisApi - fetch parameter creator
 * @export
 */
export const AtendimentosGeraisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Atendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisCreate(body: Atendimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosGeraisCreate.');
            }
            const localVarPath = `/atendimentos-gerais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosGeraisDelete.');
            }
            const localVarPath = `/atendimentos-gerais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atendimentos-gerais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisPartialUpdate(body: Atendimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosGeraisPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosGeraisPartialUpdate.');
            }
            const localVarPath = `/atendimentos-gerais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosGeraisRead.');
            }
            const localVarPath = `/atendimentos-gerais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisUpdate(body: Atendimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosGeraisUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosGeraisUpdate.');
            }
            const localVarPath = `/atendimentos-gerais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtendimentosGeraisApi - functional programming interface
 * @export
 */
export const AtendimentosGeraisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Atendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisCreate(body: Atendimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atendimento> {
            const localVarFetchArgs = AtendimentosGeraisApiFetchParamCreator(configuration).atendimentosGeraisCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtendimentosGeraisApiFetchParamCreator(configuration).atendimentosGeraisDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = AtendimentosGeraisApiFetchParamCreator(configuration).atendimentosGeraisList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisPartialUpdate(body: Atendimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atendimento> {
            const localVarFetchArgs = AtendimentosGeraisApiFetchParamCreator(configuration).atendimentosGeraisPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atendimento> {
            const localVarFetchArgs = AtendimentosGeraisApiFetchParamCreator(configuration).atendimentosGeraisRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisUpdate(body: Atendimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atendimento> {
            const localVarFetchArgs = AtendimentosGeraisApiFetchParamCreator(configuration).atendimentosGeraisUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtendimentosGeraisApi - factory interface
 * @export
 */
export const AtendimentosGeraisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Atendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisCreate(body: Atendimento, options?: any) {
            return AtendimentosGeraisApiFp(configuration).atendimentosGeraisCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisDelete(id: number, options?: any) {
            return AtendimentosGeraisApiFp(configuration).atendimentosGeraisDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisList(limit?: number, offset?: number, options?: any) {
            return AtendimentosGeraisApiFp(configuration).atendimentosGeraisList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisPartialUpdate(body: Atendimento, id: number, options?: any) {
            return AtendimentosGeraisApiFp(configuration).atendimentosGeraisPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisRead(id: number, options?: any) {
            return AtendimentosGeraisApiFp(configuration).atendimentosGeraisRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Atendimento} body 
         * @param {number} id A unique integer value identifying this Atendimento Geral.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosGeraisUpdate(body: Atendimento, id: number, options?: any) {
            return AtendimentosGeraisApiFp(configuration).atendimentosGeraisUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtendimentosGeraisApi - object-oriented interface
 * @export
 * @class AtendimentosGeraisApi
 * @extends {BaseAPI}
 */
export class AtendimentosGeraisApi extends BaseAPI {
    /**
     * 
     * @param {Atendimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosGeraisApi
     */
    public atendimentosGeraisCreate(body: Atendimento, options?: any) {
        return AtendimentosGeraisApiFp(this.configuration).atendimentosGeraisCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atendimento Geral.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosGeraisApi
     */
    public atendimentosGeraisDelete(id: number, options?: any) {
        return AtendimentosGeraisApiFp(this.configuration).atendimentosGeraisDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosGeraisApi
     */
    public atendimentosGeraisList(limit?: number, offset?: number, options?: any) {
        return AtendimentosGeraisApiFp(this.configuration).atendimentosGeraisList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Atendimento} body 
     * @param {number} id A unique integer value identifying this Atendimento Geral.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosGeraisApi
     */
    public atendimentosGeraisPartialUpdate(body: Atendimento, id: number, options?: any) {
        return AtendimentosGeraisApiFp(this.configuration).atendimentosGeraisPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atendimento Geral.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosGeraisApi
     */
    public atendimentosGeraisRead(id: number, options?: any) {
        return AtendimentosGeraisApiFp(this.configuration).atendimentosGeraisRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Atendimento} body 
     * @param {number} id A unique integer value identifying this Atendimento Geral.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosGeraisApi
     */
    public atendimentosGeraisUpdate(body: Atendimento, id: number, options?: any) {
        return AtendimentosGeraisApiFp(this.configuration).atendimentosGeraisUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtendimentosPartesApi - fetch parameter creator
 * @export
 */
export const AtendimentosPartesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pessoa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesCreate(body: Pessoa, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosPartesCreate.');
            }
            const localVarPath = `/atendimentos-partes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pessoa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosPartesDelete.');
            }
            const localVarPath = `/atendimentos-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atendimentos-partes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pessoa} body 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesPartialUpdate(body: Pessoa, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosPartesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosPartesPartialUpdate.');
            }
            const localVarPath = `/atendimentos-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pessoa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosPartesRead.');
            }
            const localVarPath = `/atendimentos-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pessoa} body 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesUpdate(body: Pessoa, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosPartesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosPartesUpdate.');
            }
            const localVarPath = `/atendimentos-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pessoa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtendimentosPartesApi - functional programming interface
 * @export
 */
export const AtendimentosPartesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pessoa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesCreate(body: Pessoa, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pessoa> {
            const localVarFetchArgs = AtendimentosPartesApiFetchParamCreator(configuration).atendimentosPartesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtendimentosPartesApiFetchParamCreator(configuration).atendimentosPartesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = AtendimentosPartesApiFetchParamCreator(configuration).atendimentosPartesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Pessoa} body 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesPartialUpdate(body: Pessoa, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pessoa> {
            const localVarFetchArgs = AtendimentosPartesApiFetchParamCreator(configuration).atendimentosPartesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pessoa> {
            const localVarFetchArgs = AtendimentosPartesApiFetchParamCreator(configuration).atendimentosPartesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Pessoa} body 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesUpdate(body: Pessoa, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pessoa> {
            const localVarFetchArgs = AtendimentosPartesApiFetchParamCreator(configuration).atendimentosPartesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtendimentosPartesApi - factory interface
 * @export
 */
export const AtendimentosPartesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Pessoa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesCreate(body: Pessoa, options?: any) {
            return AtendimentosPartesApiFp(configuration).atendimentosPartesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesDelete(id: number, options?: any) {
            return AtendimentosPartesApiFp(configuration).atendimentosPartesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesList(limit?: number, offset?: number, options?: any) {
            return AtendimentosPartesApiFp(configuration).atendimentosPartesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Pessoa} body 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesPartialUpdate(body: Pessoa, id: number, options?: any) {
            return AtendimentosPartesApiFp(configuration).atendimentosPartesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesRead(id: number, options?: any) {
            return AtendimentosPartesApiFp(configuration).atendimentosPartesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Pessoa} body 
         * @param {number} id A unique integer value identifying this Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosPartesUpdate(body: Pessoa, id: number, options?: any) {
            return AtendimentosPartesApiFp(configuration).atendimentosPartesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtendimentosPartesApi - object-oriented interface
 * @export
 * @class AtendimentosPartesApi
 * @extends {BaseAPI}
 */
export class AtendimentosPartesApi extends BaseAPI {
    /**
     * 
     * @param {Pessoa} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosPartesApi
     */
    public atendimentosPartesCreate(body: Pessoa, options?: any) {
        return AtendimentosPartesApiFp(this.configuration).atendimentosPartesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosPartesApi
     */
    public atendimentosPartesDelete(id: number, options?: any) {
        return AtendimentosPartesApiFp(this.configuration).atendimentosPartesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosPartesApi
     */
    public atendimentosPartesList(limit?: number, offset?: number, options?: any) {
        return AtendimentosPartesApiFp(this.configuration).atendimentosPartesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Pessoa} body 
     * @param {number} id A unique integer value identifying this Parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosPartesApi
     */
    public atendimentosPartesPartialUpdate(body: Pessoa, id: number, options?: any) {
        return AtendimentosPartesApiFp(this.configuration).atendimentosPartesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosPartesApi
     */
    public atendimentosPartesRead(id: number, options?: any) {
        return AtendimentosPartesApiFp(this.configuration).atendimentosPartesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Pessoa} body 
     * @param {number} id A unique integer value identifying this Parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosPartesApi
     */
    public atendimentosPartesUpdate(body: Pessoa, id: number, options?: any) {
        return AtendimentosPartesApiFp(this.configuration).atendimentosPartesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtendimentosParticipantesApi - fetch parameter creator
 * @export
 */
export const AtendimentosParticipantesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesCreate(body: AtendimentoParticipante, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosParticipantesCreate.');
            }
            const localVarPath = `/atendimentos-participantes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoParticipante" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosParticipantesDelete.');
            }
            const localVarPath = `/atendimentos-participantes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atendimentos-participantes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesPartialUpdate(body: AtendimentoParticipante, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosParticipantesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosParticipantesPartialUpdate.');
            }
            const localVarPath = `/atendimentos-participantes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoParticipante" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosParticipantesRead.');
            }
            const localVarPath = `/atendimentos-participantes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesUpdate(body: AtendimentoParticipante, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atendimentosParticipantesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atendimentosParticipantesUpdate.');
            }
            const localVarPath = `/atendimentos-participantes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoParticipante" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtendimentosParticipantesApi - functional programming interface
 * @export
 */
export const AtendimentosParticipantesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesCreate(body: AtendimentoParticipante, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoParticipante> {
            const localVarFetchArgs = AtendimentosParticipantesApiFetchParamCreator(configuration).atendimentosParticipantesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtendimentosParticipantesApiFetchParamCreator(configuration).atendimentosParticipantesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = AtendimentosParticipantesApiFetchParamCreator(configuration).atendimentosParticipantesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesPartialUpdate(body: AtendimentoParticipante, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoParticipante> {
            const localVarFetchArgs = AtendimentosParticipantesApiFetchParamCreator(configuration).atendimentosParticipantesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoParticipante> {
            const localVarFetchArgs = AtendimentosParticipantesApiFetchParamCreator(configuration).atendimentosParticipantesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesUpdate(body: AtendimentoParticipante, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoParticipante> {
            const localVarFetchArgs = AtendimentosParticipantesApiFetchParamCreator(configuration).atendimentosParticipantesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtendimentosParticipantesApi - factory interface
 * @export
 */
export const AtendimentosParticipantesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesCreate(body: AtendimentoParticipante, options?: any) {
            return AtendimentosParticipantesApiFp(configuration).atendimentosParticipantesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesDelete(id: number, options?: any) {
            return AtendimentosParticipantesApiFp(configuration).atendimentosParticipantesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesList(limit?: number, offset?: number, options?: any) {
            return AtendimentosParticipantesApiFp(configuration).atendimentosParticipantesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesPartialUpdate(body: AtendimentoParticipante, id: number, options?: any) {
            return AtendimentosParticipantesApiFp(configuration).atendimentosParticipantesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesRead(id: number, options?: any) {
            return AtendimentosParticipantesApiFp(configuration).atendimentosParticipantesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtendimentoParticipante} body 
         * @param {number} id A unique integer value identifying this atendimento participante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosParticipantesUpdate(body: AtendimentoParticipante, id: number, options?: any) {
            return AtendimentosParticipantesApiFp(configuration).atendimentosParticipantesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtendimentosParticipantesApi - object-oriented interface
 * @export
 * @class AtendimentosParticipantesApi
 * @extends {BaseAPI}
 */
export class AtendimentosParticipantesApi extends BaseAPI {
    /**
     * 
     * @param {AtendimentoParticipante} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosParticipantesApi
     */
    public atendimentosParticipantesCreate(body: AtendimentoParticipante, options?: any) {
        return AtendimentosParticipantesApiFp(this.configuration).atendimentosParticipantesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this atendimento participante.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosParticipantesApi
     */
    public atendimentosParticipantesDelete(id: number, options?: any) {
        return AtendimentosParticipantesApiFp(this.configuration).atendimentosParticipantesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosParticipantesApi
     */
    public atendimentosParticipantesList(limit?: number, offset?: number, options?: any) {
        return AtendimentosParticipantesApiFp(this.configuration).atendimentosParticipantesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtendimentoParticipante} body 
     * @param {number} id A unique integer value identifying this atendimento participante.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosParticipantesApi
     */
    public atendimentosParticipantesPartialUpdate(body: AtendimentoParticipante, id: number, options?: any) {
        return AtendimentosParticipantesApiFp(this.configuration).atendimentosParticipantesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this atendimento participante.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosParticipantesApi
     */
    public atendimentosParticipantesRead(id: number, options?: any) {
        return AtendimentosParticipantesApiFp(this.configuration).atendimentosParticipantesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtendimentoParticipante} body 
     * @param {number} id A unique integer value identifying this atendimento participante.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosParticipantesApi
     */
    public atendimentosParticipantesUpdate(body: AtendimentoParticipante, id: number, options?: any) {
        return AtendimentosParticipantesApiFp(this.configuration).atendimentosParticipantesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtendimentosTotaisPorMesApi - fetch parameter creator
 * @export
 */
export const AtendimentosTotaisPorMesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} ano 
         * @param {number} mes 
         * @param {number} [area_id] 
         * @param {number} [usuario_defensor_id] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosTotaisPorMesList(ano: number, mes: number, area_id?: number, usuario_defensor_id?: number, limit?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'ano' is not null or undefined
            if (ano === null || ano === undefined) {
                throw new RequiredError('ano','Required parameter ano was null or undefined when calling atendimentosTotaisPorMesList.');
            }
            // verify required parameter 'mes' is not null or undefined
            if (mes === null || mes === undefined) {
                throw new RequiredError('mes','Required parameter mes was null or undefined when calling atendimentosTotaisPorMesList.');
            }
            const localVarPath = `/atendimentos-totais-por-mes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (ano !== undefined) {
                localVarQueryParameter['ano'] = ano;
            }

            if (mes !== undefined) {
                localVarQueryParameter['mes'] = mes;
            }

            if (area_id !== undefined) {
                localVarQueryParameter['area_id'] = area_id;
            }

            if (usuario_defensor_id !== undefined) {
                localVarQueryParameter['usuario_defensor_id'] = usuario_defensor_id;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtendimentosTotaisPorMesApi - functional programming interface
 * @export
 */
export const AtendimentosTotaisPorMesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} ano 
         * @param {number} mes 
         * @param {number} [area_id] 
         * @param {number} [usuario_defensor_id] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosTotaisPorMesList(ano: number, mes: number, area_id?: number, usuario_defensor_id?: number, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = AtendimentosTotaisPorMesApiFetchParamCreator(configuration).atendimentosTotaisPorMesList(ano, mes, area_id, usuario_defensor_id, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtendimentosTotaisPorMesApi - factory interface
 * @export
 */
export const AtendimentosTotaisPorMesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} ano 
         * @param {number} mes 
         * @param {number} [area_id] 
         * @param {number} [usuario_defensor_id] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atendimentosTotaisPorMesList(ano: number, mes: number, area_id?: number, usuario_defensor_id?: number, limit?: number, offset?: number, options?: any) {
            return AtendimentosTotaisPorMesApiFp(configuration).atendimentosTotaisPorMesList(ano, mes, area_id, usuario_defensor_id, limit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * AtendimentosTotaisPorMesApi - object-oriented interface
 * @export
 * @class AtendimentosTotaisPorMesApi
 * @extends {BaseAPI}
 */
export class AtendimentosTotaisPorMesApi extends BaseAPI {
    /**
     * 
     * @param {number} ano 
     * @param {number} mes 
     * @param {number} [area_id] 
     * @param {number} [usuario_defensor_id] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtendimentosTotaisPorMesApi
     */
    public atendimentosTotaisPorMesList(ano: number, mes: number, area_id?: number, usuario_defensor_id?: number, limit?: number, offset?: number, options?: any) {
        return AtendimentosTotaisPorMesApiFp(this.configuration).atendimentosTotaisPorMesList(ano, mes, area_id, usuario_defensor_id, limit, offset, options)(this.fetch, this.basePath);
    }

}
/**
 * AtividadesExtraordinariaApi - fetch parameter creator
 * @export
 */
export const AtividadesExtraordinariaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaCreate(body: AtividadeExtraordinaria, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atividadesExtraordinariaCreate.');
            }
            const localVarPath = `/atividades-extraordinaria/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtividadeExtraordinaria" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atividadesExtraordinariaDelete.');
            }
            const localVarPath = `/atividades-extraordinaria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atividades-extraordinaria/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaPartialUpdate(body: AtividadeExtraordinaria, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atividadesExtraordinariaPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atividadesExtraordinariaPartialUpdate.');
            }
            const localVarPath = `/atividades-extraordinaria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtividadeExtraordinaria" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atividadesExtraordinariaRead.');
            }
            const localVarPath = `/atividades-extraordinaria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaUpdate(body: AtividadeExtraordinaria, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atividadesExtraordinariaUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atividadesExtraordinariaUpdate.');
            }
            const localVarPath = `/atividades-extraordinaria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtividadeExtraordinaria" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtividadesExtraordinariaApi - functional programming interface
 * @export
 */
export const AtividadesExtraordinariaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaCreate(body: AtividadeExtraordinaria, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtividadeExtraordinaria> {
            const localVarFetchArgs = AtividadesExtraordinariaApiFetchParamCreator(configuration).atividadesExtraordinariaCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtividadesExtraordinariaApiFetchParamCreator(configuration).atividadesExtraordinariaDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = AtividadesExtraordinariaApiFetchParamCreator(configuration).atividadesExtraordinariaList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaPartialUpdate(body: AtividadeExtraordinaria, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtividadeExtraordinaria> {
            const localVarFetchArgs = AtividadesExtraordinariaApiFetchParamCreator(configuration).atividadesExtraordinariaPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtividadeExtraordinaria> {
            const localVarFetchArgs = AtividadesExtraordinariaApiFetchParamCreator(configuration).atividadesExtraordinariaRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaUpdate(body: AtividadeExtraordinaria, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtividadeExtraordinaria> {
            const localVarFetchArgs = AtividadesExtraordinariaApiFetchParamCreator(configuration).atividadesExtraordinariaUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtividadesExtraordinariaApi - factory interface
 * @export
 */
export const AtividadesExtraordinariaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaCreate(body: AtividadeExtraordinaria, options?: any) {
            return AtividadesExtraordinariaApiFp(configuration).atividadesExtraordinariaCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaDelete(id: number, options?: any) {
            return AtividadesExtraordinariaApiFp(configuration).atividadesExtraordinariaDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaList(limit?: number, offset?: number, options?: any) {
            return AtividadesExtraordinariaApiFp(configuration).atividadesExtraordinariaList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaPartialUpdate(body: AtividadeExtraordinaria, id: number, options?: any) {
            return AtividadesExtraordinariaApiFp(configuration).atividadesExtraordinariaPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaRead(id: number, options?: any) {
            return AtividadesExtraordinariaApiFp(configuration).atividadesExtraordinariaRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtividadeExtraordinaria} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atividadesExtraordinariaUpdate(body: AtividadeExtraordinaria, id: number, options?: any) {
            return AtividadesExtraordinariaApiFp(configuration).atividadesExtraordinariaUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtividadesExtraordinariaApi - object-oriented interface
 * @export
 * @class AtividadesExtraordinariaApi
 * @extends {BaseAPI}
 */
export class AtividadesExtraordinariaApi extends BaseAPI {
    /**
     * 
     * @param {AtividadeExtraordinaria} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtividadesExtraordinariaApi
     */
    public atividadesExtraordinariaCreate(body: AtividadeExtraordinaria, options?: any) {
        return AtividadesExtraordinariaApiFp(this.configuration).atividadesExtraordinariaCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atividade Extraordinária.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtividadesExtraordinariaApi
     */
    public atividadesExtraordinariaDelete(id: number, options?: any) {
        return AtividadesExtraordinariaApiFp(this.configuration).atividadesExtraordinariaDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtividadesExtraordinariaApi
     */
    public atividadesExtraordinariaList(limit?: number, offset?: number, options?: any) {
        return AtividadesExtraordinariaApiFp(this.configuration).atividadesExtraordinariaList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtividadeExtraordinaria} body 
     * @param {number} id A unique integer value identifying this Atividade Extraordinária.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtividadesExtraordinariaApi
     */
    public atividadesExtraordinariaPartialUpdate(body: AtividadeExtraordinaria, id: number, options?: any) {
        return AtividadesExtraordinariaApiFp(this.configuration).atividadesExtraordinariaPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atividade Extraordinária.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtividadesExtraordinariaApi
     */
    public atividadesExtraordinariaRead(id: number, options?: any) {
        return AtividadesExtraordinariaApiFp(this.configuration).atividadesExtraordinariaRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtividadeExtraordinaria} body 
     * @param {number} id A unique integer value identifying this Atividade Extraordinária.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtividadesExtraordinariaApi
     */
    public atividadesExtraordinariaUpdate(body: AtividadeExtraordinaria, id: number, options?: any) {
        return AtividadesExtraordinariaApiFp(this.configuration).atividadesExtraordinariaUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtuacoesApi - fetch parameter creator
 * @export
 */
export const AtuacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtuacaoCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesCreate(body: AtuacaoCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atuacoesCreate.');
            }
            const localVarPath = `/atuacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtuacaoCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atuacoesDelete.');
            }
            const localVarPath = `/atuacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [defensor] 
         * @param {string} [servidor] 
         * @param {string} [defensoria] 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [eh_defensor] 
         * @param {string} [esta_vigente] 
         * @param {string} [incluir_filhos] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesList(tipo?: string, defensor?: string, servidor?: string, defensoria?: string, data_inicial?: string, data_final?: string, eh_defensor?: string, esta_vigente?: string, incluir_filhos?: string, ativo?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atuacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (tipo !== undefined) {
                localVarQueryParameter['tipo'] = tipo;
            }

            if (defensor !== undefined) {
                localVarQueryParameter['defensor'] = defensor;
            }

            if (servidor !== undefined) {
                localVarQueryParameter['servidor'] = servidor;
            }

            if (defensoria !== undefined) {
                localVarQueryParameter['defensoria'] = defensoria;
            }

            if (data_inicial !== undefined) {
                localVarQueryParameter['data_inicial'] = data_inicial;
            }

            if (data_final !== undefined) {
                localVarQueryParameter['data_final'] = data_final;
            }

            if (eh_defensor !== undefined) {
                localVarQueryParameter['eh_defensor'] = eh_defensor;
            }

            if (esta_vigente !== undefined) {
                localVarQueryParameter['esta_vigente'] = esta_vigente;
            }

            if (incluir_filhos !== undefined) {
                localVarQueryParameter['incluir_filhos'] = incluir_filhos;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Atuacao} body 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesPartialUpdate(body: Atuacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atuacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atuacoesPartialUpdate.');
            }
            const localVarPath = `/atuacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atuacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atuacoesRead.');
            }
            const localVarPath = `/atuacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Atuacao} body 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesUpdate(body: Atuacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atuacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atuacoesUpdate.');
            }
            const localVarPath = `/atuacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atuacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtuacoesApi - functional programming interface
 * @export
 */
export const AtuacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtuacaoCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesCreate(body: AtuacaoCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtuacaoCreate> {
            const localVarFetchArgs = AtuacoesApiFetchParamCreator(configuration).atuacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtuacoesApiFetchParamCreator(configuration).atuacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [defensor] 
         * @param {string} [servidor] 
         * @param {string} [defensoria] 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [eh_defensor] 
         * @param {string} [esta_vigente] 
         * @param {string} [incluir_filhos] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesList(tipo?: string, defensor?: string, servidor?: string, defensoria?: string, data_inicial?: string, data_final?: string, eh_defensor?: string, esta_vigente?: string, incluir_filhos?: string, ativo?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = AtuacoesApiFetchParamCreator(configuration).atuacoesList(tipo, defensor, servidor, defensoria, data_inicial, data_final, eh_defensor, esta_vigente, incluir_filhos, ativo, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Atuacao} body 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesPartialUpdate(body: Atuacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atuacao> {
            const localVarFetchArgs = AtuacoesApiFetchParamCreator(configuration).atuacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atuacao> {
            const localVarFetchArgs = AtuacoesApiFetchParamCreator(configuration).atuacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Atuacao} body 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesUpdate(body: Atuacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atuacao> {
            const localVarFetchArgs = AtuacoesApiFetchParamCreator(configuration).atuacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtuacoesApi - factory interface
 * @export
 */
export const AtuacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AtuacaoCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesCreate(body: AtuacaoCreate, options?: any) {
            return AtuacoesApiFp(configuration).atuacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDelete(id: number, options?: any) {
            return AtuacoesApiFp(configuration).atuacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [defensor] 
         * @param {string} [servidor] 
         * @param {string} [defensoria] 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [eh_defensor] 
         * @param {string} [esta_vigente] 
         * @param {string} [incluir_filhos] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesList(tipo?: string, defensor?: string, servidor?: string, defensoria?: string, data_inicial?: string, data_final?: string, eh_defensor?: string, esta_vigente?: string, incluir_filhos?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
            return AtuacoesApiFp(configuration).atuacoesList(tipo, defensor, servidor, defensoria, data_inicial, data_final, eh_defensor, esta_vigente, incluir_filhos, ativo, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Atuacao} body 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesPartialUpdate(body: Atuacao, id: number, options?: any) {
            return AtuacoesApiFp(configuration).atuacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesRead(id: number, options?: any) {
            return AtuacoesApiFp(configuration).atuacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Atuacao} body 
         * @param {number} id A unique integer value identifying this Atuação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesUpdate(body: Atuacao, id: number, options?: any) {
            return AtuacoesApiFp(configuration).atuacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtuacoesApi - object-oriented interface
 * @export
 * @class AtuacoesApi
 * @extends {BaseAPI}
 */
export class AtuacoesApi extends BaseAPI {
    /**
     * 
     * @param {AtuacaoCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesApi
     */
    public atuacoesCreate(body: AtuacaoCreate, options?: any) {
        return AtuacoesApiFp(this.configuration).atuacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atuação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesApi
     */
    public atuacoesDelete(id: number, options?: any) {
        return AtuacoesApiFp(this.configuration).atuacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [tipo] 
     * @param {string} [defensor] 
     * @param {string} [servidor] 
     * @param {string} [defensoria] 
     * @param {string} [data_inicial] 
     * @param {string} [data_final] 
     * @param {string} [eh_defensor] 
     * @param {string} [esta_vigente] 
     * @param {string} [incluir_filhos] 
     * @param {string} [ativo] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesApi
     */
    public atuacoesList(tipo?: string, defensor?: string, servidor?: string, defensoria?: string, data_inicial?: string, data_final?: string, eh_defensor?: string, esta_vigente?: string, incluir_filhos?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
        return AtuacoesApiFp(this.configuration).atuacoesList(tipo, defensor, servidor, defensoria, data_inicial, data_final, eh_defensor, esta_vigente, incluir_filhos, ativo, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Atuacao} body 
     * @param {number} id A unique integer value identifying this Atuação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesApi
     */
    public atuacoesPartialUpdate(body: Atuacao, id: number, options?: any) {
        return AtuacoesApiFp(this.configuration).atuacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atuação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesApi
     */
    public atuacoesRead(id: number, options?: any) {
        return AtuacoesApiFp(this.configuration).atuacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Atuacao} body 
     * @param {number} id A unique integer value identifying this Atuação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesApi
     */
    public atuacoesUpdate(body: Atuacao, id: number, options?: any) {
        return AtuacoesApiFp(this.configuration).atuacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtuacoesDocumentosApi - fetch parameter creator
 * @export
 */
export const AtuacoesDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosCreate(body: DefensorDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atuacoesDocumentosCreate.');
            }
            const localVarPath = `/atuacoes-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensorDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atuacoesDocumentosDelete.');
            }
            const localVarPath = `/atuacoes-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atuacoes-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosPartialUpdate(body: DefensorDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atuacoesDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atuacoesDocumentosPartialUpdate.');
            }
            const localVarPath = `/atuacoes-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensorDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atuacoesDocumentosRead.');
            }
            const localVarPath = `/atuacoes-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosUpdate(body: DefensorDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atuacoesDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atuacoesDocumentosUpdate.');
            }
            const localVarPath = `/atuacoes-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensorDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtuacoesDocumentosApi - functional programming interface
 * @export
 */
export const AtuacoesDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosCreate(body: DefensorDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensorDocumento> {
            const localVarFetchArgs = AtuacoesDocumentosApiFetchParamCreator(configuration).atuacoesDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtuacoesDocumentosApiFetchParamCreator(configuration).atuacoesDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = AtuacoesDocumentosApiFetchParamCreator(configuration).atuacoesDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosPartialUpdate(body: DefensorDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensorDocumento> {
            const localVarFetchArgs = AtuacoesDocumentosApiFetchParamCreator(configuration).atuacoesDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensorDocumento> {
            const localVarFetchArgs = AtuacoesDocumentosApiFetchParamCreator(configuration).atuacoesDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosUpdate(body: DefensorDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensorDocumento> {
            const localVarFetchArgs = AtuacoesDocumentosApiFetchParamCreator(configuration).atuacoesDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtuacoesDocumentosApi - factory interface
 * @export
 */
export const AtuacoesDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosCreate(body: DefensorDocumento, options?: any) {
            return AtuacoesDocumentosApiFp(configuration).atuacoesDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosDelete(id: number, options?: any) {
            return AtuacoesDocumentosApiFp(configuration).atuacoesDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosList(limit?: number, offset?: number, options?: any) {
            return AtuacoesDocumentosApiFp(configuration).atuacoesDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosPartialUpdate(body: DefensorDocumento, id: number, options?: any) {
            return AtuacoesDocumentosApiFp(configuration).atuacoesDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosRead(id: number, options?: any) {
            return AtuacoesDocumentosApiFp(configuration).atuacoesDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DefensorDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atuacoesDocumentosUpdate(body: DefensorDocumento, id: number, options?: any) {
            return AtuacoesDocumentosApiFp(configuration).atuacoesDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtuacoesDocumentosApi - object-oriented interface
 * @export
 * @class AtuacoesDocumentosApi
 * @extends {BaseAPI}
 */
export class AtuacoesDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {DefensorDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesDocumentosApi
     */
    public atuacoesDocumentosCreate(body: DefensorDocumento, options?: any) {
        return AtuacoesDocumentosApiFp(this.configuration).atuacoesDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesDocumentosApi
     */
    public atuacoesDocumentosDelete(id: number, options?: any) {
        return AtuacoesDocumentosApiFp(this.configuration).atuacoesDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesDocumentosApi
     */
    public atuacoesDocumentosList(limit?: number, offset?: number, options?: any) {
        return AtuacoesDocumentosApiFp(this.configuration).atuacoesDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DefensorDocumento} body 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesDocumentosApi
     */
    public atuacoesDocumentosPartialUpdate(body: DefensorDocumento, id: number, options?: any) {
        return AtuacoesDocumentosApiFp(this.configuration).atuacoesDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesDocumentosApi
     */
    public atuacoesDocumentosRead(id: number, options?: any) {
        return AtuacoesDocumentosApiFp(this.configuration).atuacoesDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DefensorDocumento} body 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtuacoesDocumentosApi
     */
    public atuacoesDocumentosUpdate(body: DefensorDocumento, id: number, options?: any) {
        return AtuacoesDocumentosApiFp(this.configuration).atuacoesDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AtualizacoesApi - fetch parameter creator
 * @export
 */
export const AtualizacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Atualizacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesCreate(body: Atualizacao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atualizacoesCreate.');
            }
            const localVarPath = `/atualizacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atualizacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atualizacoesDelete.');
            }
            const localVarPath = `/atualizacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/atualizacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Atualizacao} body 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesPartialUpdate(body: Atualizacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atualizacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atualizacoesPartialUpdate.');
            }
            const localVarPath = `/atualizacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atualizacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atualizacoesRead.');
            }
            const localVarPath = `/atualizacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Atualizacao} body 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesUpdate(body: Atualizacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atualizacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atualizacoesUpdate.');
            }
            const localVarPath = `/atualizacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Atualizacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtualizacoesApi - functional programming interface
 * @export
 */
export const AtualizacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Atualizacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesCreate(body: Atualizacao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atualizacao> {
            const localVarFetchArgs = AtualizacoesApiFetchParamCreator(configuration).atualizacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AtualizacoesApiFetchParamCreator(configuration).atualizacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = AtualizacoesApiFetchParamCreator(configuration).atualizacoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Atualizacao} body 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesPartialUpdate(body: Atualizacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atualizacao> {
            const localVarFetchArgs = AtualizacoesApiFetchParamCreator(configuration).atualizacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atualizacao> {
            const localVarFetchArgs = AtualizacoesApiFetchParamCreator(configuration).atualizacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Atualizacao} body 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesUpdate(body: Atualizacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Atualizacao> {
            const localVarFetchArgs = AtualizacoesApiFetchParamCreator(configuration).atualizacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtualizacoesApi - factory interface
 * @export
 */
export const AtualizacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Atualizacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesCreate(body: Atualizacao, options?: any) {
            return AtualizacoesApiFp(configuration).atualizacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesDelete(id: number, options?: any) {
            return AtualizacoesApiFp(configuration).atualizacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesList(limit?: number, offset?: number, options?: any) {
            return AtualizacoesApiFp(configuration).atualizacoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Atualizacao} body 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesPartialUpdate(body: Atualizacao, id: number, options?: any) {
            return AtualizacoesApiFp(configuration).atualizacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesRead(id: number, options?: any) {
            return AtualizacoesApiFp(configuration).atualizacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Atualizacao} body 
         * @param {number} id A unique integer value identifying this Atualização.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atualizacoesUpdate(body: Atualizacao, id: number, options?: any) {
            return AtualizacoesApiFp(configuration).atualizacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AtualizacoesApi - object-oriented interface
 * @export
 * @class AtualizacoesApi
 * @extends {BaseAPI}
 */
export class AtualizacoesApi extends BaseAPI {
    /**
     * 
     * @param {Atualizacao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtualizacoesApi
     */
    public atualizacoesCreate(body: Atualizacao, options?: any) {
        return AtualizacoesApiFp(this.configuration).atualizacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atualização.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtualizacoesApi
     */
    public atualizacoesDelete(id: number, options?: any) {
        return AtualizacoesApiFp(this.configuration).atualizacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtualizacoesApi
     */
    public atualizacoesList(limit?: number, offset?: number, options?: any) {
        return AtualizacoesApiFp(this.configuration).atualizacoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Atualizacao} body 
     * @param {number} id A unique integer value identifying this Atualização.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtualizacoesApi
     */
    public atualizacoesPartialUpdate(body: Atualizacao, id: number, options?: any) {
        return AtualizacoesApiFp(this.configuration).atualizacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atualização.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtualizacoesApi
     */
    public atualizacoesRead(id: number, options?: any) {
        return AtualizacoesApiFp(this.configuration).atualizacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Atualizacao} body 
     * @param {number} id A unique integer value identifying this Atualização.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtualizacoesApi
     */
    public atualizacoesUpdate(body: Atualizacao, id: number, options?: any) {
        return AtualizacoesApiFp(this.configuration).atualizacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AudienciasApi - fetch parameter creator
 * @export
 */
export const AudienciasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Audiencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasCreate(body: Audiencia, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling audienciasCreate.');
            }
            const localVarPath = `/audiencias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Audiencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling audienciasDelete.');
            }
            const localVarPath = `/audiencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [defensor_cadastro] 
         * @param {string} [defensoria] 
         * @param {string} [processo] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasList(data_inicial?: string, data_final?: string, defensor_cadastro?: string, defensoria?: string, processo?: string, ativo?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/audiencias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (data_inicial !== undefined) {
                localVarQueryParameter['data_inicial'] = data_inicial;
            }

            if (data_final !== undefined) {
                localVarQueryParameter['data_final'] = data_final;
            }

            if (defensor_cadastro !== undefined) {
                localVarQueryParameter['defensor_cadastro'] = defensor_cadastro;
            }

            if (defensoria !== undefined) {
                localVarQueryParameter['defensoria'] = defensoria;
            }

            if (processo !== undefined) {
                localVarQueryParameter['processo'] = processo;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Audiencia} body 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasPartialUpdate(body: Audiencia, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling audienciasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling audienciasPartialUpdate.');
            }
            const localVarPath = `/audiencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Audiencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling audienciasRead.');
            }
            const localVarPath = `/audiencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Audiencia} body 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasUpdate(body: Audiencia, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling audienciasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling audienciasUpdate.');
            }
            const localVarPath = `/audiencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Audiencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudienciasApi - functional programming interface
 * @export
 */
export const AudienciasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Audiencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasCreate(body: Audiencia, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Audiencia> {
            const localVarFetchArgs = AudienciasApiFetchParamCreator(configuration).audienciasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AudienciasApiFetchParamCreator(configuration).audienciasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [defensor_cadastro] 
         * @param {string} [defensoria] 
         * @param {string} [processo] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasList(data_inicial?: string, data_final?: string, defensor_cadastro?: string, defensoria?: string, processo?: string, ativo?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
            const localVarFetchArgs = AudienciasApiFetchParamCreator(configuration).audienciasList(data_inicial, data_final, defensor_cadastro, defensoria, processo, ativo, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Audiencia} body 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasPartialUpdate(body: Audiencia, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Audiencia> {
            const localVarFetchArgs = AudienciasApiFetchParamCreator(configuration).audienciasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Audiencia> {
            const localVarFetchArgs = AudienciasApiFetchParamCreator(configuration).audienciasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Audiencia} body 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasUpdate(body: Audiencia, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Audiencia> {
            const localVarFetchArgs = AudienciasApiFetchParamCreator(configuration).audienciasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AudienciasApi - factory interface
 * @export
 */
export const AudienciasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Audiencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasCreate(body: Audiencia, options?: any) {
            return AudienciasApiFp(configuration).audienciasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasDelete(id: number, options?: any) {
            return AudienciasApiFp(configuration).audienciasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [defensor_cadastro] 
         * @param {string} [defensoria] 
         * @param {string} [processo] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasList(data_inicial?: string, data_final?: string, defensor_cadastro?: string, defensoria?: string, processo?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
            return AudienciasApiFp(configuration).audienciasList(data_inicial, data_final, defensor_cadastro, defensoria, processo, ativo, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Audiencia} body 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasPartialUpdate(body: Audiencia, id: number, options?: any) {
            return AudienciasApiFp(configuration).audienciasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasRead(id: number, options?: any) {
            return AudienciasApiFp(configuration).audienciasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Audiencia} body 
         * @param {number} id A unique integer value identifying this audiencia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasUpdate(body: Audiencia, id: number, options?: any) {
            return AudienciasApiFp(configuration).audienciasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * AudienciasApi - object-oriented interface
 * @export
 * @class AudienciasApi
 * @extends {BaseAPI}
 */
export class AudienciasApi extends BaseAPI {
    /**
     * 
     * @param {Audiencia} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienciasApi
     */
    public audienciasCreate(body: Audiencia, options?: any) {
        return AudienciasApiFp(this.configuration).audienciasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this audiencia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienciasApi
     */
    public audienciasDelete(id: number, options?: any) {
        return AudienciasApiFp(this.configuration).audienciasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [data_inicial] 
     * @param {string} [data_final] 
     * @param {string} [defensor_cadastro] 
     * @param {string} [defensoria] 
     * @param {string} [processo] 
     * @param {string} [ativo] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienciasApi
     */
    public audienciasList(data_inicial?: string, data_final?: string, defensor_cadastro?: string, defensoria?: string, processo?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
        return AudienciasApiFp(this.configuration).audienciasList(data_inicial, data_final, defensor_cadastro, defensoria, processo, ativo, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Audiencia} body 
     * @param {number} id A unique integer value identifying this audiencia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienciasApi
     */
    public audienciasPartialUpdate(body: Audiencia, id: number, options?: any) {
        return AudienciasApiFp(this.configuration).audienciasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this audiencia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienciasApi
     */
    public audienciasRead(id: number, options?: any) {
        return AudienciasApiFp(this.configuration).audienciasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Audiencia} body 
     * @param {number} id A unique integer value identifying this audiencia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienciasApi
     */
    public audienciasUpdate(body: Audiencia, id: number, options?: any) {
        return AudienciasApiFp(this.configuration).audienciasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * AudienciasTotaisPorMesApi - fetch parameter creator
 * @export
 */
export const AudienciasTotaisPorMesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} ano 
         * @param {number} mes 
         * @param {number} [area_id] 
         * @param {string} [vara_id] Valores múltiplos podem ser separados por vírgulas.
         * @param {number} [usuario_defensor_id] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasTotaisPorMesList(ano: number, mes: number, area_id?: number, vara_id?: string, usuario_defensor_id?: number, limit?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'ano' is not null or undefined
            if (ano === null || ano === undefined) {
                throw new RequiredError('ano','Required parameter ano was null or undefined when calling audienciasTotaisPorMesList.');
            }
            // verify required parameter 'mes' is not null or undefined
            if (mes === null || mes === undefined) {
                throw new RequiredError('mes','Required parameter mes was null or undefined when calling audienciasTotaisPorMesList.');
            }
            const localVarPath = `/audiencias-totais-por-mes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (ano !== undefined) {
                localVarQueryParameter['ano'] = ano;
            }

            if (mes !== undefined) {
                localVarQueryParameter['mes'] = mes;
            }

            if (area_id !== undefined) {
                localVarQueryParameter['area_id'] = area_id;
            }

            if (vara_id !== undefined) {
                localVarQueryParameter['vara_id'] = vara_id;
            }

            if (usuario_defensor_id !== undefined) {
                localVarQueryParameter['usuario_defensor_id'] = usuario_defensor_id;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudienciasTotaisPorMesApi - functional programming interface
 * @export
 */
export const AudienciasTotaisPorMesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} ano 
         * @param {number} mes 
         * @param {number} [area_id] 
         * @param {string} [vara_id] Valores múltiplos podem ser separados por vírgulas.
         * @param {number} [usuario_defensor_id] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasTotaisPorMesList(ano: number, mes: number, area_id?: number, vara_id?: string, usuario_defensor_id?: number, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = AudienciasTotaisPorMesApiFetchParamCreator(configuration).audienciasTotaisPorMesList(ano, mes, area_id, vara_id, usuario_defensor_id, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AudienciasTotaisPorMesApi - factory interface
 * @export
 */
export const AudienciasTotaisPorMesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} ano 
         * @param {number} mes 
         * @param {number} [area_id] 
         * @param {string} [vara_id] Valores múltiplos podem ser separados por vírgulas.
         * @param {number} [usuario_defensor_id] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienciasTotaisPorMesList(ano: number, mes: number, area_id?: number, vara_id?: string, usuario_defensor_id?: number, limit?: number, offset?: number, options?: any) {
            return AudienciasTotaisPorMesApiFp(configuration).audienciasTotaisPorMesList(ano, mes, area_id, vara_id, usuario_defensor_id, limit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * AudienciasTotaisPorMesApi - object-oriented interface
 * @export
 * @class AudienciasTotaisPorMesApi
 * @extends {BaseAPI}
 */
export class AudienciasTotaisPorMesApi extends BaseAPI {
    /**
     * 
     * @param {number} ano 
     * @param {number} mes 
     * @param {number} [area_id] 
     * @param {string} [vara_id] Valores múltiplos podem ser separados por vírgulas.
     * @param {number} [usuario_defensor_id] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienciasTotaisPorMesApi
     */
    public audienciasTotaisPorMesList(ano: number, mes: number, area_id?: number, vara_id?: string, usuario_defensor_id?: number, limit?: number, offset?: number, options?: any) {
        return AudienciasTotaisPorMesApiFp(this.configuration).audienciasTotaisPorMesList(ano, mes, area_id, vara_id, usuario_defensor_id, limit, offset, options)(this.fetch, this.basePath);
    }

}
/**
 * AvisosApi - fetch parameter creator
 * @export
 */
export const AvisosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosDistribuirCreate(options: any = {}): FetchArgs {
            const localVarPath = `/avisos/distribuir/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [comarca] 
         * @param {string} [defensor] 
         * @param {string} [defensoria] 
         * @param {string} [paridade] 
         * @param {string} [sistema_webservice] 
         * @param {string} [vara] 
         * @param {string} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosDistribuirList(comarca?: string, defensor?: string, defensoria?: string, paridade?: string, sistema_webservice?: string, vara?: string, page?: string, options: any = {}): FetchArgs {
            const localVarPath = `/avisos/distribuir/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (comarca !== undefined) {
                localVarQueryParameter['comarca'] = comarca;
            }

            if (defensor !== undefined) {
                localVarQueryParameter['defensor'] = defensor;
            }

            if (defensoria !== undefined) {
                localVarQueryParameter['defensoria'] = defensoria;
            }

            if (paridade !== undefined) {
                localVarQueryParameter['paridade'] = paridade;
            }

            if (sistema_webservice !== undefined) {
                localVarQueryParameter['sistema_webservice'] = sistema_webservice;
            }

            if (vara !== undefined) {
                localVarQueryParameter['vara'] = vara;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [defensoria] 
         * @param {string} [responsavel] 
         * @param {string} [sistema_webservice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosPainelList(defensoria?: string, responsavel?: string, sistema_webservice?: string, options: any = {}): FetchArgs {
            const localVarPath = `/avisos/painel/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (defensoria !== undefined) {
                localVarQueryParameter['defensoria'] = defensoria;
            }

            if (responsavel !== undefined) {
                localVarQueryParameter['responsavel'] = responsavel;
            }

            if (sistema_webservice !== undefined) {
                localVarQueryParameter['sistema_webservice'] = sistema_webservice;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvisosApi - functional programming interface
 * @export
 */
export const AvisosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosDistribuirCreate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AvisosApiFetchParamCreator(configuration).avisosDistribuirCreate(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [comarca] 
         * @param {string} [defensor] 
         * @param {string} [defensoria] 
         * @param {string} [paridade] 
         * @param {string} [sistema_webservice] 
         * @param {string} [vara] 
         * @param {string} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosDistribuirList(comarca?: string, defensor?: string, defensoria?: string, paridade?: string, sistema_webservice?: string, vara?: string, page?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AvisosApiFetchParamCreator(configuration).avisosDistribuirList(comarca, defensor, defensoria, paridade, sistema_webservice, vara, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [defensoria] 
         * @param {string} [responsavel] 
         * @param {string} [sistema_webservice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosPainelList(defensoria?: string, responsavel?: string, sistema_webservice?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PainelDeAviso> {
            const localVarFetchArgs = AvisosApiFetchParamCreator(configuration).avisosPainelList(defensoria, responsavel, sistema_webservice, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AvisosApi - factory interface
 * @export
 */
export const AvisosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosDistribuirCreate(options?: any) {
            return AvisosApiFp(configuration).avisosDistribuirCreate(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [comarca] 
         * @param {string} [defensor] 
         * @param {string} [defensoria] 
         * @param {string} [paridade] 
         * @param {string} [sistema_webservice] 
         * @param {string} [vara] 
         * @param {string} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosDistribuirList(comarca?: string, defensor?: string, defensoria?: string, paridade?: string, sistema_webservice?: string, vara?: string, page?: string, options?: any) {
            return AvisosApiFp(configuration).avisosDistribuirList(comarca, defensor, defensoria, paridade, sistema_webservice, vara, page, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [defensoria] 
         * @param {string} [responsavel] 
         * @param {string} [sistema_webservice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avisosPainelList(defensoria?: string, responsavel?: string, sistema_webservice?: string, options?: any) {
            return AvisosApiFp(configuration).avisosPainelList(defensoria, responsavel, sistema_webservice, options)(fetch, basePath);
        },
    };
};

/**
 * AvisosApi - object-oriented interface
 * @export
 * @class AvisosApi
 * @extends {BaseAPI}
 */
export class AvisosApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvisosApi
     */
    public avisosDistribuirCreate(options?: any) {
        return AvisosApiFp(this.configuration).avisosDistribuirCreate(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [comarca] 
     * @param {string} [defensor] 
     * @param {string} [defensoria] 
     * @param {string} [paridade] 
     * @param {string} [sistema_webservice] 
     * @param {string} [vara] 
     * @param {string} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvisosApi
     */
    public avisosDistribuirList(comarca?: string, defensor?: string, defensoria?: string, paridade?: string, sistema_webservice?: string, vara?: string, page?: string, options?: any) {
        return AvisosApiFp(this.configuration).avisosDistribuirList(comarca, defensor, defensoria, paridade, sistema_webservice, vara, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [defensoria] 
     * @param {string} [responsavel] 
     * @param {string} [sistema_webservice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvisosApi
     */
    public avisosPainelList(defensoria?: string, responsavel?: string, sistema_webservice?: string, options?: any) {
        return AvisosApiFp(this.configuration).avisosPainelList(defensoria, responsavel, sistema_webservice, options)(this.fetch, this.basePath);
    }

}
/**
 * BairrosApi - fetch parameter creator
 * @export
 */
export const BairrosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Bairro} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosCreate(body: Bairro, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bairrosCreate.');
            }
            const localVarPath = `/bairros/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bairro" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bairrosDelete.');
            }
            const localVarPath = `/bairros/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/bairros/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Bairro} body 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosPartialUpdate(body: Bairro, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bairrosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bairrosPartialUpdate.');
            }
            const localVarPath = `/bairros/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bairro" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bairrosRead.');
            }
            const localVarPath = `/bairros/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Bairro} body 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosUpdate(body: Bairro, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bairrosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bairrosUpdate.');
            }
            const localVarPath = `/bairros/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bairro" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BairrosApi - functional programming interface
 * @export
 */
export const BairrosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Bairro} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosCreate(body: Bairro, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Bairro> {
            const localVarFetchArgs = BairrosApiFetchParamCreator(configuration).bairrosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BairrosApiFetchParamCreator(configuration).bairrosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20018> {
            const localVarFetchArgs = BairrosApiFetchParamCreator(configuration).bairrosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Bairro} body 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosPartialUpdate(body: Bairro, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Bairro> {
            const localVarFetchArgs = BairrosApiFetchParamCreator(configuration).bairrosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Bairro> {
            const localVarFetchArgs = BairrosApiFetchParamCreator(configuration).bairrosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Bairro} body 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosUpdate(body: Bairro, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Bairro> {
            const localVarFetchArgs = BairrosApiFetchParamCreator(configuration).bairrosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BairrosApi - factory interface
 * @export
 */
export const BairrosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Bairro} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosCreate(body: Bairro, options?: any) {
            return BairrosApiFp(configuration).bairrosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosDelete(id: number, options?: any) {
            return BairrosApiFp(configuration).bairrosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosList(limit?: number, offset?: number, options?: any) {
            return BairrosApiFp(configuration).bairrosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Bairro} body 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosPartialUpdate(body: Bairro, id: number, options?: any) {
            return BairrosApiFp(configuration).bairrosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosRead(id: number, options?: any) {
            return BairrosApiFp(configuration).bairrosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Bairro} body 
         * @param {number} id A unique integer value identifying this Bairro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bairrosUpdate(body: Bairro, id: number, options?: any) {
            return BairrosApiFp(configuration).bairrosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * BairrosApi - object-oriented interface
 * @export
 * @class BairrosApi
 * @extends {BaseAPI}
 */
export class BairrosApi extends BaseAPI {
    /**
     * 
     * @param {Bairro} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BairrosApi
     */
    public bairrosCreate(body: Bairro, options?: any) {
        return BairrosApiFp(this.configuration).bairrosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Bairro.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BairrosApi
     */
    public bairrosDelete(id: number, options?: any) {
        return BairrosApiFp(this.configuration).bairrosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BairrosApi
     */
    public bairrosList(limit?: number, offset?: number, options?: any) {
        return BairrosApiFp(this.configuration).bairrosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Bairro} body 
     * @param {number} id A unique integer value identifying this Bairro.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BairrosApi
     */
    public bairrosPartialUpdate(body: Bairro, id: number, options?: any) {
        return BairrosApiFp(this.configuration).bairrosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Bairro.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BairrosApi
     */
    public bairrosRead(id: number, options?: any) {
        return BairrosApiFp(this.configuration).bairrosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Bairro} body 
     * @param {number} id A unique integer value identifying this Bairro.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BairrosApi
     */
    public bairrosUpdate(body: Bairro, id: number, options?: any) {
        return BairrosApiFp(this.configuration).bairrosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CalculosDeExecucaoPenalApi - fetch parameter creator
 * @export
 */
export const CalculosDeExecucaoPenalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalCreate(body: CalculoExecucaoPenal, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling calculosDeExecucaoPenalCreate.');
            }
            const localVarPath = `/calculos-de-execucao-penal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CalculoExecucaoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling calculosDeExecucaoPenalDelete.');
            }
            const localVarPath = `/calculos-de-execucao-penal/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/calculos-de-execucao-penal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalPartialUpdate(body: CalculoExecucaoPenal, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling calculosDeExecucaoPenalPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling calculosDeExecucaoPenalPartialUpdate.');
            }
            const localVarPath = `/calculos-de-execucao-penal/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CalculoExecucaoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling calculosDeExecucaoPenalRead.');
            }
            const localVarPath = `/calculos-de-execucao-penal/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalUpdate(body: CalculoExecucaoPenal, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling calculosDeExecucaoPenalUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling calculosDeExecucaoPenalUpdate.');
            }
            const localVarPath = `/calculos-de-execucao-penal/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CalculoExecucaoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalculosDeExecucaoPenalApi - functional programming interface
 * @export
 */
export const CalculosDeExecucaoPenalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalCreate(body: CalculoExecucaoPenal, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CalculoExecucaoPenal> {
            const localVarFetchArgs = CalculosDeExecucaoPenalApiFetchParamCreator(configuration).calculosDeExecucaoPenalCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CalculosDeExecucaoPenalApiFetchParamCreator(configuration).calculosDeExecucaoPenalDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20019> {
            const localVarFetchArgs = CalculosDeExecucaoPenalApiFetchParamCreator(configuration).calculosDeExecucaoPenalList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalPartialUpdate(body: CalculoExecucaoPenal, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CalculoExecucaoPenal> {
            const localVarFetchArgs = CalculosDeExecucaoPenalApiFetchParamCreator(configuration).calculosDeExecucaoPenalPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CalculoExecucaoPenal> {
            const localVarFetchArgs = CalculosDeExecucaoPenalApiFetchParamCreator(configuration).calculosDeExecucaoPenalRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalUpdate(body: CalculoExecucaoPenal, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CalculoExecucaoPenal> {
            const localVarFetchArgs = CalculosDeExecucaoPenalApiFetchParamCreator(configuration).calculosDeExecucaoPenalUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CalculosDeExecucaoPenalApi - factory interface
 * @export
 */
export const CalculosDeExecucaoPenalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalCreate(body: CalculoExecucaoPenal, options?: any) {
            return CalculosDeExecucaoPenalApiFp(configuration).calculosDeExecucaoPenalCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalDelete(id: number, options?: any) {
            return CalculosDeExecucaoPenalApiFp(configuration).calculosDeExecucaoPenalDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalList(limit?: number, offset?: number, options?: any) {
            return CalculosDeExecucaoPenalApiFp(configuration).calculosDeExecucaoPenalList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalPartialUpdate(body: CalculoExecucaoPenal, id: number, options?: any) {
            return CalculosDeExecucaoPenalApiFp(configuration).calculosDeExecucaoPenalPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalRead(id: number, options?: any) {
            return CalculosDeExecucaoPenalApiFp(configuration).calculosDeExecucaoPenalRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CalculoExecucaoPenal} body 
         * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculosDeExecucaoPenalUpdate(body: CalculoExecucaoPenal, id: number, options?: any) {
            return CalculosDeExecucaoPenalApiFp(configuration).calculosDeExecucaoPenalUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CalculosDeExecucaoPenalApi - object-oriented interface
 * @export
 * @class CalculosDeExecucaoPenalApi
 * @extends {BaseAPI}
 */
export class CalculosDeExecucaoPenalApi extends BaseAPI {
    /**
     * 
     * @param {CalculoExecucaoPenal} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalculosDeExecucaoPenalApi
     */
    public calculosDeExecucaoPenalCreate(body: CalculoExecucaoPenal, options?: any) {
        return CalculosDeExecucaoPenalApiFp(this.configuration).calculosDeExecucaoPenalCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalculosDeExecucaoPenalApi
     */
    public calculosDeExecucaoPenalDelete(id: number, options?: any) {
        return CalculosDeExecucaoPenalApiFp(this.configuration).calculosDeExecucaoPenalDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalculosDeExecucaoPenalApi
     */
    public calculosDeExecucaoPenalList(limit?: number, offset?: number, options?: any) {
        return CalculosDeExecucaoPenalApiFp(this.configuration).calculosDeExecucaoPenalList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CalculoExecucaoPenal} body 
     * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalculosDeExecucaoPenalApi
     */
    public calculosDeExecucaoPenalPartialUpdate(body: CalculoExecucaoPenal, id: number, options?: any) {
        return CalculosDeExecucaoPenalApiFp(this.configuration).calculosDeExecucaoPenalPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalculosDeExecucaoPenalApi
     */
    public calculosDeExecucaoPenalRead(id: number, options?: any) {
        return CalculosDeExecucaoPenalApiFp(this.configuration).calculosDeExecucaoPenalRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CalculoExecucaoPenal} body 
     * @param {number} id A unique integer value identifying this Cálculo de Execução Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalculosDeExecucaoPenalApi
     */
    public calculosDeExecucaoPenalUpdate(body: CalculoExecucaoPenal, id: number, options?: any) {
        return CalculosDeExecucaoPenalApiFp(this.configuration).calculosDeExecucaoPenalUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CargosApi - fetch parameter creator
 * @export
 */
export const CargosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Cargo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosCreate(body: Cargo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cargosCreate.');
            }
            const localVarPath = `/cargos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cargo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cargosDelete.');
            }
            const localVarPath = `/cargos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/cargos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Cargo} body 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosPartialUpdate(body: Cargo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cargosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cargosPartialUpdate.');
            }
            const localVarPath = `/cargos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cargo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cargosRead.');
            }
            const localVarPath = `/cargos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Cargo} body 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosUpdate(body: Cargo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cargosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cargosUpdate.');
            }
            const localVarPath = `/cargos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cargo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CargosApi - functional programming interface
 * @export
 */
export const CargosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Cargo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosCreate(body: Cargo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cargo> {
            const localVarFetchArgs = CargosApiFetchParamCreator(configuration).cargosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CargosApiFetchParamCreator(configuration).cargosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = CargosApiFetchParamCreator(configuration).cargosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Cargo} body 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosPartialUpdate(body: Cargo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cargo> {
            const localVarFetchArgs = CargosApiFetchParamCreator(configuration).cargosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cargo> {
            const localVarFetchArgs = CargosApiFetchParamCreator(configuration).cargosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Cargo} body 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosUpdate(body: Cargo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cargo> {
            const localVarFetchArgs = CargosApiFetchParamCreator(configuration).cargosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CargosApi - factory interface
 * @export
 */
export const CargosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Cargo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosCreate(body: Cargo, options?: any) {
            return CargosApiFp(configuration).cargosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosDelete(id: number, options?: any) {
            return CargosApiFp(configuration).cargosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosList(limit?: number, offset?: number, options?: any) {
            return CargosApiFp(configuration).cargosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Cargo} body 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosPartialUpdate(body: Cargo, id: number, options?: any) {
            return CargosApiFp(configuration).cargosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosRead(id: number, options?: any) {
            return CargosApiFp(configuration).cargosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Cargo} body 
         * @param {number} id A unique integer value identifying this cargo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cargosUpdate(body: Cargo, id: number, options?: any) {
            return CargosApiFp(configuration).cargosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CargosApi - object-oriented interface
 * @export
 * @class CargosApi
 * @extends {BaseAPI}
 */
export class CargosApi extends BaseAPI {
    /**
     * 
     * @param {Cargo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CargosApi
     */
    public cargosCreate(body: Cargo, options?: any) {
        return CargosApiFp(this.configuration).cargosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cargo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CargosApi
     */
    public cargosDelete(id: number, options?: any) {
        return CargosApiFp(this.configuration).cargosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CargosApi
     */
    public cargosList(limit?: number, offset?: number, options?: any) {
        return CargosApiFp(this.configuration).cargosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Cargo} body 
     * @param {number} id A unique integer value identifying this cargo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CargosApi
     */
    public cargosPartialUpdate(body: Cargo, id: number, options?: any) {
        return CargosApiFp(this.configuration).cargosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cargo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CargosApi
     */
    public cargosRead(id: number, options?: any) {
        return CargosApiFp(this.configuration).cargosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Cargo} body 
     * @param {number} id A unique integer value identifying this cargo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CargosApi
     */
    public cargosUpdate(body: Cargo, id: number, options?: any) {
        return CargosApiFp(this.configuration).cargosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CategoriasDeAgendaApi - fetch parameter creator
 * @export
 */
export const CategoriasDeAgendaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaCreate(body: CategoriaDeAgenda, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling categoriasDeAgendaCreate.');
            }
            const localVarPath = `/categorias-de-agenda/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoriaDeAgenda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriasDeAgendaDelete.');
            }
            const localVarPath = `/categorias-de-agenda/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/categorias-de-agenda/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaPartialUpdate(body: CategoriaDeAgenda, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling categoriasDeAgendaPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriasDeAgendaPartialUpdate.');
            }
            const localVarPath = `/categorias-de-agenda/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoriaDeAgenda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriasDeAgendaRead.');
            }
            const localVarPath = `/categorias-de-agenda/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaUpdate(body: CategoriaDeAgenda, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling categoriasDeAgendaUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriasDeAgendaUpdate.');
            }
            const localVarPath = `/categorias-de-agenda/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoriaDeAgenda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriasDeAgendaApi - functional programming interface
 * @export
 */
export const CategoriasDeAgendaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaCreate(body: CategoriaDeAgenda, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoriaDeAgenda> {
            const localVarFetchArgs = CategoriasDeAgendaApiFetchParamCreator(configuration).categoriasDeAgendaCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CategoriasDeAgendaApiFetchParamCreator(configuration).categoriasDeAgendaDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20021> {
            const localVarFetchArgs = CategoriasDeAgendaApiFetchParamCreator(configuration).categoriasDeAgendaList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaPartialUpdate(body: CategoriaDeAgenda, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoriaDeAgenda> {
            const localVarFetchArgs = CategoriasDeAgendaApiFetchParamCreator(configuration).categoriasDeAgendaPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoriaDeAgenda> {
            const localVarFetchArgs = CategoriasDeAgendaApiFetchParamCreator(configuration).categoriasDeAgendaRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaUpdate(body: CategoriaDeAgenda, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoriaDeAgenda> {
            const localVarFetchArgs = CategoriasDeAgendaApiFetchParamCreator(configuration).categoriasDeAgendaUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CategoriasDeAgendaApi - factory interface
 * @export
 */
export const CategoriasDeAgendaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaCreate(body: CategoriaDeAgenda, options?: any) {
            return CategoriasDeAgendaApiFp(configuration).categoriasDeAgendaCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaDelete(id: number, options?: any) {
            return CategoriasDeAgendaApiFp(configuration).categoriasDeAgendaDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaList(limit?: number, offset?: number, options?: any) {
            return CategoriasDeAgendaApiFp(configuration).categoriasDeAgendaList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaPartialUpdate(body: CategoriaDeAgenda, id: number, options?: any) {
            return CategoriasDeAgendaApiFp(configuration).categoriasDeAgendaPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaRead(id: number, options?: any) {
            return CategoriasDeAgendaApiFp(configuration).categoriasDeAgendaRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CategoriaDeAgenda} body 
         * @param {number} id A unique integer value identifying this categoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriasDeAgendaUpdate(body: CategoriaDeAgenda, id: number, options?: any) {
            return CategoriasDeAgendaApiFp(configuration).categoriasDeAgendaUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CategoriasDeAgendaApi - object-oriented interface
 * @export
 * @class CategoriasDeAgendaApi
 * @extends {BaseAPI}
 */
export class CategoriasDeAgendaApi extends BaseAPI {
    /**
     * 
     * @param {CategoriaDeAgenda} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriasDeAgendaApi
     */
    public categoriasDeAgendaCreate(body: CategoriaDeAgenda, options?: any) {
        return CategoriasDeAgendaApiFp(this.configuration).categoriasDeAgendaCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this categoria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriasDeAgendaApi
     */
    public categoriasDeAgendaDelete(id: number, options?: any) {
        return CategoriasDeAgendaApiFp(this.configuration).categoriasDeAgendaDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriasDeAgendaApi
     */
    public categoriasDeAgendaList(limit?: number, offset?: number, options?: any) {
        return CategoriasDeAgendaApiFp(this.configuration).categoriasDeAgendaList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CategoriaDeAgenda} body 
     * @param {number} id A unique integer value identifying this categoria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriasDeAgendaApi
     */
    public categoriasDeAgendaPartialUpdate(body: CategoriaDeAgenda, id: number, options?: any) {
        return CategoriasDeAgendaApiFp(this.configuration).categoriasDeAgendaPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this categoria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriasDeAgendaApi
     */
    public categoriasDeAgendaRead(id: number, options?: any) {
        return CategoriasDeAgendaApiFp(this.configuration).categoriasDeAgendaRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CategoriaDeAgenda} body 
     * @param {number} id A unique integer value identifying this categoria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriasDeAgendaApi
     */
    public categoriasDeAgendaUpdate(body: CategoriaDeAgenda, id: number, options?: any) {
        return CategoriasDeAgendaApiFp(this.configuration).categoriasDeAgendaUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CepsApi - fetch parameter creator
 * @export
 */
export const CepsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CEP} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsCreate(body: CEP, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cepsCreate.');
            }
            const localVarPath = `/ceps/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CEP" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cepsDelete.');
            }
            const localVarPath = `/ceps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ceps/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CEP} body 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsPartialUpdate(body: CEP, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cepsPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cepsPartialUpdate.');
            }
            const localVarPath = `/ceps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CEP" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cepsRead.');
            }
            const localVarPath = `/ceps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CEP} body 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsUpdate(body: CEP, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cepsUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cepsUpdate.');
            }
            const localVarPath = `/ceps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CEP" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CepsApi - functional programming interface
 * @export
 */
export const CepsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CEP} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsCreate(body: CEP, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CEP> {
            const localVarFetchArgs = CepsApiFetchParamCreator(configuration).cepsCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CepsApiFetchParamCreator(configuration).cepsDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20022> {
            const localVarFetchArgs = CepsApiFetchParamCreator(configuration).cepsList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CEP} body 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsPartialUpdate(body: CEP, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CEP> {
            const localVarFetchArgs = CepsApiFetchParamCreator(configuration).cepsPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CEP> {
            const localVarFetchArgs = CepsApiFetchParamCreator(configuration).cepsRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CEP} body 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsUpdate(body: CEP, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CEP> {
            const localVarFetchArgs = CepsApiFetchParamCreator(configuration).cepsUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CepsApi - factory interface
 * @export
 */
export const CepsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CEP} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsCreate(body: CEP, options?: any) {
            return CepsApiFp(configuration).cepsCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsDelete(id: number, options?: any) {
            return CepsApiFp(configuration).cepsDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsList(limit?: number, offset?: number, options?: any) {
            return CepsApiFp(configuration).cepsList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CEP} body 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsPartialUpdate(body: CEP, id: number, options?: any) {
            return CepsApiFp(configuration).cepsPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsRead(id: number, options?: any) {
            return CepsApiFp(configuration).cepsRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CEP} body 
         * @param {number} id A unique integer value identifying this CEP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cepsUpdate(body: CEP, id: number, options?: any) {
            return CepsApiFp(configuration).cepsUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CepsApi - object-oriented interface
 * @export
 * @class CepsApi
 * @extends {BaseAPI}
 */
export class CepsApi extends BaseAPI {
    /**
     * 
     * @param {CEP} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CepsApi
     */
    public cepsCreate(body: CEP, options?: any) {
        return CepsApiFp(this.configuration).cepsCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this CEP.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CepsApi
     */
    public cepsDelete(id: number, options?: any) {
        return CepsApiFp(this.configuration).cepsDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CepsApi
     */
    public cepsList(limit?: number, offset?: number, options?: any) {
        return CepsApiFp(this.configuration).cepsList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CEP} body 
     * @param {number} id A unique integer value identifying this CEP.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CepsApi
     */
    public cepsPartialUpdate(body: CEP, id: number, options?: any) {
        return CepsApiFp(this.configuration).cepsPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this CEP.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CepsApi
     */
    public cepsRead(id: number, options?: any) {
        return CepsApiFp(this.configuration).cepsRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CEP} body 
     * @param {number} id A unique integer value identifying this CEP.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CepsApi
     */
    public cepsUpdate(body: CEP, id: number, options?: any) {
        return CepsApiFp(this.configuration).cepsUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ComarcasApi - fetch parameter creator
 * @export
 */
export const ComarcasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Comarca} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasCreate(body: Comarca, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling comarcasCreate.');
            }
            const localVarPath = `/comarcas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Comarca" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling comarcasDelete.');
            }
            const localVarPath = `/comarcas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [eh_coordenadoria] 
         * @param {string} [ativo] 
         * @param {string} [incluir_filhos] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasList(eh_coordenadoria?: string, ativo?: string, incluir_filhos?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/comarcas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (eh_coordenadoria !== undefined) {
                localVarQueryParameter['eh_coordenadoria'] = eh_coordenadoria;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (incluir_filhos !== undefined) {
                localVarQueryParameter['incluir_filhos'] = incluir_filhos;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Comarca} body 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasPartialUpdate(body: Comarca, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling comarcasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling comarcasPartialUpdate.');
            }
            const localVarPath = `/comarcas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Comarca" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling comarcasRead.');
            }
            const localVarPath = `/comarcas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Comarca} body 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasUpdate(body: Comarca, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling comarcasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling comarcasUpdate.');
            }
            const localVarPath = `/comarcas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Comarca" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComarcasApi - functional programming interface
 * @export
 */
export const ComarcasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Comarca} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasCreate(body: Comarca, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comarca> {
            const localVarFetchArgs = ComarcasApiFetchParamCreator(configuration).comarcasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ComarcasApiFetchParamCreator(configuration).comarcasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [eh_coordenadoria] 
         * @param {string} [ativo] 
         * @param {string} [incluir_filhos] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasList(eh_coordenadoria?: string, ativo?: string, incluir_filhos?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20023> {
            const localVarFetchArgs = ComarcasApiFetchParamCreator(configuration).comarcasList(eh_coordenadoria, ativo, incluir_filhos, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Comarca} body 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasPartialUpdate(body: Comarca, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comarca> {
            const localVarFetchArgs = ComarcasApiFetchParamCreator(configuration).comarcasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comarca> {
            const localVarFetchArgs = ComarcasApiFetchParamCreator(configuration).comarcasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Comarca} body 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasUpdate(body: Comarca, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comarca> {
            const localVarFetchArgs = ComarcasApiFetchParamCreator(configuration).comarcasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ComarcasApi - factory interface
 * @export
 */
export const ComarcasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Comarca} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasCreate(body: Comarca, options?: any) {
            return ComarcasApiFp(configuration).comarcasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasDelete(id: number, options?: any) {
            return ComarcasApiFp(configuration).comarcasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [eh_coordenadoria] 
         * @param {string} [ativo] 
         * @param {string} [incluir_filhos] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasList(eh_coordenadoria?: string, ativo?: string, incluir_filhos?: string, limit?: number, offset?: number, options?: any) {
            return ComarcasApiFp(configuration).comarcasList(eh_coordenadoria, ativo, incluir_filhos, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Comarca} body 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasPartialUpdate(body: Comarca, id: number, options?: any) {
            return ComarcasApiFp(configuration).comarcasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasRead(id: number, options?: any) {
            return ComarcasApiFp(configuration).comarcasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Comarca} body 
         * @param {number} id A unique integer value identifying this Comarca.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comarcasUpdate(body: Comarca, id: number, options?: any) {
            return ComarcasApiFp(configuration).comarcasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ComarcasApi - object-oriented interface
 * @export
 * @class ComarcasApi
 * @extends {BaseAPI}
 */
export class ComarcasApi extends BaseAPI {
    /**
     * 
     * @param {Comarca} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComarcasApi
     */
    public comarcasCreate(body: Comarca, options?: any) {
        return ComarcasApiFp(this.configuration).comarcasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Comarca.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComarcasApi
     */
    public comarcasDelete(id: number, options?: any) {
        return ComarcasApiFp(this.configuration).comarcasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [eh_coordenadoria] 
     * @param {string} [ativo] 
     * @param {string} [incluir_filhos] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComarcasApi
     */
    public comarcasList(eh_coordenadoria?: string, ativo?: string, incluir_filhos?: string, limit?: number, offset?: number, options?: any) {
        return ComarcasApiFp(this.configuration).comarcasList(eh_coordenadoria, ativo, incluir_filhos, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Comarca} body 
     * @param {number} id A unique integer value identifying this Comarca.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComarcasApi
     */
    public comarcasPartialUpdate(body: Comarca, id: number, options?: any) {
        return ComarcasApiFp(this.configuration).comarcasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Comarca.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComarcasApi
     */
    public comarcasRead(id: number, options?: any) {
        return ComarcasApiFp(this.configuration).comarcasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Comarca} body 
     * @param {number} id A unique integer value identifying this Comarca.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComarcasApi
     */
    public comarcasUpdate(body: Comarca, id: number, options?: any) {
        return ComarcasApiFp(this.configuration).comarcasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CompetenciasApi - fetch parameter creator
 * @export
 */
export const CompetenciasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasCreate(body: SistemaWebService, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling competenciasCreate.');
            }
            const localVarPath = `/competencias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SistemaWebService" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling competenciasDelete.');
            }
            const localVarPath = `/competencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/competencias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasPartialUpdate(body: SistemaWebService, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling competenciasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling competenciasPartialUpdate.');
            }
            const localVarPath = `/competencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SistemaWebService" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling competenciasRead.');
            }
            const localVarPath = `/competencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasUpdate(body: SistemaWebService, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling competenciasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling competenciasUpdate.');
            }
            const localVarPath = `/competencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SistemaWebService" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompetenciasApi - functional programming interface
 * @export
 */
export const CompetenciasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasCreate(body: SistemaWebService, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SistemaWebService> {
            const localVarFetchArgs = CompetenciasApiFetchParamCreator(configuration).competenciasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CompetenciasApiFetchParamCreator(configuration).competenciasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = CompetenciasApiFetchParamCreator(configuration).competenciasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasPartialUpdate(body: SistemaWebService, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SistemaWebService> {
            const localVarFetchArgs = CompetenciasApiFetchParamCreator(configuration).competenciasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SistemaWebService> {
            const localVarFetchArgs = CompetenciasApiFetchParamCreator(configuration).competenciasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasUpdate(body: SistemaWebService, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SistemaWebService> {
            const localVarFetchArgs = CompetenciasApiFetchParamCreator(configuration).competenciasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompetenciasApi - factory interface
 * @export
 */
export const CompetenciasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasCreate(body: SistemaWebService, options?: any) {
            return CompetenciasApiFp(configuration).competenciasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasDelete(id: number, options?: any) {
            return CompetenciasApiFp(configuration).competenciasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasList(limit?: number, offset?: number, options?: any) {
            return CompetenciasApiFp(configuration).competenciasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasPartialUpdate(body: SistemaWebService, id: number, options?: any) {
            return CompetenciasApiFp(configuration).competenciasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasRead(id: number, options?: any) {
            return CompetenciasApiFp(configuration).competenciasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Competência ProcAPI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        competenciasUpdate(body: SistemaWebService, id: number, options?: any) {
            return CompetenciasApiFp(configuration).competenciasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CompetenciasApi - object-oriented interface
 * @export
 * @class CompetenciasApi
 * @extends {BaseAPI}
 */
export class CompetenciasApi extends BaseAPI {
    /**
     * 
     * @param {SistemaWebService} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetenciasApi
     */
    public competenciasCreate(body: SistemaWebService, options?: any) {
        return CompetenciasApiFp(this.configuration).competenciasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Competência ProcAPI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetenciasApi
     */
    public competenciasDelete(id: number, options?: any) {
        return CompetenciasApiFp(this.configuration).competenciasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetenciasApi
     */
    public competenciasList(limit?: number, offset?: number, options?: any) {
        return CompetenciasApiFp(this.configuration).competenciasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SistemaWebService} body 
     * @param {number} id A unique integer value identifying this Competência ProcAPI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetenciasApi
     */
    public competenciasPartialUpdate(body: SistemaWebService, id: number, options?: any) {
        return CompetenciasApiFp(this.configuration).competenciasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Competência ProcAPI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetenciasApi
     */
    public competenciasRead(id: number, options?: any) {
        return CompetenciasApiFp(this.configuration).competenciasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SistemaWebService} body 
     * @param {number} id A unique integer value identifying this Competência ProcAPI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompetenciasApi
     */
    public competenciasUpdate(body: SistemaWebService, id: number, options?: any) {
        return CompetenciasApiFp(this.configuration).competenciasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ContribDocumentosApi - fetch parameter creator
 * @export
 */
export const ContribDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosCreate(body: ContribDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contribDocumentosCreate.');
            }
            const localVarPath = `/contrib-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contribDocumentosDelete.');
            }
            const localVarPath = `/contrib-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/contrib-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosPartialUpdate(body: ContribDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contribDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contribDocumentosPartialUpdate.');
            }
            const localVarPath = `/contrib-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contribDocumentosRead.');
            }
            const localVarPath = `/contrib-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosUpdate(body: ContribDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contribDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contribDocumentosUpdate.');
            }
            const localVarPath = `/contrib-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContribDocumentosApi - functional programming interface
 * @export
 */
export const ContribDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosCreate(body: ContribDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribDocumento> {
            const localVarFetchArgs = ContribDocumentosApiFetchParamCreator(configuration).contribDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContribDocumentosApiFetchParamCreator(configuration).contribDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = ContribDocumentosApiFetchParamCreator(configuration).contribDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosPartialUpdate(body: ContribDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribDocumento> {
            const localVarFetchArgs = ContribDocumentosApiFetchParamCreator(configuration).contribDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribDocumento> {
            const localVarFetchArgs = ContribDocumentosApiFetchParamCreator(configuration).contribDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosUpdate(body: ContribDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribDocumento> {
            const localVarFetchArgs = ContribDocumentosApiFetchParamCreator(configuration).contribDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContribDocumentosApi - factory interface
 * @export
 */
export const ContribDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosCreate(body: ContribDocumento, options?: any) {
            return ContribDocumentosApiFp(configuration).contribDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosDelete(id: number, options?: any) {
            return ContribDocumentosApiFp(configuration).contribDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosList(limit?: number, offset?: number, options?: any) {
            return ContribDocumentosApiFp(configuration).contribDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosPartialUpdate(body: ContribDocumento, id: number, options?: any) {
            return ContribDocumentosApiFp(configuration).contribDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosRead(id: number, options?: any) {
            return ContribDocumentosApiFp(configuration).contribDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ContribDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contribDocumentosUpdate(body: ContribDocumento, id: number, options?: any) {
            return ContribDocumentosApiFp(configuration).contribDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ContribDocumentosApi - object-oriented interface
 * @export
 * @class ContribDocumentosApi
 * @extends {BaseAPI}
 */
export class ContribDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {ContribDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContribDocumentosApi
     */
    public contribDocumentosCreate(body: ContribDocumento, options?: any) {
        return ContribDocumentosApiFp(this.configuration).contribDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContribDocumentosApi
     */
    public contribDocumentosDelete(id: number, options?: any) {
        return ContribDocumentosApiFp(this.configuration).contribDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContribDocumentosApi
     */
    public contribDocumentosList(limit?: number, offset?: number, options?: any) {
        return ContribDocumentosApiFp(this.configuration).contribDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ContribDocumento} body 
     * @param {number} id A unique integer value identifying this Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContribDocumentosApi
     */
    public contribDocumentosPartialUpdate(body: ContribDocumento, id: number, options?: any) {
        return ContribDocumentosApiFp(this.configuration).contribDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContribDocumentosApi
     */
    public contribDocumentosRead(id: number, options?: any) {
        return ContribDocumentosApiFp(this.configuration).contribDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ContribDocumento} body 
     * @param {number} id A unique integer value identifying this Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContribDocumentosApi
     */
    public contribDocumentosUpdate(body: ContribDocumento, id: number, options?: any) {
        return ContribDocumentosApiFp(this.configuration).contribDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CoreClassesApi - fetch parameter creator
 * @export
 */
export const CoreClassesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Classe} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesCreate(body: Classe, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreClassesCreate.');
            }
            const localVarPath = `/core-classes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Classe" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreClassesDelete.');
            }
            const localVarPath = `/core-classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/core-classes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Classe} body 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesPartialUpdate(body: Classe, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreClassesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreClassesPartialUpdate.');
            }
            const localVarPath = `/core-classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Classe" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreClassesRead.');
            }
            const localVarPath = `/core-classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Classe} body 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesUpdate(body: Classe, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreClassesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreClassesUpdate.');
            }
            const localVarPath = `/core-classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Classe" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreClassesApi - functional programming interface
 * @export
 */
export const CoreClassesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Classe} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesCreate(body: Classe, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Classe> {
            const localVarFetchArgs = CoreClassesApiFetchParamCreator(configuration).coreClassesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoreClassesApiFetchParamCreator(configuration).coreClassesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = CoreClassesApiFetchParamCreator(configuration).coreClassesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Classe} body 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesPartialUpdate(body: Classe, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Classe> {
            const localVarFetchArgs = CoreClassesApiFetchParamCreator(configuration).coreClassesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Classe> {
            const localVarFetchArgs = CoreClassesApiFetchParamCreator(configuration).coreClassesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Classe} body 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesUpdate(body: Classe, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Classe> {
            const localVarFetchArgs = CoreClassesApiFetchParamCreator(configuration).coreClassesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoreClassesApi - factory interface
 * @export
 */
export const CoreClassesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Classe} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesCreate(body: Classe, options?: any) {
            return CoreClassesApiFp(configuration).coreClassesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesDelete(id: number, options?: any) {
            return CoreClassesApiFp(configuration).coreClassesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesList(limit?: number, offset?: number, options?: any) {
            return CoreClassesApiFp(configuration).coreClassesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Classe} body 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesPartialUpdate(body: Classe, id: number, options?: any) {
            return CoreClassesApiFp(configuration).coreClassesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesRead(id: number, options?: any) {
            return CoreClassesApiFp(configuration).coreClassesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Classe} body 
         * @param {number} id A unique integer value identifying this classe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreClassesUpdate(body: Classe, id: number, options?: any) {
            return CoreClassesApiFp(configuration).coreClassesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CoreClassesApi - object-oriented interface
 * @export
 * @class CoreClassesApi
 * @extends {BaseAPI}
 */
export class CoreClassesApi extends BaseAPI {
    /**
     * 
     * @param {Classe} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClassesApi
     */
    public coreClassesCreate(body: Classe, options?: any) {
        return CoreClassesApiFp(this.configuration).coreClassesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this classe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClassesApi
     */
    public coreClassesDelete(id: number, options?: any) {
        return CoreClassesApiFp(this.configuration).coreClassesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClassesApi
     */
    public coreClassesList(limit?: number, offset?: number, options?: any) {
        return CoreClassesApiFp(this.configuration).coreClassesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Classe} body 
     * @param {number} id A unique integer value identifying this classe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClassesApi
     */
    public coreClassesPartialUpdate(body: Classe, id: number, options?: any) {
        return CoreClassesApiFp(this.configuration).coreClassesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this classe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClassesApi
     */
    public coreClassesRead(id: number, options?: any) {
        return CoreClassesApiFp(this.configuration).coreClassesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Classe} body 
     * @param {number} id A unique integer value identifying this classe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreClassesApi
     */
    public coreClassesUpdate(body: Classe, id: number, options?: any) {
        return CoreClassesApiFp(this.configuration).coreClassesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CoreDocumentosApi - fetch parameter creator
 * @export
 */
export const CoreDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosCreate(body: CoreDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreDocumentosCreate.');
            }
            const localVarPath = `/core-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreDocumentosDelete.');
            }
            const localVarPath = `/core-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/core-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosPartialUpdate(body: CoreDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreDocumentosPartialUpdate.');
            }
            const localVarPath = `/core-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreDocumentosRead.');
            }
            const localVarPath = `/core-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosUpdate(body: CoreDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreDocumentosUpdate.');
            }
            const localVarPath = `/core-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreDocumentosApi - functional programming interface
 * @export
 */
export const CoreDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosCreate(body: CoreDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreDocumento> {
            const localVarFetchArgs = CoreDocumentosApiFetchParamCreator(configuration).coreDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoreDocumentosApiFetchParamCreator(configuration).coreDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20027> {
            const localVarFetchArgs = CoreDocumentosApiFetchParamCreator(configuration).coreDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosPartialUpdate(body: CoreDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreDocumento> {
            const localVarFetchArgs = CoreDocumentosApiFetchParamCreator(configuration).coreDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreDocumento> {
            const localVarFetchArgs = CoreDocumentosApiFetchParamCreator(configuration).coreDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosUpdate(body: CoreDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreDocumento> {
            const localVarFetchArgs = CoreDocumentosApiFetchParamCreator(configuration).coreDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoreDocumentosApi - factory interface
 * @export
 */
export const CoreDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosCreate(body: CoreDocumento, options?: any) {
            return CoreDocumentosApiFp(configuration).coreDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosDelete(id: number, options?: any) {
            return CoreDocumentosApiFp(configuration).coreDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosList(limit?: number, offset?: number, options?: any) {
            return CoreDocumentosApiFp(configuration).coreDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosPartialUpdate(body: CoreDocumento, id: number, options?: any) {
            return CoreDocumentosApiFp(configuration).coreDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosRead(id: number, options?: any) {
            return CoreDocumentosApiFp(configuration).coreDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CoreDocumento} body 
         * @param {number} id A unique integer value identifying this documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreDocumentosUpdate(body: CoreDocumento, id: number, options?: any) {
            return CoreDocumentosApiFp(configuration).coreDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CoreDocumentosApi - object-oriented interface
 * @export
 * @class CoreDocumentosApi
 * @extends {BaseAPI}
 */
export class CoreDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {CoreDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreDocumentosApi
     */
    public coreDocumentosCreate(body: CoreDocumento, options?: any) {
        return CoreDocumentosApiFp(this.configuration).coreDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreDocumentosApi
     */
    public coreDocumentosDelete(id: number, options?: any) {
        return CoreDocumentosApiFp(this.configuration).coreDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreDocumentosApi
     */
    public coreDocumentosList(limit?: number, offset?: number, options?: any) {
        return CoreDocumentosApiFp(this.configuration).coreDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CoreDocumento} body 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreDocumentosApi
     */
    public coreDocumentosPartialUpdate(body: CoreDocumento, id: number, options?: any) {
        return CoreDocumentosApiFp(this.configuration).coreDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreDocumentosApi
     */
    public coreDocumentosRead(id: number, options?: any) {
        return CoreDocumentosApiFp(this.configuration).coreDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CoreDocumento} body 
     * @param {number} id A unique integer value identifying this documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreDocumentosApi
     */
    public coreDocumentosUpdate(body: CoreDocumento, id: number, options?: any) {
        return CoreDocumentosApiFp(this.configuration).coreDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CoreEventosApi - fetch parameter creator
 * @export
 */
export const CoreEventosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoreEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosCreate(body: CoreEvento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreEventosCreate.');
            }
            const localVarPath = `/core-eventos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreEventosDelete.');
            }
            const localVarPath = `/core-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/core-eventos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreEvento} body 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosPartialUpdate(body: CoreEvento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreEventosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreEventosPartialUpdate.');
            }
            const localVarPath = `/core-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreEventosRead.');
            }
            const localVarPath = `/core-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreEvento} body 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosUpdate(body: CoreEvento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreEventosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreEventosUpdate.');
            }
            const localVarPath = `/core-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreEventosApi - functional programming interface
 * @export
 */
export const CoreEventosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoreEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosCreate(body: CoreEvento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreEvento> {
            const localVarFetchArgs = CoreEventosApiFetchParamCreator(configuration).coreEventosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoreEventosApiFetchParamCreator(configuration).coreEventosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20028> {
            const localVarFetchArgs = CoreEventosApiFetchParamCreator(configuration).coreEventosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CoreEvento} body 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosPartialUpdate(body: CoreEvento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreEvento> {
            const localVarFetchArgs = CoreEventosApiFetchParamCreator(configuration).coreEventosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreEvento> {
            const localVarFetchArgs = CoreEventosApiFetchParamCreator(configuration).coreEventosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CoreEvento} body 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosUpdate(body: CoreEvento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreEvento> {
            const localVarFetchArgs = CoreEventosApiFetchParamCreator(configuration).coreEventosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoreEventosApi - factory interface
 * @export
 */
export const CoreEventosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CoreEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosCreate(body: CoreEvento, options?: any) {
            return CoreEventosApiFp(configuration).coreEventosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosDelete(id: number, options?: any) {
            return CoreEventosApiFp(configuration).coreEventosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosList(limit?: number, offset?: number, options?: any) {
            return CoreEventosApiFp(configuration).coreEventosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CoreEvento} body 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosPartialUpdate(body: CoreEvento, id: number, options?: any) {
            return CoreEventosApiFp(configuration).coreEventosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosRead(id: number, options?: any) {
            return CoreEventosApiFp(configuration).coreEventosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CoreEvento} body 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreEventosUpdate(body: CoreEvento, id: number, options?: any) {
            return CoreEventosApiFp(configuration).coreEventosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CoreEventosApi - object-oriented interface
 * @export
 * @class CoreEventosApi
 * @extends {BaseAPI}
 */
export class CoreEventosApi extends BaseAPI {
    /**
     * 
     * @param {CoreEvento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreEventosApi
     */
    public coreEventosCreate(body: CoreEvento, options?: any) {
        return CoreEventosApiFp(this.configuration).coreEventosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreEventosApi
     */
    public coreEventosDelete(id: number, options?: any) {
        return CoreEventosApiFp(this.configuration).coreEventosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreEventosApi
     */
    public coreEventosList(limit?: number, offset?: number, options?: any) {
        return CoreEventosApiFp(this.configuration).coreEventosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CoreEvento} body 
     * @param {number} id A unique integer value identifying this evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreEventosApi
     */
    public coreEventosPartialUpdate(body: CoreEvento, id: number, options?: any) {
        return CoreEventosApiFp(this.configuration).coreEventosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreEventosApi
     */
    public coreEventosRead(id: number, options?: any) {
        return CoreEventosApiFp(this.configuration).coreEventosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CoreEvento} body 
     * @param {number} id A unique integer value identifying this evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreEventosApi
     */
    public coreEventosUpdate(body: CoreEvento, id: number, options?: any) {
        return CoreEventosApiFp(this.configuration).coreEventosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CoreModelosDocumentoApi - fetch parameter creator
 * @export
 */
export const CoreModelosDocumentoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoCreate(body: CoreModeloDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreModelosDocumentoCreate.');
            }
            const localVarPath = `/core-modelos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreModeloDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreModelosDocumentoDelete.');
            }
            const localVarPath = `/core-modelos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/core-modelos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoPartialUpdate(body: CoreModeloDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreModelosDocumentoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreModelosDocumentoPartialUpdate.');
            }
            const localVarPath = `/core-modelos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreModeloDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreModelosDocumentoRead.');
            }
            const localVarPath = `/core-modelos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoUpdate(body: CoreModeloDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreModelosDocumentoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreModelosDocumentoUpdate.');
            }
            const localVarPath = `/core-modelos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreModeloDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreModelosDocumentoApi - functional programming interface
 * @export
 */
export const CoreModelosDocumentoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoCreate(body: CoreModeloDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreModeloDocumento> {
            const localVarFetchArgs = CoreModelosDocumentoApiFetchParamCreator(configuration).coreModelosDocumentoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoreModelosDocumentoApiFetchParamCreator(configuration).coreModelosDocumentoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = CoreModelosDocumentoApiFetchParamCreator(configuration).coreModelosDocumentoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoPartialUpdate(body: CoreModeloDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreModeloDocumento> {
            const localVarFetchArgs = CoreModelosDocumentoApiFetchParamCreator(configuration).coreModelosDocumentoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreModeloDocumento> {
            const localVarFetchArgs = CoreModelosDocumentoApiFetchParamCreator(configuration).coreModelosDocumentoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoUpdate(body: CoreModeloDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreModeloDocumento> {
            const localVarFetchArgs = CoreModelosDocumentoApiFetchParamCreator(configuration).coreModelosDocumentoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoreModelosDocumentoApi - factory interface
 * @export
 */
export const CoreModelosDocumentoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoCreate(body: CoreModeloDocumento, options?: any) {
            return CoreModelosDocumentoApiFp(configuration).coreModelosDocumentoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoDelete(id: number, options?: any) {
            return CoreModelosDocumentoApiFp(configuration).coreModelosDocumentoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoList(limit?: number, offset?: number, options?: any) {
            return CoreModelosDocumentoApiFp(configuration).coreModelosDocumentoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoPartialUpdate(body: CoreModeloDocumento, id: number, options?: any) {
            return CoreModelosDocumentoApiFp(configuration).coreModelosDocumentoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoRead(id: number, options?: any) {
            return CoreModelosDocumentoApiFp(configuration).coreModelosDocumentoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CoreModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreModelosDocumentoUpdate(body: CoreModeloDocumento, id: number, options?: any) {
            return CoreModelosDocumentoApiFp(configuration).coreModelosDocumentoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CoreModelosDocumentoApi - object-oriented interface
 * @export
 * @class CoreModelosDocumentoApi
 * @extends {BaseAPI}
 */
export class CoreModelosDocumentoApi extends BaseAPI {
    /**
     * 
     * @param {CoreModeloDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreModelosDocumentoApi
     */
    public coreModelosDocumentoCreate(body: CoreModeloDocumento, options?: any) {
        return CoreModelosDocumentoApiFp(this.configuration).coreModelosDocumentoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this modelo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreModelosDocumentoApi
     */
    public coreModelosDocumentoDelete(id: number, options?: any) {
        return CoreModelosDocumentoApiFp(this.configuration).coreModelosDocumentoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreModelosDocumentoApi
     */
    public coreModelosDocumentoList(limit?: number, offset?: number, options?: any) {
        return CoreModelosDocumentoApiFp(this.configuration).coreModelosDocumentoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CoreModeloDocumento} body 
     * @param {number} id A unique integer value identifying this modelo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreModelosDocumentoApi
     */
    public coreModelosDocumentoPartialUpdate(body: CoreModeloDocumento, id: number, options?: any) {
        return CoreModelosDocumentoApiFp(this.configuration).coreModelosDocumentoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this modelo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreModelosDocumentoApi
     */
    public coreModelosDocumentoRead(id: number, options?: any) {
        return CoreModelosDocumentoApiFp(this.configuration).coreModelosDocumentoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CoreModeloDocumento} body 
     * @param {number} id A unique integer value identifying this modelo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreModelosDocumentoApi
     */
    public coreModelosDocumentoUpdate(body: CoreModeloDocumento, id: number, options?: any) {
        return CoreModelosDocumentoApiFp(this.configuration).coreModelosDocumentoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CorePartesApi - fetch parameter creator
 * @export
 */
export const CorePartesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Parte} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesCreate(body: Parte, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling corePartesCreate.');
            }
            const localVarPath = `/core-partes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Parte" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling corePartesDelete.');
            }
            const localVarPath = `/core-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/core-partes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Parte} body 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesPartialUpdate(body: Parte, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling corePartesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling corePartesPartialUpdate.');
            }
            const localVarPath = `/core-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Parte" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling corePartesRead.');
            }
            const localVarPath = `/core-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Parte} body 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesUpdate(body: Parte, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling corePartesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling corePartesUpdate.');
            }
            const localVarPath = `/core-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Parte" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CorePartesApi - functional programming interface
 * @export
 */
export const CorePartesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Parte} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesCreate(body: Parte, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Parte> {
            const localVarFetchArgs = CorePartesApiFetchParamCreator(configuration).corePartesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CorePartesApiFetchParamCreator(configuration).corePartesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20030> {
            const localVarFetchArgs = CorePartesApiFetchParamCreator(configuration).corePartesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Parte} body 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesPartialUpdate(body: Parte, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Parte> {
            const localVarFetchArgs = CorePartesApiFetchParamCreator(configuration).corePartesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Parte> {
            const localVarFetchArgs = CorePartesApiFetchParamCreator(configuration).corePartesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Parte} body 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesUpdate(body: Parte, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Parte> {
            const localVarFetchArgs = CorePartesApiFetchParamCreator(configuration).corePartesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CorePartesApi - factory interface
 * @export
 */
export const CorePartesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Parte} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesCreate(body: Parte, options?: any) {
            return CorePartesApiFp(configuration).corePartesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesDelete(id: number, options?: any) {
            return CorePartesApiFp(configuration).corePartesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesList(limit?: number, offset?: number, options?: any) {
            return CorePartesApiFp(configuration).corePartesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Parte} body 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesPartialUpdate(body: Parte, id: number, options?: any) {
            return CorePartesApiFp(configuration).corePartesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesRead(id: number, options?: any) {
            return CorePartesApiFp(configuration).corePartesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Parte} body 
         * @param {number} id A unique integer value identifying this parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        corePartesUpdate(body: Parte, id: number, options?: any) {
            return CorePartesApiFp(configuration).corePartesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CorePartesApi - object-oriented interface
 * @export
 * @class CorePartesApi
 * @extends {BaseAPI}
 */
export class CorePartesApi extends BaseAPI {
    /**
     * 
     * @param {Parte} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorePartesApi
     */
    public corePartesCreate(body: Parte, options?: any) {
        return CorePartesApiFp(this.configuration).corePartesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorePartesApi
     */
    public corePartesDelete(id: number, options?: any) {
        return CorePartesApiFp(this.configuration).corePartesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorePartesApi
     */
    public corePartesList(limit?: number, offset?: number, options?: any) {
        return CorePartesApiFp(this.configuration).corePartesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Parte} body 
     * @param {number} id A unique integer value identifying this parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorePartesApi
     */
    public corePartesPartialUpdate(body: Parte, id: number, options?: any) {
        return CorePartesApiFp(this.configuration).corePartesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorePartesApi
     */
    public corePartesRead(id: number, options?: any) {
        return CorePartesApiFp(this.configuration).corePartesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Parte} body 
     * @param {number} id A unique integer value identifying this parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorePartesApi
     */
    public corePartesUpdate(body: Parte, id: number, options?: any) {
        return CorePartesApiFp(this.configuration).corePartesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CoreProcessosApi - fetch parameter creator
 * @export
 */
export const CoreProcessosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosCreate(body: CoreProcesso, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreProcessosCreate.');
            }
            const localVarPath = `/core-processos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreProcessosDelete.');
            }
            const localVarPath = `/core-processos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/core-processos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosPartialUpdate(body: CoreProcesso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreProcessosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreProcessosPartialUpdate.');
            }
            const localVarPath = `/core-processos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreProcessosRead.');
            }
            const localVarPath = `/core-processos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosUpdate(body: CoreProcesso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreProcessosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreProcessosUpdate.');
            }
            const localVarPath = `/core-processos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoreProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreProcessosApi - functional programming interface
 * @export
 */
export const CoreProcessosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosCreate(body: CoreProcesso, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreProcesso> {
            const localVarFetchArgs = CoreProcessosApiFetchParamCreator(configuration).coreProcessosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoreProcessosApiFetchParamCreator(configuration).coreProcessosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20031> {
            const localVarFetchArgs = CoreProcessosApiFetchParamCreator(configuration).coreProcessosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosPartialUpdate(body: CoreProcesso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreProcesso> {
            const localVarFetchArgs = CoreProcessosApiFetchParamCreator(configuration).coreProcessosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreProcesso> {
            const localVarFetchArgs = CoreProcessosApiFetchParamCreator(configuration).coreProcessosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosUpdate(body: CoreProcesso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreProcesso> {
            const localVarFetchArgs = CoreProcessosApiFetchParamCreator(configuration).coreProcessosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoreProcessosApi - factory interface
 * @export
 */
export const CoreProcessosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosCreate(body: CoreProcesso, options?: any) {
            return CoreProcessosApiFp(configuration).coreProcessosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosDelete(id: number, options?: any) {
            return CoreProcessosApiFp(configuration).coreProcessosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosList(limit?: number, offset?: number, options?: any) {
            return CoreProcessosApiFp(configuration).coreProcessosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosPartialUpdate(body: CoreProcesso, id: number, options?: any) {
            return CoreProcessosApiFp(configuration).coreProcessosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosRead(id: number, options?: any) {
            return CoreProcessosApiFp(configuration).coreProcessosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CoreProcesso} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreProcessosUpdate(body: CoreProcesso, id: number, options?: any) {
            return CoreProcessosApiFp(configuration).coreProcessosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CoreProcessosApi - object-oriented interface
 * @export
 * @class CoreProcessosApi
 * @extends {BaseAPI}
 */
export class CoreProcessosApi extends BaseAPI {
    /**
     * 
     * @param {CoreProcesso} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreProcessosApi
     */
    public coreProcessosCreate(body: CoreProcesso, options?: any) {
        return CoreProcessosApiFp(this.configuration).coreProcessosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreProcessosApi
     */
    public coreProcessosDelete(id: number, options?: any) {
        return CoreProcessosApiFp(this.configuration).coreProcessosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreProcessosApi
     */
    public coreProcessosList(limit?: number, offset?: number, options?: any) {
        return CoreProcessosApiFp(this.configuration).coreProcessosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CoreProcesso} body 
     * @param {number} id A unique integer value identifying this processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreProcessosApi
     */
    public coreProcessosPartialUpdate(body: CoreProcesso, id: number, options?: any) {
        return CoreProcessosApiFp(this.configuration).coreProcessosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreProcessosApi
     */
    public coreProcessosRead(id: number, options?: any) {
        return CoreProcessosApiFp(this.configuration).coreProcessosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CoreProcesso} body 
     * @param {number} id A unique integer value identifying this processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreProcessosApi
     */
    public coreProcessosUpdate(body: CoreProcesso, id: number, options?: any) {
        return CoreProcessosApiFp(this.configuration).coreProcessosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CoreTiposDocumentoApi - fetch parameter creator
 * @export
 */
export const CoreTiposDocumentoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoCreate(body: TipoDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreTiposDocumentoCreate.');
            }
            const localVarPath = `/core-tipos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreTiposDocumentoDelete.');
            }
            const localVarPath = `/core-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/core-tipos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoPartialUpdate(body: TipoDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreTiposDocumentoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreTiposDocumentoPartialUpdate.');
            }
            const localVarPath = `/core-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreTiposDocumentoRead.');
            }
            const localVarPath = `/core-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoUpdate(body: TipoDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreTiposDocumentoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreTiposDocumentoUpdate.');
            }
            const localVarPath = `/core-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreTiposDocumentoApi - functional programming interface
 * @export
 */
export const CoreTiposDocumentoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoCreate(body: TipoDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoDocumento> {
            const localVarFetchArgs = CoreTiposDocumentoApiFetchParamCreator(configuration).coreTiposDocumentoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoreTiposDocumentoApiFetchParamCreator(configuration).coreTiposDocumentoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20032> {
            const localVarFetchArgs = CoreTiposDocumentoApiFetchParamCreator(configuration).coreTiposDocumentoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoPartialUpdate(body: TipoDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoDocumento> {
            const localVarFetchArgs = CoreTiposDocumentoApiFetchParamCreator(configuration).coreTiposDocumentoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoDocumento> {
            const localVarFetchArgs = CoreTiposDocumentoApiFetchParamCreator(configuration).coreTiposDocumentoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoUpdate(body: TipoDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoDocumento> {
            const localVarFetchArgs = CoreTiposDocumentoApiFetchParamCreator(configuration).coreTiposDocumentoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoreTiposDocumentoApi - factory interface
 * @export
 */
export const CoreTiposDocumentoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoCreate(body: TipoDocumento, options?: any) {
            return CoreTiposDocumentoApiFp(configuration).coreTiposDocumentoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoDelete(id: number, options?: any) {
            return CoreTiposDocumentoApiFp(configuration).coreTiposDocumentoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoList(limit?: number, offset?: number, options?: any) {
            return CoreTiposDocumentoApiFp(configuration).coreTiposDocumentoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoPartialUpdate(body: TipoDocumento, id: number, options?: any) {
            return CoreTiposDocumentoApiFp(configuration).coreTiposDocumentoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoRead(id: number, options?: any) {
            return CoreTiposDocumentoApiFp(configuration).coreTiposDocumentoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoDocumento} body 
         * @param {number} id A unique integer value identifying this tipo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposDocumentoUpdate(body: TipoDocumento, id: number, options?: any) {
            return CoreTiposDocumentoApiFp(configuration).coreTiposDocumentoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CoreTiposDocumentoApi - object-oriented interface
 * @export
 * @class CoreTiposDocumentoApi
 * @extends {BaseAPI}
 */
export class CoreTiposDocumentoApi extends BaseAPI {
    /**
     * 
     * @param {TipoDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposDocumentoApi
     */
    public coreTiposDocumentoCreate(body: TipoDocumento, options?: any) {
        return CoreTiposDocumentoApiFp(this.configuration).coreTiposDocumentoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this tipo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposDocumentoApi
     */
    public coreTiposDocumentoDelete(id: number, options?: any) {
        return CoreTiposDocumentoApiFp(this.configuration).coreTiposDocumentoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposDocumentoApi
     */
    public coreTiposDocumentoList(limit?: number, offset?: number, options?: any) {
        return CoreTiposDocumentoApiFp(this.configuration).coreTiposDocumentoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoDocumento} body 
     * @param {number} id A unique integer value identifying this tipo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposDocumentoApi
     */
    public coreTiposDocumentoPartialUpdate(body: TipoDocumento, id: number, options?: any) {
        return CoreTiposDocumentoApiFp(this.configuration).coreTiposDocumentoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this tipo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposDocumentoApi
     */
    public coreTiposDocumentoRead(id: number, options?: any) {
        return CoreTiposDocumentoApiFp(this.configuration).coreTiposDocumentoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoDocumento} body 
     * @param {number} id A unique integer value identifying this tipo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposDocumentoApi
     */
    public coreTiposDocumentoUpdate(body: TipoDocumento, id: number, options?: any) {
        return CoreTiposDocumentoApiFp(this.configuration).coreTiposDocumentoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * CoreTiposEventoApi - fetch parameter creator
 * @export
 */
export const CoreTiposEventoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoCreate(body: TipoEvento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreTiposEventoCreate.');
            }
            const localVarPath = `/core-tipos-evento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreTiposEventoDelete.');
            }
            const localVarPath = `/core-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [tipo_processo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoList(tipo?: string, tipo_processo?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/core-tipos-evento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (tipo !== undefined) {
                localVarQueryParameter['tipo'] = tipo;
            }

            if (tipo_processo !== undefined) {
                localVarQueryParameter['tipo_processo'] = tipo_processo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoEvento} body 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoPartialUpdate(body: TipoEvento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreTiposEventoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreTiposEventoPartialUpdate.');
            }
            const localVarPath = `/core-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreTiposEventoRead.');
            }
            const localVarPath = `/core-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoEvento} body 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoUpdate(body: TipoEvento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling coreTiposEventoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coreTiposEventoUpdate.');
            }
            const localVarPath = `/core-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreTiposEventoApi - functional programming interface
 * @export
 */
export const CoreTiposEventoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoCreate(body: TipoEvento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoEvento> {
            const localVarFetchArgs = CoreTiposEventoApiFetchParamCreator(configuration).coreTiposEventoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoreTiposEventoApiFetchParamCreator(configuration).coreTiposEventoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [tipo_processo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoList(tipo?: string, tipo_processo?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20033> {
            const localVarFetchArgs = CoreTiposEventoApiFetchParamCreator(configuration).coreTiposEventoList(tipo, tipo_processo, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoEvento} body 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoPartialUpdate(body: TipoEvento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoEvento> {
            const localVarFetchArgs = CoreTiposEventoApiFetchParamCreator(configuration).coreTiposEventoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoEvento> {
            const localVarFetchArgs = CoreTiposEventoApiFetchParamCreator(configuration).coreTiposEventoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoEvento} body 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoUpdate(body: TipoEvento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoEvento> {
            const localVarFetchArgs = CoreTiposEventoApiFetchParamCreator(configuration).coreTiposEventoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoreTiposEventoApi - factory interface
 * @export
 */
export const CoreTiposEventoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TipoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoCreate(body: TipoEvento, options?: any) {
            return CoreTiposEventoApiFp(configuration).coreTiposEventoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoDelete(id: number, options?: any) {
            return CoreTiposEventoApiFp(configuration).coreTiposEventoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [tipo_processo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoList(tipo?: string, tipo_processo?: string, limit?: number, offset?: number, options?: any) {
            return CoreTiposEventoApiFp(configuration).coreTiposEventoList(tipo, tipo_processo, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoEvento} body 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoPartialUpdate(body: TipoEvento, id: number, options?: any) {
            return CoreTiposEventoApiFp(configuration).coreTiposEventoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoRead(id: number, options?: any) {
            return CoreTiposEventoApiFp(configuration).coreTiposEventoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoEvento} body 
         * @param {number} id A unique integer value identifying this tipo evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreTiposEventoUpdate(body: TipoEvento, id: number, options?: any) {
            return CoreTiposEventoApiFp(configuration).coreTiposEventoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * CoreTiposEventoApi - object-oriented interface
 * @export
 * @class CoreTiposEventoApi
 * @extends {BaseAPI}
 */
export class CoreTiposEventoApi extends BaseAPI {
    /**
     * 
     * @param {TipoEvento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposEventoApi
     */
    public coreTiposEventoCreate(body: TipoEvento, options?: any) {
        return CoreTiposEventoApiFp(this.configuration).coreTiposEventoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this tipo evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposEventoApi
     */
    public coreTiposEventoDelete(id: number, options?: any) {
        return CoreTiposEventoApiFp(this.configuration).coreTiposEventoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [tipo] 
     * @param {string} [tipo_processo] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposEventoApi
     */
    public coreTiposEventoList(tipo?: string, tipo_processo?: string, limit?: number, offset?: number, options?: any) {
        return CoreTiposEventoApiFp(this.configuration).coreTiposEventoList(tipo, tipo_processo, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoEvento} body 
     * @param {number} id A unique integer value identifying this tipo evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposEventoApi
     */
    public coreTiposEventoPartialUpdate(body: TipoEvento, id: number, options?: any) {
        return CoreTiposEventoApiFp(this.configuration).coreTiposEventoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this tipo evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposEventoApi
     */
    public coreTiposEventoRead(id: number, options?: any) {
        return CoreTiposEventoApiFp(this.configuration).coreTiposEventoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoEvento} body 
     * @param {number} id A unique integer value identifying this tipo evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreTiposEventoApi
     */
    public coreTiposEventoUpdate(body: TipoEvento, id: number, options?: any) {
        return CoreTiposEventoApiFp(this.configuration).coreTiposEventoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * DefensoresApi - fetch parameter creator
 * @export
 */
export const DefensoresApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Defensor} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresCreate(body: Defensor, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoresCreate.');
            }
            const localVarPath = `/defensores/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Defensor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoresDelete.');
            }
            const localVarPath = `/defensores/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [servidor] 
         * @param {string} [incluir_atuacoes] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresList(servidor?: string, incluir_atuacoes?: string, ativo?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/defensores/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (servidor !== undefined) {
                localVarQueryParameter['servidor'] = servidor;
            }

            if (incluir_atuacoes !== undefined) {
                localVarQueryParameter['incluir_atuacoes'] = incluir_atuacoes;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Defensor} body 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresPartialUpdate(body: Defensor, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoresPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoresPartialUpdate.');
            }
            const localVarPath = `/defensores/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Defensor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoresRead.');
            }
            const localVarPath = `/defensores/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Defensor} body 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresUpdate(body: Defensor, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoresUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoresUpdate.');
            }
            const localVarPath = `/defensores/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Defensor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefensoresApi - functional programming interface
 * @export
 */
export const DefensoresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Defensor} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresCreate(body: Defensor, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Defensor> {
            const localVarFetchArgs = DefensoresApiFetchParamCreator(configuration).defensoresCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefensoresApiFetchParamCreator(configuration).defensoresDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [servidor] 
         * @param {string} [incluir_atuacoes] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresList(servidor?: string, incluir_atuacoes?: string, ativo?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20034> {
            const localVarFetchArgs = DefensoresApiFetchParamCreator(configuration).defensoresList(servidor, incluir_atuacoes, ativo, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Defensor} body 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresPartialUpdate(body: Defensor, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Defensor> {
            const localVarFetchArgs = DefensoresApiFetchParamCreator(configuration).defensoresPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Defensor> {
            const localVarFetchArgs = DefensoresApiFetchParamCreator(configuration).defensoresRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Defensor} body 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresUpdate(body: Defensor, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Defensor> {
            const localVarFetchArgs = DefensoresApiFetchParamCreator(configuration).defensoresUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefensoresApi - factory interface
 * @export
 */
export const DefensoresApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Defensor} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresCreate(body: Defensor, options?: any) {
            return DefensoresApiFp(configuration).defensoresCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresDelete(id: number, options?: any) {
            return DefensoresApiFp(configuration).defensoresDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [servidor] 
         * @param {string} [incluir_atuacoes] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresList(servidor?: string, incluir_atuacoes?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
            return DefensoresApiFp(configuration).defensoresList(servidor, incluir_atuacoes, ativo, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Defensor} body 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresPartialUpdate(body: Defensor, id: number, options?: any) {
            return DefensoresApiFp(configuration).defensoresPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresRead(id: number, options?: any) {
            return DefensoresApiFp(configuration).defensoresRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Defensor} body 
         * @param {number} id A unique integer value identifying this Defensor/Assessor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoresUpdate(body: Defensor, id: number, options?: any) {
            return DefensoresApiFp(configuration).defensoresUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * DefensoresApi - object-oriented interface
 * @export
 * @class DefensoresApi
 * @extends {BaseAPI}
 */
export class DefensoresApi extends BaseAPI {
    /**
     * 
     * @param {Defensor} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoresApi
     */
    public defensoresCreate(body: Defensor, options?: any) {
        return DefensoresApiFp(this.configuration).defensoresCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Defensor/Assessor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoresApi
     */
    public defensoresDelete(id: number, options?: any) {
        return DefensoresApiFp(this.configuration).defensoresDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [servidor] 
     * @param {string} [incluir_atuacoes] 
     * @param {string} [ativo] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoresApi
     */
    public defensoresList(servidor?: string, incluir_atuacoes?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
        return DefensoresApiFp(this.configuration).defensoresList(servidor, incluir_atuacoes, ativo, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Defensor} body 
     * @param {number} id A unique integer value identifying this Defensor/Assessor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoresApi
     */
    public defensoresPartialUpdate(body: Defensor, id: number, options?: any) {
        return DefensoresApiFp(this.configuration).defensoresPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Defensor/Assessor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoresApi
     */
    public defensoresRead(id: number, options?: any) {
        return DefensoresApiFp(this.configuration).defensoresRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Defensor} body 
     * @param {number} id A unique integer value identifying this Defensor/Assessor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoresApi
     */
    public defensoresUpdate(body: Defensor, id: number, options?: any) {
        return DefensoresApiFp(this.configuration).defensoresUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * DefensoriasApi - fetch parameter creator
 * @export
 */
export const DefensoriasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Defensoria} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasCreate(body: Defensoria, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasCreate.');
            }
            const localVarPath = `/defensorias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Defensoria" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasDelete.');
            }
            const localVarPath = `/defensorias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [nome] 
         * @param {number} [numero] 
         * @param {string} [comarca] 
         * @param {string} [eh_itinerante] 
         * @param {string} [incluir_atuacoes] 
         * @param {string} [incluir_categorias] 
         * @param {string} [ativo] 
         * @param {string} [defensor] 
         * @param {string} [serializer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasList(nome?: string, numero?: number, comarca?: string, eh_itinerante?: string, incluir_atuacoes?: string, incluir_categorias?: string, ativo?: string, defensor?: string, serializer?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/defensorias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (nome !== undefined) {
                localVarQueryParameter['nome'] = nome;
            }

            if (numero !== undefined) {
                localVarQueryParameter['numero'] = numero;
            }

            if (comarca !== undefined) {
                localVarQueryParameter['comarca'] = comarca;
            }

            if (eh_itinerante !== undefined) {
                localVarQueryParameter['eh_itinerante'] = eh_itinerante;
            }

            if (incluir_atuacoes !== undefined) {
                localVarQueryParameter['incluir_atuacoes'] = incluir_atuacoes;
            }

            if (incluir_categorias !== undefined) {
                localVarQueryParameter['incluir_categorias'] = incluir_categorias;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (defensor !== undefined) {
                localVarQueryParameter['defensor'] = defensor;
            }

            if (serializer !== undefined) {
                localVarQueryParameter['serializer'] = serializer;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Defensoria} body 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasPartialUpdate(body: Defensoria, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasPartialUpdate.');
            }
            const localVarPath = `/defensorias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Defensoria" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasRead.');
            }
            const localVarPath = `/defensorias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Defensoria} body 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasUpdate(body: Defensoria, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasUpdate.');
            }
            const localVarPath = `/defensorias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Defensoria" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefensoriasApi - functional programming interface
 * @export
 */
export const DefensoriasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Defensoria} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasCreate(body: Defensoria, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Defensoria> {
            const localVarFetchArgs = DefensoriasApiFetchParamCreator(configuration).defensoriasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefensoriasApiFetchParamCreator(configuration).defensoriasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [nome] 
         * @param {number} [numero] 
         * @param {string} [comarca] 
         * @param {string} [eh_itinerante] 
         * @param {string} [incluir_atuacoes] 
         * @param {string} [incluir_categorias] 
         * @param {string} [ativo] 
         * @param {string} [defensor] 
         * @param {string} [serializer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasList(nome?: string, numero?: number, comarca?: string, eh_itinerante?: string, incluir_atuacoes?: string, incluir_categorias?: string, ativo?: string, defensor?: string, serializer?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20037> {
            const localVarFetchArgs = DefensoriasApiFetchParamCreator(configuration).defensoriasList(nome, numero, comarca, eh_itinerante, incluir_atuacoes, incluir_categorias, ativo, defensor, serializer, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Defensoria} body 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasPartialUpdate(body: Defensoria, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Defensoria> {
            const localVarFetchArgs = DefensoriasApiFetchParamCreator(configuration).defensoriasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Defensoria> {
            const localVarFetchArgs = DefensoriasApiFetchParamCreator(configuration).defensoriasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Defensoria} body 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasUpdate(body: Defensoria, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Defensoria> {
            const localVarFetchArgs = DefensoriasApiFetchParamCreator(configuration).defensoriasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefensoriasApi - factory interface
 * @export
 */
export const DefensoriasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Defensoria} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasCreate(body: Defensoria, options?: any) {
            return DefensoriasApiFp(configuration).defensoriasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasDelete(id: number, options?: any) {
            return DefensoriasApiFp(configuration).defensoriasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [nome] 
         * @param {number} [numero] 
         * @param {string} [comarca] 
         * @param {string} [eh_itinerante] 
         * @param {string} [incluir_atuacoes] 
         * @param {string} [incluir_categorias] 
         * @param {string} [ativo] 
         * @param {string} [defensor] 
         * @param {string} [serializer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasList(nome?: string, numero?: number, comarca?: string, eh_itinerante?: string, incluir_atuacoes?: string, incluir_categorias?: string, ativo?: string, defensor?: string, serializer?: string, limit?: number, offset?: number, options?: any) {
            return DefensoriasApiFp(configuration).defensoriasList(nome, numero, comarca, eh_itinerante, incluir_atuacoes, incluir_categorias, ativo, defensor, serializer, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Defensoria} body 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasPartialUpdate(body: Defensoria, id: number, options?: any) {
            return DefensoriasApiFp(configuration).defensoriasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasRead(id: number, options?: any) {
            return DefensoriasApiFp(configuration).defensoriasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Defensoria} body 
         * @param {number} id A unique integer value identifying this Defensoria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasUpdate(body: Defensoria, id: number, options?: any) {
            return DefensoriasApiFp(configuration).defensoriasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * DefensoriasApi - object-oriented interface
 * @export
 * @class DefensoriasApi
 * @extends {BaseAPI}
 */
export class DefensoriasApi extends BaseAPI {
    /**
     * 
     * @param {Defensoria} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasApi
     */
    public defensoriasCreate(body: Defensoria, options?: any) {
        return DefensoriasApiFp(this.configuration).defensoriasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Defensoria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasApi
     */
    public defensoriasDelete(id: number, options?: any) {
        return DefensoriasApiFp(this.configuration).defensoriasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [nome] 
     * @param {number} [numero] 
     * @param {string} [comarca] 
     * @param {string} [eh_itinerante] 
     * @param {string} [incluir_atuacoes] 
     * @param {string} [incluir_categorias] 
     * @param {string} [ativo] 
     * @param {string} [defensor] 
     * @param {string} [serializer] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasApi
     */
    public defensoriasList(nome?: string, numero?: number, comarca?: string, eh_itinerante?: string, incluir_atuacoes?: string, incluir_categorias?: string, ativo?: string, defensor?: string, serializer?: string, limit?: number, offset?: number, options?: any) {
        return DefensoriasApiFp(this.configuration).defensoriasList(nome, numero, comarca, eh_itinerante, incluir_atuacoes, incluir_categorias, ativo, defensor, serializer, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Defensoria} body 
     * @param {number} id A unique integer value identifying this Defensoria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasApi
     */
    public defensoriasPartialUpdate(body: Defensoria, id: number, options?: any) {
        return DefensoriasApiFp(this.configuration).defensoriasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Defensoria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasApi
     */
    public defensoriasRead(id: number, options?: any) {
        return DefensoriasApiFp(this.configuration).defensoriasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Defensoria} body 
     * @param {number} id A unique integer value identifying this Defensoria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasApi
     */
    public defensoriasUpdate(body: Defensoria, id: number, options?: any) {
        return DefensoriasApiFp(this.configuration).defensoriasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * DefensoriasTiposEventoApi - fetch parameter creator
 * @export
 */
export const DefensoriasTiposEventoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoCreate(body: DefensoriaTipoEvento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasTiposEventoCreate.');
            }
            const localVarPath = `/defensorias-tipos-evento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensoriaTipoEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasTiposEventoDelete.');
            }
            const localVarPath = `/defensorias-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [defensoria] Valores múltiplos podem ser separados por vírgulas.
         * @param {string} [tipo_evento] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoList(defensoria?: number, tipo_evento?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/defensorias-tipos-evento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (defensoria !== undefined) {
                localVarQueryParameter['defensoria'] = defensoria;
            }

            if (tipo_evento !== undefined) {
                localVarQueryParameter['tipo_evento'] = tipo_evento;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoPartialUpdate(body: DefensoriaTipoEvento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasTiposEventoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasTiposEventoPartialUpdate.');
            }
            const localVarPath = `/defensorias-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensoriaTipoEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasTiposEventoRead.');
            }
            const localVarPath = `/defensorias-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoUpdate(body: DefensoriaTipoEvento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasTiposEventoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasTiposEventoUpdate.');
            }
            const localVarPath = `/defensorias-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensoriaTipoEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefensoriasTiposEventoApi - functional programming interface
 * @export
 */
export const DefensoriasTiposEventoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoCreate(body: DefensoriaTipoEvento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaTipoEvento> {
            const localVarFetchArgs = DefensoriasTiposEventoApiFetchParamCreator(configuration).defensoriasTiposEventoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefensoriasTiposEventoApiFetchParamCreator(configuration).defensoriasTiposEventoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [defensoria] Valores múltiplos podem ser separados por vírgulas.
         * @param {string} [tipo_evento] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoList(defensoria?: number, tipo_evento?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20035> {
            const localVarFetchArgs = DefensoriasTiposEventoApiFetchParamCreator(configuration).defensoriasTiposEventoList(defensoria, tipo_evento, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoPartialUpdate(body: DefensoriaTipoEvento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaTipoEvento> {
            const localVarFetchArgs = DefensoriasTiposEventoApiFetchParamCreator(configuration).defensoriasTiposEventoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaTipoEvento> {
            const localVarFetchArgs = DefensoriasTiposEventoApiFetchParamCreator(configuration).defensoriasTiposEventoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoUpdate(body: DefensoriaTipoEvento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaTipoEvento> {
            const localVarFetchArgs = DefensoriasTiposEventoApiFetchParamCreator(configuration).defensoriasTiposEventoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefensoriasTiposEventoApi - factory interface
 * @export
 */
export const DefensoriasTiposEventoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoCreate(body: DefensoriaTipoEvento, options?: any) {
            return DefensoriasTiposEventoApiFp(configuration).defensoriasTiposEventoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoDelete(id: number, options?: any) {
            return DefensoriasTiposEventoApiFp(configuration).defensoriasTiposEventoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [defensoria] Valores múltiplos podem ser separados por vírgulas.
         * @param {string} [tipo_evento] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoList(defensoria?: number, tipo_evento?: string, limit?: number, offset?: number, options?: any) {
            return DefensoriasTiposEventoApiFp(configuration).defensoriasTiposEventoList(defensoria, tipo_evento, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoPartialUpdate(body: DefensoriaTipoEvento, id: number, options?: any) {
            return DefensoriasTiposEventoApiFp(configuration).defensoriasTiposEventoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoRead(id: number, options?: any) {
            return DefensoriasTiposEventoApiFp(configuration).defensoriasTiposEventoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DefensoriaTipoEvento} body 
         * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasTiposEventoUpdate(body: DefensoriaTipoEvento, id: number, options?: any) {
            return DefensoriasTiposEventoApiFp(configuration).defensoriasTiposEventoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * DefensoriasTiposEventoApi - object-oriented interface
 * @export
 * @class DefensoriasTiposEventoApi
 * @extends {BaseAPI}
 */
export class DefensoriasTiposEventoApi extends BaseAPI {
    /**
     * 
     * @param {DefensoriaTipoEvento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasTiposEventoApi
     */
    public defensoriasTiposEventoCreate(body: DefensoriaTipoEvento, options?: any) {
        return DefensoriasTiposEventoApiFp(this.configuration).defensoriasTiposEventoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasTiposEventoApi
     */
    public defensoriasTiposEventoDelete(id: number, options?: any) {
        return DefensoriasTiposEventoApiFp(this.configuration).defensoriasTiposEventoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [defensoria] Valores múltiplos podem ser separados por vírgulas.
     * @param {string} [tipo_evento] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasTiposEventoApi
     */
    public defensoriasTiposEventoList(defensoria?: number, tipo_evento?: string, limit?: number, offset?: number, options?: any) {
        return DefensoriasTiposEventoApiFp(this.configuration).defensoriasTiposEventoList(defensoria, tipo_evento, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DefensoriaTipoEvento} body 
     * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasTiposEventoApi
     */
    public defensoriasTiposEventoPartialUpdate(body: DefensoriaTipoEvento, id: number, options?: any) {
        return DefensoriasTiposEventoApiFp(this.configuration).defensoriasTiposEventoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasTiposEventoApi
     */
    public defensoriasTiposEventoRead(id: number, options?: any) {
        return DefensoriasTiposEventoApiFp(this.configuration).defensoriasTiposEventoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DefensoriaTipoEvento} body 
     * @param {number} id A unique integer value identifying this Defensoria / Tipos de Evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasTiposEventoApi
     */
    public defensoriasTiposEventoUpdate(body: DefensoriaTipoEvento, id: number, options?: any) {
        return DefensoriasTiposEventoApiFp(this.configuration).defensoriasTiposEventoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * DefensoriasVarasApi - fetch parameter creator
 * @export
 */
export const DefensoriasVarasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasCreate(body: DefensoriaVaraCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasVarasCreate.');
            }
            const localVarPath = `/defensorias-varas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensoriaVaraCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasVarasDelete.');
            }
            const localVarPath = `/defensorias-varas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [defensoria] 
         * @param {string} [vara] 
         * @param {string} [paridade] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasList(defensoria?: string, vara?: string, paridade?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/defensorias-varas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (defensoria !== undefined) {
                localVarQueryParameter['defensoria'] = defensoria;
            }

            if (vara !== undefined) {
                localVarQueryParameter['vara'] = vara;
            }

            if (paridade !== undefined) {
                localVarQueryParameter['paridade'] = paridade;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasPartialUpdate(body: DefensoriaVaraCreate, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasVarasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasVarasPartialUpdate.');
            }
            const localVarPath = `/defensorias-varas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensoriaVaraCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasVarasRead.');
            }
            const localVarPath = `/defensorias-varas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasUpdate(body: DefensoriaVaraCreate, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defensoriasVarasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defensoriasVarasUpdate.');
            }
            const localVarPath = `/defensorias-varas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefensoriaVaraCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefensoriasVarasApi - functional programming interface
 * @export
 */
export const DefensoriasVarasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasCreate(body: DefensoriaVaraCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaVaraCreate> {
            const localVarFetchArgs = DefensoriasVarasApiFetchParamCreator(configuration).defensoriasVarasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaVaraCreate> {
            const localVarFetchArgs = DefensoriasVarasApiFetchParamCreator(configuration).defensoriasVarasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [defensoria] 
         * @param {string} [vara] 
         * @param {string} [paridade] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasList(defensoria?: string, vara?: string, paridade?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20036> {
            const localVarFetchArgs = DefensoriasVarasApiFetchParamCreator(configuration).defensoriasVarasList(defensoria, vara, paridade, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasPartialUpdate(body: DefensoriaVaraCreate, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaVaraCreate> {
            const localVarFetchArgs = DefensoriasVarasApiFetchParamCreator(configuration).defensoriasVarasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaVara> {
            const localVarFetchArgs = DefensoriasVarasApiFetchParamCreator(configuration).defensoriasVarasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasUpdate(body: DefensoriaVaraCreate, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefensoriaVaraCreate> {
            const localVarFetchArgs = DefensoriasVarasApiFetchParamCreator(configuration).defensoriasVarasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefensoriasVarasApi - factory interface
 * @export
 */
export const DefensoriasVarasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasCreate(body: DefensoriaVaraCreate, options?: any) {
            return DefensoriasVarasApiFp(configuration).defensoriasVarasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasDelete(id: number, options?: any) {
            return DefensoriasVarasApiFp(configuration).defensoriasVarasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [defensoria] 
         * @param {string} [vara] 
         * @param {string} [paridade] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasList(defensoria?: string, vara?: string, paridade?: string, limit?: number, offset?: number, options?: any) {
            return DefensoriasVarasApiFp(configuration).defensoriasVarasList(defensoria, vara, paridade, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasPartialUpdate(body: DefensoriaVaraCreate, id: number, options?: any) {
            return DefensoriasVarasApiFp(configuration).defensoriasVarasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasRead(id: number, options?: any) {
            return DefensoriasVarasApiFp(configuration).defensoriasVarasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DefensoriaVaraCreate} body 
         * @param {number} id A unique integer value identifying this Defensoria / Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defensoriasVarasUpdate(body: DefensoriaVaraCreate, id: number, options?: any) {
            return DefensoriasVarasApiFp(configuration).defensoriasVarasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * DefensoriasVarasApi - object-oriented interface
 * @export
 * @class DefensoriasVarasApi
 * @extends {BaseAPI}
 */
export class DefensoriasVarasApi extends BaseAPI {
    /**
     * 
     * @param {DefensoriaVaraCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasVarasApi
     */
    public defensoriasVarasCreate(body: DefensoriaVaraCreate, options?: any) {
        return DefensoriasVarasApiFp(this.configuration).defensoriasVarasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Defensoria / Vara.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasVarasApi
     */
    public defensoriasVarasDelete(id: number, options?: any) {
        return DefensoriasVarasApiFp(this.configuration).defensoriasVarasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [defensoria] 
     * @param {string} [vara] 
     * @param {string} [paridade] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasVarasApi
     */
    public defensoriasVarasList(defensoria?: string, vara?: string, paridade?: string, limit?: number, offset?: number, options?: any) {
        return DefensoriasVarasApiFp(this.configuration).defensoriasVarasList(defensoria, vara, paridade, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DefensoriaVaraCreate} body 
     * @param {number} id A unique integer value identifying this Defensoria / Vara.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasVarasApi
     */
    public defensoriasVarasPartialUpdate(body: DefensoriaVaraCreate, id: number, options?: any) {
        return DefensoriasVarasApiFp(this.configuration).defensoriasVarasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Defensoria / Vara.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasVarasApi
     */
    public defensoriasVarasRead(id: number, options?: any) {
        return DefensoriasVarasApiFp(this.configuration).defensoriasVarasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DefensoriaVaraCreate} body 
     * @param {number} id A unique integer value identifying this Defensoria / Vara.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensoriasVarasApi
     */
    public defensoriasVarasUpdate(body: DefensoriaVaraCreate, id: number, options?: any) {
        return DefensoriasVarasApiFp(this.configuration).defensoriasVarasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * DeficienciasApi - fetch parameter creator
 * @export
 */
export const DeficienciasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Deficiencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasCreate(body: Deficiencia, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deficienciasCreate.');
            }
            const localVarPath = `/deficiencias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Deficiencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deficienciasDelete.');
            }
            const localVarPath = `/deficiencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/deficiencias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Deficiencia} body 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasPartialUpdate(body: Deficiencia, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deficienciasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deficienciasPartialUpdate.');
            }
            const localVarPath = `/deficiencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Deficiencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deficienciasRead.');
            }
            const localVarPath = `/deficiencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Deficiencia} body 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasUpdate(body: Deficiencia, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deficienciasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deficienciasUpdate.');
            }
            const localVarPath = `/deficiencias/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Deficiencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeficienciasApi - functional programming interface
 * @export
 */
export const DeficienciasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Deficiencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasCreate(body: Deficiencia, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Deficiencia> {
            const localVarFetchArgs = DeficienciasApiFetchParamCreator(configuration).deficienciasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeficienciasApiFetchParamCreator(configuration).deficienciasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20038> {
            const localVarFetchArgs = DeficienciasApiFetchParamCreator(configuration).deficienciasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Deficiencia} body 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasPartialUpdate(body: Deficiencia, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Deficiencia> {
            const localVarFetchArgs = DeficienciasApiFetchParamCreator(configuration).deficienciasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Deficiencia> {
            const localVarFetchArgs = DeficienciasApiFetchParamCreator(configuration).deficienciasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Deficiencia} body 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasUpdate(body: Deficiencia, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Deficiencia> {
            const localVarFetchArgs = DeficienciasApiFetchParamCreator(configuration).deficienciasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeficienciasApi - factory interface
 * @export
 */
export const DeficienciasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Deficiencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasCreate(body: Deficiencia, options?: any) {
            return DeficienciasApiFp(configuration).deficienciasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasDelete(id: number, options?: any) {
            return DeficienciasApiFp(configuration).deficienciasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasList(limit?: number, offset?: number, options?: any) {
            return DeficienciasApiFp(configuration).deficienciasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Deficiencia} body 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasPartialUpdate(body: Deficiencia, id: number, options?: any) {
            return DeficienciasApiFp(configuration).deficienciasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasRead(id: number, options?: any) {
            return DeficienciasApiFp(configuration).deficienciasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Deficiencia} body 
         * @param {number} id A unique integer value identifying this Deficiência.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deficienciasUpdate(body: Deficiencia, id: number, options?: any) {
            return DeficienciasApiFp(configuration).deficienciasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * DeficienciasApi - object-oriented interface
 * @export
 * @class DeficienciasApi
 * @extends {BaseAPI}
 */
export class DeficienciasApi extends BaseAPI {
    /**
     * 
     * @param {Deficiencia} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeficienciasApi
     */
    public deficienciasCreate(body: Deficiencia, options?: any) {
        return DeficienciasApiFp(this.configuration).deficienciasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Deficiência.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeficienciasApi
     */
    public deficienciasDelete(id: number, options?: any) {
        return DeficienciasApiFp(this.configuration).deficienciasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeficienciasApi
     */
    public deficienciasList(limit?: number, offset?: number, options?: any) {
        return DeficienciasApiFp(this.configuration).deficienciasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Deficiencia} body 
     * @param {number} id A unique integer value identifying this Deficiência.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeficienciasApi
     */
    public deficienciasPartialUpdate(body: Deficiencia, id: number, options?: any) {
        return DeficienciasApiFp(this.configuration).deficienciasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Deficiência.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeficienciasApi
     */
    public deficienciasRead(id: number, options?: any) {
        return DeficienciasApiFp(this.configuration).deficienciasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Deficiencia} body 
     * @param {number} id A unique integer value identifying this Deficiência.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeficienciasApi
     */
    public deficienciasUpdate(body: Deficiencia, id: number, options?: any) {
        return DeficienciasApiFp(this.configuration).deficienciasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * DependentesApi - fetch parameter creator
 * @export
 */
export const DependentesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Dependente} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesCreate(body: Dependente, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dependentesCreate.');
            }
            const localVarPath = `/dependentes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dependente" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling dependentesDelete.');
            }
            const localVarPath = `/dependentes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/dependentes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Dependente} body 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesPartialUpdate(body: Dependente, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dependentesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling dependentesPartialUpdate.');
            }
            const localVarPath = `/dependentes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dependente" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling dependentesRead.');
            }
            const localVarPath = `/dependentes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Dependente} body 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesUpdate(body: Dependente, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dependentesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling dependentesUpdate.');
            }
            const localVarPath = `/dependentes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dependente" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DependentesApi - functional programming interface
 * @export
 */
export const DependentesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Dependente} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesCreate(body: Dependente, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Dependente> {
            const localVarFetchArgs = DependentesApiFetchParamCreator(configuration).dependentesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DependentesApiFetchParamCreator(configuration).dependentesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20039> {
            const localVarFetchArgs = DependentesApiFetchParamCreator(configuration).dependentesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Dependente} body 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesPartialUpdate(body: Dependente, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Dependente> {
            const localVarFetchArgs = DependentesApiFetchParamCreator(configuration).dependentesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Dependente> {
            const localVarFetchArgs = DependentesApiFetchParamCreator(configuration).dependentesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Dependente} body 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesUpdate(body: Dependente, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Dependente> {
            const localVarFetchArgs = DependentesApiFetchParamCreator(configuration).dependentesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DependentesApi - factory interface
 * @export
 */
export const DependentesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Dependente} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesCreate(body: Dependente, options?: any) {
            return DependentesApiFp(configuration).dependentesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesDelete(id: number, options?: any) {
            return DependentesApiFp(configuration).dependentesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesList(limit?: number, offset?: number, options?: any) {
            return DependentesApiFp(configuration).dependentesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Dependente} body 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesPartialUpdate(body: Dependente, id: number, options?: any) {
            return DependentesApiFp(configuration).dependentesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesRead(id: number, options?: any) {
            return DependentesApiFp(configuration).dependentesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Dependente} body 
         * @param {number} id A unique integer value identifying this dependente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dependentesUpdate(body: Dependente, id: number, options?: any) {
            return DependentesApiFp(configuration).dependentesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * DependentesApi - object-oriented interface
 * @export
 * @class DependentesApi
 * @extends {BaseAPI}
 */
export class DependentesApi extends BaseAPI {
    /**
     * 
     * @param {Dependente} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependentesApi
     */
    public dependentesCreate(body: Dependente, options?: any) {
        return DependentesApiFp(this.configuration).dependentesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this dependente.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependentesApi
     */
    public dependentesDelete(id: number, options?: any) {
        return DependentesApiFp(this.configuration).dependentesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependentesApi
     */
    public dependentesList(limit?: number, offset?: number, options?: any) {
        return DependentesApiFp(this.configuration).dependentesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Dependente} body 
     * @param {number} id A unique integer value identifying this dependente.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependentesApi
     */
    public dependentesPartialUpdate(body: Dependente, id: number, options?: any) {
        return DependentesApiFp(this.configuration).dependentesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this dependente.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependentesApi
     */
    public dependentesRead(id: number, options?: any) {
        return DependentesApiFp(this.configuration).dependentesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Dependente} body 
     * @param {number} id A unique integer value identifying this dependente.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependentesApi
     */
    public dependentesUpdate(body: Dependente, id: number, options?: any) {
        return DependentesApiFp(this.configuration).dependentesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EditaisConcorrenciaPlantaoApi - fetch parameter creator
 * @export
 */
export const EditaisConcorrenciaPlantaoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoCreate(body: EditalConcorrenciaPlantao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling editaisConcorrenciaPlantaoCreate.');
            }
            const localVarPath = `/editais-concorrencia-plantao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EditalConcorrenciaPlantao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editaisConcorrenciaPlantaoDelete.');
            }
            const localVarPath = `/editais-concorrencia-plantao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/editais-concorrencia-plantao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoPartialUpdate(body: EditalConcorrenciaPlantao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling editaisConcorrenciaPlantaoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editaisConcorrenciaPlantaoPartialUpdate.');
            }
            const localVarPath = `/editais-concorrencia-plantao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EditalConcorrenciaPlantao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editaisConcorrenciaPlantaoRead.');
            }
            const localVarPath = `/editais-concorrencia-plantao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoUpdate(body: EditalConcorrenciaPlantao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling editaisConcorrenciaPlantaoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editaisConcorrenciaPlantaoUpdate.');
            }
            const localVarPath = `/editais-concorrencia-plantao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EditalConcorrenciaPlantao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EditaisConcorrenciaPlantaoApi - functional programming interface
 * @export
 */
export const EditaisConcorrenciaPlantaoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoCreate(body: EditalConcorrenciaPlantao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EditalConcorrenciaPlantao> {
            const localVarFetchArgs = EditaisConcorrenciaPlantaoApiFetchParamCreator(configuration).editaisConcorrenciaPlantaoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EditaisConcorrenciaPlantaoApiFetchParamCreator(configuration).editaisConcorrenciaPlantaoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20040> {
            const localVarFetchArgs = EditaisConcorrenciaPlantaoApiFetchParamCreator(configuration).editaisConcorrenciaPlantaoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoPartialUpdate(body: EditalConcorrenciaPlantao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EditalConcorrenciaPlantao> {
            const localVarFetchArgs = EditaisConcorrenciaPlantaoApiFetchParamCreator(configuration).editaisConcorrenciaPlantaoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EditalConcorrenciaPlantao> {
            const localVarFetchArgs = EditaisConcorrenciaPlantaoApiFetchParamCreator(configuration).editaisConcorrenciaPlantaoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoUpdate(body: EditalConcorrenciaPlantao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EditalConcorrenciaPlantao> {
            const localVarFetchArgs = EditaisConcorrenciaPlantaoApiFetchParamCreator(configuration).editaisConcorrenciaPlantaoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EditaisConcorrenciaPlantaoApi - factory interface
 * @export
 */
export const EditaisConcorrenciaPlantaoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoCreate(body: EditalConcorrenciaPlantao, options?: any) {
            return EditaisConcorrenciaPlantaoApiFp(configuration).editaisConcorrenciaPlantaoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoDelete(id: number, options?: any) {
            return EditaisConcorrenciaPlantaoApiFp(configuration).editaisConcorrenciaPlantaoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoList(limit?: number, offset?: number, options?: any) {
            return EditaisConcorrenciaPlantaoApiFp(configuration).editaisConcorrenciaPlantaoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoPartialUpdate(body: EditalConcorrenciaPlantao, id: number, options?: any) {
            return EditaisConcorrenciaPlantaoApiFp(configuration).editaisConcorrenciaPlantaoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoRead(id: number, options?: any) {
            return EditaisConcorrenciaPlantaoApiFp(configuration).editaisConcorrenciaPlantaoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EditalConcorrenciaPlantao} body 
         * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editaisConcorrenciaPlantaoUpdate(body: EditalConcorrenciaPlantao, id: number, options?: any) {
            return EditaisConcorrenciaPlantaoApiFp(configuration).editaisConcorrenciaPlantaoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EditaisConcorrenciaPlantaoApi - object-oriented interface
 * @export
 * @class EditaisConcorrenciaPlantaoApi
 * @extends {BaseAPI}
 */
export class EditaisConcorrenciaPlantaoApi extends BaseAPI {
    /**
     * 
     * @param {EditalConcorrenciaPlantao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditaisConcorrenciaPlantaoApi
     */
    public editaisConcorrenciaPlantaoCreate(body: EditalConcorrenciaPlantao, options?: any) {
        return EditaisConcorrenciaPlantaoApiFp(this.configuration).editaisConcorrenciaPlantaoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditaisConcorrenciaPlantaoApi
     */
    public editaisConcorrenciaPlantaoDelete(id: number, options?: any) {
        return EditaisConcorrenciaPlantaoApiFp(this.configuration).editaisConcorrenciaPlantaoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditaisConcorrenciaPlantaoApi
     */
    public editaisConcorrenciaPlantaoList(limit?: number, offset?: number, options?: any) {
        return EditaisConcorrenciaPlantaoApiFp(this.configuration).editaisConcorrenciaPlantaoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EditalConcorrenciaPlantao} body 
     * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditaisConcorrenciaPlantaoApi
     */
    public editaisConcorrenciaPlantaoPartialUpdate(body: EditalConcorrenciaPlantao, id: number, options?: any) {
        return EditaisConcorrenciaPlantaoApiFp(this.configuration).editaisConcorrenciaPlantaoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditaisConcorrenciaPlantaoApi
     */
    public editaisConcorrenciaPlantaoRead(id: number, options?: any) {
        return EditaisConcorrenciaPlantaoApiFp(this.configuration).editaisConcorrenciaPlantaoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EditalConcorrenciaPlantao} body 
     * @param {number} id A unique integer value identifying this Edital de Concorrência à Plantão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditaisConcorrenciaPlantaoApi
     */
    public editaisConcorrenciaPlantaoUpdate(body: EditalConcorrenciaPlantao, id: number, options?: any) {
        return EditaisConcorrenciaPlantaoApiFp(this.configuration).editaisConcorrenciaPlantaoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EncaminhamentosApi - fetch parameter creator
 * @export
 */
export const EncaminhamentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosCreate(body: Encaminhamento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling encaminhamentosCreate.');
            }
            const localVarPath = `/encaminhamentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Encaminhamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling encaminhamentosDelete.');
            }
            const localVarPath = `/encaminhamentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/encaminhamentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosPartialUpdate(body: Encaminhamento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling encaminhamentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling encaminhamentosPartialUpdate.');
            }
            const localVarPath = `/encaminhamentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Encaminhamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling encaminhamentosRead.');
            }
            const localVarPath = `/encaminhamentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosUpdate(body: Encaminhamento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling encaminhamentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling encaminhamentosUpdate.');
            }
            const localVarPath = `/encaminhamentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Encaminhamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EncaminhamentosApi - functional programming interface
 * @export
 */
export const EncaminhamentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosCreate(body: Encaminhamento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Encaminhamento> {
            const localVarFetchArgs = EncaminhamentosApiFetchParamCreator(configuration).encaminhamentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EncaminhamentosApiFetchParamCreator(configuration).encaminhamentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20041> {
            const localVarFetchArgs = EncaminhamentosApiFetchParamCreator(configuration).encaminhamentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosPartialUpdate(body: Encaminhamento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Encaminhamento> {
            const localVarFetchArgs = EncaminhamentosApiFetchParamCreator(configuration).encaminhamentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Encaminhamento> {
            const localVarFetchArgs = EncaminhamentosApiFetchParamCreator(configuration).encaminhamentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosUpdate(body: Encaminhamento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Encaminhamento> {
            const localVarFetchArgs = EncaminhamentosApiFetchParamCreator(configuration).encaminhamentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EncaminhamentosApi - factory interface
 * @export
 */
export const EncaminhamentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosCreate(body: Encaminhamento, options?: any) {
            return EncaminhamentosApiFp(configuration).encaminhamentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosDelete(id: number, options?: any) {
            return EncaminhamentosApiFp(configuration).encaminhamentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosList(limit?: number, offset?: number, options?: any) {
            return EncaminhamentosApiFp(configuration).encaminhamentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosPartialUpdate(body: Encaminhamento, id: number, options?: any) {
            return EncaminhamentosApiFp(configuration).encaminhamentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosRead(id: number, options?: any) {
            return EncaminhamentosApiFp(configuration).encaminhamentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Encaminhamento} body 
         * @param {number} id A unique integer value identifying this encaminhamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encaminhamentosUpdate(body: Encaminhamento, id: number, options?: any) {
            return EncaminhamentosApiFp(configuration).encaminhamentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EncaminhamentosApi - object-oriented interface
 * @export
 * @class EncaminhamentosApi
 * @extends {BaseAPI}
 */
export class EncaminhamentosApi extends BaseAPI {
    /**
     * 
     * @param {Encaminhamento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncaminhamentosApi
     */
    public encaminhamentosCreate(body: Encaminhamento, options?: any) {
        return EncaminhamentosApiFp(this.configuration).encaminhamentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this encaminhamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncaminhamentosApi
     */
    public encaminhamentosDelete(id: number, options?: any) {
        return EncaminhamentosApiFp(this.configuration).encaminhamentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncaminhamentosApi
     */
    public encaminhamentosList(limit?: number, offset?: number, options?: any) {
        return EncaminhamentosApiFp(this.configuration).encaminhamentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Encaminhamento} body 
     * @param {number} id A unique integer value identifying this encaminhamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncaminhamentosApi
     */
    public encaminhamentosPartialUpdate(body: Encaminhamento, id: number, options?: any) {
        return EncaminhamentosApiFp(this.configuration).encaminhamentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this encaminhamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncaminhamentosApi
     */
    public encaminhamentosRead(id: number, options?: any) {
        return EncaminhamentosApiFp(this.configuration).encaminhamentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Encaminhamento} body 
     * @param {number} id A unique integer value identifying this encaminhamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncaminhamentosApi
     */
    public encaminhamentosUpdate(body: Encaminhamento, id: number, options?: any) {
        return EncaminhamentosApiFp(this.configuration).encaminhamentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EnderecoHistoricosApi - fetch parameter creator
 * @export
 */
export const EnderecoHistoricosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosCreate(body: EnderecoHistorico, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling enderecoHistoricosCreate.');
            }
            const localVarPath = `/endereco-historicos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EnderecoHistorico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enderecoHistoricosDelete.');
            }
            const localVarPath = `/endereco-historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/endereco-historicos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosPartialUpdate(body: EnderecoHistorico, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling enderecoHistoricosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enderecoHistoricosPartialUpdate.');
            }
            const localVarPath = `/endereco-historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EnderecoHistorico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enderecoHistoricosRead.');
            }
            const localVarPath = `/endereco-historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosUpdate(body: EnderecoHistorico, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling enderecoHistoricosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enderecoHistoricosUpdate.');
            }
            const localVarPath = `/endereco-historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EnderecoHistorico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnderecoHistoricosApi - functional programming interface
 * @export
 */
export const EnderecoHistoricosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosCreate(body: EnderecoHistorico, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EnderecoHistorico> {
            const localVarFetchArgs = EnderecoHistoricosApiFetchParamCreator(configuration).enderecoHistoricosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EnderecoHistoricosApiFetchParamCreator(configuration).enderecoHistoricosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20042> {
            const localVarFetchArgs = EnderecoHistoricosApiFetchParamCreator(configuration).enderecoHistoricosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosPartialUpdate(body: EnderecoHistorico, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EnderecoHistorico> {
            const localVarFetchArgs = EnderecoHistoricosApiFetchParamCreator(configuration).enderecoHistoricosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EnderecoHistorico> {
            const localVarFetchArgs = EnderecoHistoricosApiFetchParamCreator(configuration).enderecoHistoricosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosUpdate(body: EnderecoHistorico, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EnderecoHistorico> {
            const localVarFetchArgs = EnderecoHistoricosApiFetchParamCreator(configuration).enderecoHistoricosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EnderecoHistoricosApi - factory interface
 * @export
 */
export const EnderecoHistoricosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosCreate(body: EnderecoHistorico, options?: any) {
            return EnderecoHistoricosApiFp(configuration).enderecoHistoricosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosDelete(id: number, options?: any) {
            return EnderecoHistoricosApiFp(configuration).enderecoHistoricosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosList(limit?: number, offset?: number, options?: any) {
            return EnderecoHistoricosApiFp(configuration).enderecoHistoricosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosPartialUpdate(body: EnderecoHistorico, id: number, options?: any) {
            return EnderecoHistoricosApiFp(configuration).enderecoHistoricosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosRead(id: number, options?: any) {
            return EnderecoHistoricosApiFp(configuration).enderecoHistoricosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EnderecoHistorico} body 
         * @param {number} id A unique integer value identifying this endereco historico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecoHistoricosUpdate(body: EnderecoHistorico, id: number, options?: any) {
            return EnderecoHistoricosApiFp(configuration).enderecoHistoricosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EnderecoHistoricosApi - object-oriented interface
 * @export
 * @class EnderecoHistoricosApi
 * @extends {BaseAPI}
 */
export class EnderecoHistoricosApi extends BaseAPI {
    /**
     * 
     * @param {EnderecoHistorico} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecoHistoricosApi
     */
    public enderecoHistoricosCreate(body: EnderecoHistorico, options?: any) {
        return EnderecoHistoricosApiFp(this.configuration).enderecoHistoricosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this endereco historico.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecoHistoricosApi
     */
    public enderecoHistoricosDelete(id: number, options?: any) {
        return EnderecoHistoricosApiFp(this.configuration).enderecoHistoricosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecoHistoricosApi
     */
    public enderecoHistoricosList(limit?: number, offset?: number, options?: any) {
        return EnderecoHistoricosApiFp(this.configuration).enderecoHistoricosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EnderecoHistorico} body 
     * @param {number} id A unique integer value identifying this endereco historico.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecoHistoricosApi
     */
    public enderecoHistoricosPartialUpdate(body: EnderecoHistorico, id: number, options?: any) {
        return EnderecoHistoricosApiFp(this.configuration).enderecoHistoricosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this endereco historico.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecoHistoricosApi
     */
    public enderecoHistoricosRead(id: number, options?: any) {
        return EnderecoHistoricosApiFp(this.configuration).enderecoHistoricosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EnderecoHistorico} body 
     * @param {number} id A unique integer value identifying this endereco historico.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecoHistoricosApi
     */
    public enderecoHistoricosUpdate(body: EnderecoHistorico, id: number, options?: any) {
        return EnderecoHistoricosApiFp(this.configuration).enderecoHistoricosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EnderecosApi - fetch parameter creator
 * @export
 */
export const EnderecosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosCreate(body: ContribEndereco, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling enderecosCreate.');
            }
            const localVarPath = `/enderecos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribEndereco" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enderecosDelete.');
            }
            const localVarPath = `/enderecos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/enderecos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosPartialUpdate(body: ContribEndereco, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling enderecosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enderecosPartialUpdate.');
            }
            const localVarPath = `/enderecos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribEndereco" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enderecosRead.');
            }
            const localVarPath = `/enderecos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosUpdate(body: ContribEndereco, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling enderecosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enderecosUpdate.');
            }
            const localVarPath = `/enderecos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribEndereco" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnderecosApi - functional programming interface
 * @export
 */
export const EnderecosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosCreate(body: ContribEndereco, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribEndereco> {
            const localVarFetchArgs = EnderecosApiFetchParamCreator(configuration).enderecosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EnderecosApiFetchParamCreator(configuration).enderecosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20043> {
            const localVarFetchArgs = EnderecosApiFetchParamCreator(configuration).enderecosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosPartialUpdate(body: ContribEndereco, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribEndereco> {
            const localVarFetchArgs = EnderecosApiFetchParamCreator(configuration).enderecosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribEndereco> {
            const localVarFetchArgs = EnderecosApiFetchParamCreator(configuration).enderecosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosUpdate(body: ContribEndereco, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribEndereco> {
            const localVarFetchArgs = EnderecosApiFetchParamCreator(configuration).enderecosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EnderecosApi - factory interface
 * @export
 */
export const EnderecosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosCreate(body: ContribEndereco, options?: any) {
            return EnderecosApiFp(configuration).enderecosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosDelete(id: number, options?: any) {
            return EnderecosApiFp(configuration).enderecosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosList(limit?: number, offset?: number, options?: any) {
            return EnderecosApiFp(configuration).enderecosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosPartialUpdate(body: ContribEndereco, id: number, options?: any) {
            return EnderecosApiFp(configuration).enderecosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosRead(id: number, options?: any) {
            return EnderecosApiFp(configuration).enderecosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ContribEndereco} body 
         * @param {number} id A unique integer value identifying this Endereço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enderecosUpdate(body: ContribEndereco, id: number, options?: any) {
            return EnderecosApiFp(configuration).enderecosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EnderecosApi - object-oriented interface
 * @export
 * @class EnderecosApi
 * @extends {BaseAPI}
 */
export class EnderecosApi extends BaseAPI {
    /**
     * 
     * @param {ContribEndereco} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecosApi
     */
    public enderecosCreate(body: ContribEndereco, options?: any) {
        return EnderecosApiFp(this.configuration).enderecosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Endereço.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecosApi
     */
    public enderecosDelete(id: number, options?: any) {
        return EnderecosApiFp(this.configuration).enderecosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecosApi
     */
    public enderecosList(limit?: number, offset?: number, options?: any) {
        return EnderecosApiFp(this.configuration).enderecosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ContribEndereco} body 
     * @param {number} id A unique integer value identifying this Endereço.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecosApi
     */
    public enderecosPartialUpdate(body: ContribEndereco, id: number, options?: any) {
        return EnderecosApiFp(this.configuration).enderecosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Endereço.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecosApi
     */
    public enderecosRead(id: number, options?: any) {
        return EnderecosApiFp(this.configuration).enderecosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ContribEndereco} body 
     * @param {number} id A unique integer value identifying this Endereço.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnderecosApi
     */
    public enderecosUpdate(body: ContribEndereco, id: number, options?: any) {
        return EnderecosApiFp(this.configuration).enderecosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EspecializadosApi - fetch parameter creator
 * @export
 */
export const EspecializadosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Especializado} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosCreate(body: Especializado, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling especializadosCreate.');
            }
            const localVarPath = `/especializados/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Especializado" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling especializadosDelete.');
            }
            const localVarPath = `/especializados/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/especializados/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Especializado} body 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosPartialUpdate(body: Especializado, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling especializadosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling especializadosPartialUpdate.');
            }
            const localVarPath = `/especializados/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Especializado" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling especializadosRead.');
            }
            const localVarPath = `/especializados/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Especializado} body 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosUpdate(body: Especializado, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling especializadosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling especializadosUpdate.');
            }
            const localVarPath = `/especializados/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Especializado" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EspecializadosApi - functional programming interface
 * @export
 */
export const EspecializadosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Especializado} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosCreate(body: Especializado, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Especializado> {
            const localVarFetchArgs = EspecializadosApiFetchParamCreator(configuration).especializadosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EspecializadosApiFetchParamCreator(configuration).especializadosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20044> {
            const localVarFetchArgs = EspecializadosApiFetchParamCreator(configuration).especializadosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Especializado} body 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosPartialUpdate(body: Especializado, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Especializado> {
            const localVarFetchArgs = EspecializadosApiFetchParamCreator(configuration).especializadosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Especializado> {
            const localVarFetchArgs = EspecializadosApiFetchParamCreator(configuration).especializadosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Especializado} body 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosUpdate(body: Especializado, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Especializado> {
            const localVarFetchArgs = EspecializadosApiFetchParamCreator(configuration).especializadosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EspecializadosApi - factory interface
 * @export
 */
export const EspecializadosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Especializado} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosCreate(body: Especializado, options?: any) {
            return EspecializadosApiFp(configuration).especializadosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosDelete(id: number, options?: any) {
            return EspecializadosApiFp(configuration).especializadosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosList(limit?: number, offset?: number, options?: any) {
            return EspecializadosApiFp(configuration).especializadosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Especializado} body 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosPartialUpdate(body: Especializado, id: number, options?: any) {
            return EspecializadosApiFp(configuration).especializadosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosRead(id: number, options?: any) {
            return EspecializadosApiFp(configuration).especializadosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Especializado} body 
         * @param {number} id A unique integer value identifying this especializado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        especializadosUpdate(body: Especializado, id: number, options?: any) {
            return EspecializadosApiFp(configuration).especializadosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EspecializadosApi - object-oriented interface
 * @export
 * @class EspecializadosApi
 * @extends {BaseAPI}
 */
export class EspecializadosApi extends BaseAPI {
    /**
     * 
     * @param {Especializado} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EspecializadosApi
     */
    public especializadosCreate(body: Especializado, options?: any) {
        return EspecializadosApiFp(this.configuration).especializadosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this especializado.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EspecializadosApi
     */
    public especializadosDelete(id: number, options?: any) {
        return EspecializadosApiFp(this.configuration).especializadosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EspecializadosApi
     */
    public especializadosList(limit?: number, offset?: number, options?: any) {
        return EspecializadosApiFp(this.configuration).especializadosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Especializado} body 
     * @param {number} id A unique integer value identifying this especializado.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EspecializadosApi
     */
    public especializadosPartialUpdate(body: Especializado, id: number, options?: any) {
        return EspecializadosApiFp(this.configuration).especializadosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this especializado.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EspecializadosApi
     */
    public especializadosRead(id: number, options?: any) {
        return EspecializadosApiFp(this.configuration).especializadosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Especializado} body 
     * @param {number} id A unique integer value identifying this especializado.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EspecializadosApi
     */
    public especializadosUpdate(body: Especializado, id: number, options?: any) {
        return EspecializadosApiFp(this.configuration).especializadosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EstabelecimentosPenaisApi - fetch parameter creator
 * @export
 */
export const EstabelecimentosPenaisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisCreate(body: EstabelecimentoPenal, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estabelecimentosPenaisCreate.');
            }
            const localVarPath = `/estabelecimentos-penais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EstabelecimentoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estabelecimentosPenaisDelete.');
            }
            const localVarPath = `/estabelecimentos-penais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/estabelecimentos-penais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisPartialUpdate(body: EstabelecimentoPenal, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estabelecimentosPenaisPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estabelecimentosPenaisPartialUpdate.');
            }
            const localVarPath = `/estabelecimentos-penais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EstabelecimentoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estabelecimentosPenaisRead.');
            }
            const localVarPath = `/estabelecimentos-penais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisUpdate(body: EstabelecimentoPenal, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estabelecimentosPenaisUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estabelecimentosPenaisUpdate.');
            }
            const localVarPath = `/estabelecimentos-penais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EstabelecimentoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EstabelecimentosPenaisApi - functional programming interface
 * @export
 */
export const EstabelecimentosPenaisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisCreate(body: EstabelecimentoPenal, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstabelecimentoPenal> {
            const localVarFetchArgs = EstabelecimentosPenaisApiFetchParamCreator(configuration).estabelecimentosPenaisCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EstabelecimentosPenaisApiFetchParamCreator(configuration).estabelecimentosPenaisDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20045> {
            const localVarFetchArgs = EstabelecimentosPenaisApiFetchParamCreator(configuration).estabelecimentosPenaisList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisPartialUpdate(body: EstabelecimentoPenal, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstabelecimentoPenal> {
            const localVarFetchArgs = EstabelecimentosPenaisApiFetchParamCreator(configuration).estabelecimentosPenaisPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstabelecimentoPenal> {
            const localVarFetchArgs = EstabelecimentosPenaisApiFetchParamCreator(configuration).estabelecimentosPenaisRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisUpdate(body: EstabelecimentoPenal, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstabelecimentoPenal> {
            const localVarFetchArgs = EstabelecimentosPenaisApiFetchParamCreator(configuration).estabelecimentosPenaisUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EstabelecimentosPenaisApi - factory interface
 * @export
 */
export const EstabelecimentosPenaisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisCreate(body: EstabelecimentoPenal, options?: any) {
            return EstabelecimentosPenaisApiFp(configuration).estabelecimentosPenaisCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisDelete(id: number, options?: any) {
            return EstabelecimentosPenaisApiFp(configuration).estabelecimentosPenaisDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisList(limit?: number, offset?: number, options?: any) {
            return EstabelecimentosPenaisApiFp(configuration).estabelecimentosPenaisList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisPartialUpdate(body: EstabelecimentoPenal, id: number, options?: any) {
            return EstabelecimentosPenaisApiFp(configuration).estabelecimentosPenaisPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisRead(id: number, options?: any) {
            return EstabelecimentosPenaisApiFp(configuration).estabelecimentosPenaisRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estabelecimentosPenaisUpdate(body: EstabelecimentoPenal, id: number, options?: any) {
            return EstabelecimentosPenaisApiFp(configuration).estabelecimentosPenaisUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EstabelecimentosPenaisApi - object-oriented interface
 * @export
 * @class EstabelecimentosPenaisApi
 * @extends {BaseAPI}
 */
export class EstabelecimentosPenaisApi extends BaseAPI {
    /**
     * 
     * @param {EstabelecimentoPenal} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstabelecimentosPenaisApi
     */
    public estabelecimentosPenaisCreate(body: EstabelecimentoPenal, options?: any) {
        return EstabelecimentosPenaisApiFp(this.configuration).estabelecimentosPenaisCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Estabelecimento Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstabelecimentosPenaisApi
     */
    public estabelecimentosPenaisDelete(id: number, options?: any) {
        return EstabelecimentosPenaisApiFp(this.configuration).estabelecimentosPenaisDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstabelecimentosPenaisApi
     */
    public estabelecimentosPenaisList(limit?: number, offset?: number, options?: any) {
        return EstabelecimentosPenaisApiFp(this.configuration).estabelecimentosPenaisList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EstabelecimentoPenal} body 
     * @param {number} id A unique integer value identifying this Estabelecimento Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstabelecimentosPenaisApi
     */
    public estabelecimentosPenaisPartialUpdate(body: EstabelecimentoPenal, id: number, options?: any) {
        return EstabelecimentosPenaisApiFp(this.configuration).estabelecimentosPenaisPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Estabelecimento Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstabelecimentosPenaisApi
     */
    public estabelecimentosPenaisRead(id: number, options?: any) {
        return EstabelecimentosPenaisApiFp(this.configuration).estabelecimentosPenaisRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EstabelecimentoPenal} body 
     * @param {number} id A unique integer value identifying this Estabelecimento Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstabelecimentosPenaisApi
     */
    public estabelecimentosPenaisUpdate(body: EstabelecimentoPenal, id: number, options?: any) {
        return EstabelecimentosPenaisApiFp(this.configuration).estabelecimentosPenaisUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EstadosApi - fetch parameter creator
 * @export
 */
export const EstadosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Estado} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosCreate(body: Estado, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estadosCreate.');
            }
            const localVarPath = `/estados/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Estado" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estadosDelete.');
            }
            const localVarPath = `/estados/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/estados/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Estado} body 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosPartialUpdate(body: Estado, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estadosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estadosPartialUpdate.');
            }
            const localVarPath = `/estados/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Estado" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estadosRead.');
            }
            const localVarPath = `/estados/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Estado} body 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosUpdate(body: Estado, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estadosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estadosUpdate.');
            }
            const localVarPath = `/estados/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Estado" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EstadosApi - functional programming interface
 * @export
 */
export const EstadosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Estado} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosCreate(body: Estado, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Estado> {
            const localVarFetchArgs = EstadosApiFetchParamCreator(configuration).estadosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EstadosApiFetchParamCreator(configuration).estadosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20046> {
            const localVarFetchArgs = EstadosApiFetchParamCreator(configuration).estadosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Estado} body 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosPartialUpdate(body: Estado, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Estado> {
            const localVarFetchArgs = EstadosApiFetchParamCreator(configuration).estadosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Estado> {
            const localVarFetchArgs = EstadosApiFetchParamCreator(configuration).estadosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Estado} body 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosUpdate(body: Estado, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Estado> {
            const localVarFetchArgs = EstadosApiFetchParamCreator(configuration).estadosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EstadosApi - factory interface
 * @export
 */
export const EstadosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Estado} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosCreate(body: Estado, options?: any) {
            return EstadosApiFp(configuration).estadosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosDelete(id: number, options?: any) {
            return EstadosApiFp(configuration).estadosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosList(limit?: number, offset?: number, options?: any) {
            return EstadosApiFp(configuration).estadosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Estado} body 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosPartialUpdate(body: Estado, id: number, options?: any) {
            return EstadosApiFp(configuration).estadosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosRead(id: number, options?: any) {
            return EstadosApiFp(configuration).estadosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Estado} body 
         * @param {number} id A unique integer value identifying this Estado.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estadosUpdate(body: Estado, id: number, options?: any) {
            return EstadosApiFp(configuration).estadosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EstadosApi - object-oriented interface
 * @export
 * @class EstadosApi
 * @extends {BaseAPI}
 */
export class EstadosApi extends BaseAPI {
    /**
     * 
     * @param {Estado} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstadosApi
     */
    public estadosCreate(body: Estado, options?: any) {
        return EstadosApiFp(this.configuration).estadosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Estado.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstadosApi
     */
    public estadosDelete(id: number, options?: any) {
        return EstadosApiFp(this.configuration).estadosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstadosApi
     */
    public estadosList(limit?: number, offset?: number, options?: any) {
        return EstadosApiFp(this.configuration).estadosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Estado} body 
     * @param {number} id A unique integer value identifying this Estado.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstadosApi
     */
    public estadosPartialUpdate(body: Estado, id: number, options?: any) {
        return EstadosApiFp(this.configuration).estadosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Estado.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstadosApi
     */
    public estadosRead(id: number, options?: any) {
        return EstadosApiFp(this.configuration).estadosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Estado} body 
     * @param {number} id A unique integer value identifying this Estado.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstadosApi
     */
    public estadosUpdate(body: Estado, id: number, options?: any) {
        return EstadosApiFp(this.configuration).estadosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EstruturasMoradiaApi - fetch parameter creator
 * @export
 */
export const EstruturasMoradiaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaCreate(body: EstruturaMoradia, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estruturasMoradiaCreate.');
            }
            const localVarPath = `/estruturas-moradia/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EstruturaMoradia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estruturasMoradiaDelete.');
            }
            const localVarPath = `/estruturas-moradia/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/estruturas-moradia/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaPartialUpdate(body: EstruturaMoradia, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estruturasMoradiaPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estruturasMoradiaPartialUpdate.');
            }
            const localVarPath = `/estruturas-moradia/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EstruturaMoradia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estruturasMoradiaRead.');
            }
            const localVarPath = `/estruturas-moradia/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaUpdate(body: EstruturaMoradia, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling estruturasMoradiaUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling estruturasMoradiaUpdate.');
            }
            const localVarPath = `/estruturas-moradia/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EstruturaMoradia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EstruturasMoradiaApi - functional programming interface
 * @export
 */
export const EstruturasMoradiaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaCreate(body: EstruturaMoradia, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstruturaMoradia> {
            const localVarFetchArgs = EstruturasMoradiaApiFetchParamCreator(configuration).estruturasMoradiaCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EstruturasMoradiaApiFetchParamCreator(configuration).estruturasMoradiaDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20047> {
            const localVarFetchArgs = EstruturasMoradiaApiFetchParamCreator(configuration).estruturasMoradiaList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaPartialUpdate(body: EstruturaMoradia, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstruturaMoradia> {
            const localVarFetchArgs = EstruturasMoradiaApiFetchParamCreator(configuration).estruturasMoradiaPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstruturaMoradia> {
            const localVarFetchArgs = EstruturasMoradiaApiFetchParamCreator(configuration).estruturasMoradiaRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaUpdate(body: EstruturaMoradia, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstruturaMoradia> {
            const localVarFetchArgs = EstruturasMoradiaApiFetchParamCreator(configuration).estruturasMoradiaUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EstruturasMoradiaApi - factory interface
 * @export
 */
export const EstruturasMoradiaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaCreate(body: EstruturaMoradia, options?: any) {
            return EstruturasMoradiaApiFp(configuration).estruturasMoradiaCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaDelete(id: number, options?: any) {
            return EstruturasMoradiaApiFp(configuration).estruturasMoradiaDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaList(limit?: number, offset?: number, options?: any) {
            return EstruturasMoradiaApiFp(configuration).estruturasMoradiaList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaPartialUpdate(body: EstruturaMoradia, id: number, options?: any) {
            return EstruturasMoradiaApiFp(configuration).estruturasMoradiaPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaRead(id: number, options?: any) {
            return EstruturasMoradiaApiFp(configuration).estruturasMoradiaRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EstruturaMoradia} body 
         * @param {number} id A unique integer value identifying this estrutura moradia.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estruturasMoradiaUpdate(body: EstruturaMoradia, id: number, options?: any) {
            return EstruturasMoradiaApiFp(configuration).estruturasMoradiaUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EstruturasMoradiaApi - object-oriented interface
 * @export
 * @class EstruturasMoradiaApi
 * @extends {BaseAPI}
 */
export class EstruturasMoradiaApi extends BaseAPI {
    /**
     * 
     * @param {EstruturaMoradia} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstruturasMoradiaApi
     */
    public estruturasMoradiaCreate(body: EstruturaMoradia, options?: any) {
        return EstruturasMoradiaApiFp(this.configuration).estruturasMoradiaCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this estrutura moradia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstruturasMoradiaApi
     */
    public estruturasMoradiaDelete(id: number, options?: any) {
        return EstruturasMoradiaApiFp(this.configuration).estruturasMoradiaDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstruturasMoradiaApi
     */
    public estruturasMoradiaList(limit?: number, offset?: number, options?: any) {
        return EstruturasMoradiaApiFp(this.configuration).estruturasMoradiaList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EstruturaMoradia} body 
     * @param {number} id A unique integer value identifying this estrutura moradia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstruturasMoradiaApi
     */
    public estruturasMoradiaPartialUpdate(body: EstruturaMoradia, id: number, options?: any) {
        return EstruturasMoradiaApiFp(this.configuration).estruturasMoradiaPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this estrutura moradia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstruturasMoradiaApi
     */
    public estruturasMoradiaRead(id: number, options?: any) {
        return EstruturasMoradiaApiFp(this.configuration).estruturasMoradiaRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EstruturaMoradia} body 
     * @param {number} id A unique integer value identifying this estrutura moradia.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstruturasMoradiaApi
     */
    public estruturasMoradiaUpdate(body: EstruturaMoradia, id: number, options?: any) {
        return EstruturasMoradiaApiFp(this.configuration).estruturasMoradiaUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EtiquetasApi - fetch parameter creator
 * @export
 */
export const EtiquetasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Etiqueta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasCreate(body: Etiqueta, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling etiquetasCreate.');
            }
            const localVarPath = `/etiquetas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Etiqueta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling etiquetasDelete.');
            }
            const localVarPath = `/etiquetas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/etiquetas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Etiqueta} body 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasPartialUpdate(body: Etiqueta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling etiquetasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling etiquetasPartialUpdate.');
            }
            const localVarPath = `/etiquetas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Etiqueta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling etiquetasRead.');
            }
            const localVarPath = `/etiquetas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Etiqueta} body 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasUpdate(body: Etiqueta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling etiquetasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling etiquetasUpdate.');
            }
            const localVarPath = `/etiquetas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Etiqueta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EtiquetasApi - functional programming interface
 * @export
 */
export const EtiquetasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Etiqueta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasCreate(body: Etiqueta, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Etiqueta> {
            const localVarFetchArgs = EtiquetasApiFetchParamCreator(configuration).etiquetasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EtiquetasApiFetchParamCreator(configuration).etiquetasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20048> {
            const localVarFetchArgs = EtiquetasApiFetchParamCreator(configuration).etiquetasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Etiqueta} body 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasPartialUpdate(body: Etiqueta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Etiqueta> {
            const localVarFetchArgs = EtiquetasApiFetchParamCreator(configuration).etiquetasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Etiqueta> {
            const localVarFetchArgs = EtiquetasApiFetchParamCreator(configuration).etiquetasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Etiqueta} body 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasUpdate(body: Etiqueta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Etiqueta> {
            const localVarFetchArgs = EtiquetasApiFetchParamCreator(configuration).etiquetasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EtiquetasApi - factory interface
 * @export
 */
export const EtiquetasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Etiqueta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasCreate(body: Etiqueta, options?: any) {
            return EtiquetasApiFp(configuration).etiquetasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasDelete(id: number, options?: any) {
            return EtiquetasApiFp(configuration).etiquetasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasList(limit?: number, offset?: number, options?: any) {
            return EtiquetasApiFp(configuration).etiquetasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Etiqueta} body 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasPartialUpdate(body: Etiqueta, id: number, options?: any) {
            return EtiquetasApiFp(configuration).etiquetasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasRead(id: number, options?: any) {
            return EtiquetasApiFp(configuration).etiquetasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Etiqueta} body 
         * @param {number} id A unique integer value identifying this etiqueta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiquetasUpdate(body: Etiqueta, id: number, options?: any) {
            return EtiquetasApiFp(configuration).etiquetasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * EtiquetasApi - object-oriented interface
 * @export
 * @class EtiquetasApi
 * @extends {BaseAPI}
 */
export class EtiquetasApi extends BaseAPI {
    /**
     * 
     * @param {Etiqueta} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EtiquetasApi
     */
    public etiquetasCreate(body: Etiqueta, options?: any) {
        return EtiquetasApiFp(this.configuration).etiquetasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this etiqueta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EtiquetasApi
     */
    public etiquetasDelete(id: number, options?: any) {
        return EtiquetasApiFp(this.configuration).etiquetasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EtiquetasApi
     */
    public etiquetasList(limit?: number, offset?: number, options?: any) {
        return EtiquetasApiFp(this.configuration).etiquetasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Etiqueta} body 
     * @param {number} id A unique integer value identifying this etiqueta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EtiquetasApi
     */
    public etiquetasPartialUpdate(body: Etiqueta, id: number, options?: any) {
        return EtiquetasApiFp(this.configuration).etiquetasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this etiqueta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EtiquetasApi
     */
    public etiquetasRead(id: number, options?: any) {
        return EtiquetasApiFp(this.configuration).etiquetasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Etiqueta} body 
     * @param {number} id A unique integer value identifying this etiqueta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EtiquetasApi
     */
    public etiquetasUpdate(body: Etiqueta, id: number, options?: any) {
        return EtiquetasApiFp(this.configuration).etiquetasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * EventosApi - fetch parameter creator
 * @export
 */
export const EventosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EventoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosCreate(body: EventoEvento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling eventosCreate.');
            }
            const localVarPath = `/eventos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventoEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventosDelete.');
            }
            const localVarPath = `/eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [eh_pai] 
         * @param {string} [defensor] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosList(tipo?: string, eh_pai?: string, defensor?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/eventos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (tipo !== undefined) {
                localVarQueryParameter['tipo'] = tipo;
            }

            if (eh_pai !== undefined) {
                localVarQueryParameter['eh_pai'] = eh_pai;
            }

            if (defensor !== undefined) {
                localVarQueryParameter['defensor'] = defensor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventosRead.');
            }
            const localVarPath = `/eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventosApi - functional programming interface
 * @export
 */
export const EventosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EventoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosCreate(body: EventoEvento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventoEvento> {
            const localVarFetchArgs = EventosApiFetchParamCreator(configuration).eventosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventosApiFetchParamCreator(configuration).eventosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [eh_pai] 
         * @param {string} [defensor] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosList(tipo?: string, eh_pai?: string, defensor?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20049> {
            const localVarFetchArgs = EventosApiFetchParamCreator(configuration).eventosList(tipo, eh_pai, defensor, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventoEvento> {
            const localVarFetchArgs = EventosApiFetchParamCreator(configuration).eventosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventosApi - factory interface
 * @export
 */
export const EventosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {EventoEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosCreate(body: EventoEvento, options?: any) {
            return EventosApiFp(configuration).eventosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosDelete(id: number, options?: any) {
            return EventosApiFp(configuration).eventosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [tipo] 
         * @param {string} [eh_pai] 
         * @param {string} [defensor] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosList(tipo?: string, eh_pai?: string, defensor?: string, limit?: number, offset?: number, options?: any) {
            return EventosApiFp(configuration).eventosList(tipo, eh_pai, defensor, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this evento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventosRead(id: number, options?: any) {
            return EventosApiFp(configuration).eventosRead(id, options)(fetch, basePath);
        },
    };
};

/**
 * EventosApi - object-oriented interface
 * @export
 * @class EventosApi
 * @extends {BaseAPI}
 */
export class EventosApi extends BaseAPI {
    /**
     * 
     * @param {EventoEvento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventosApi
     */
    public eventosCreate(body: EventoEvento, options?: any) {
        return EventosApiFp(this.configuration).eventosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventosApi
     */
    public eventosDelete(id: number, options?: any) {
        return EventosApiFp(this.configuration).eventosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [tipo] 
     * @param {string} [eh_pai] 
     * @param {string} [defensor] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventosApi
     */
    public eventosList(tipo?: string, eh_pai?: string, defensor?: string, limit?: number, offset?: number, options?: any) {
        return EventosApiFp(this.configuration).eventosList(tipo, eh_pai, defensor, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this evento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventosApi
     */
    public eventosRead(id: number, options?: any) {
        return EventosApiFp(this.configuration).eventosRead(id, options)(this.fetch, this.basePath);
    }

}
/**
 * FaltasApi - fetch parameter creator
 * @export
 */
export const FaltasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Falta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasCreate(body: Falta, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling faltasCreate.');
            }
            const localVarPath = `/faltas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Falta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling faltasDelete.');
            }
            const localVarPath = `/faltas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/faltas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Falta} body 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasPartialUpdate(body: Falta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling faltasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling faltasPartialUpdate.');
            }
            const localVarPath = `/faltas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Falta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling faltasRead.');
            }
            const localVarPath = `/faltas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Falta} body 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasUpdate(body: Falta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling faltasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling faltasUpdate.');
            }
            const localVarPath = `/faltas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Falta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FaltasApi - functional programming interface
 * @export
 */
export const FaltasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Falta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasCreate(body: Falta, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Falta> {
            const localVarFetchArgs = FaltasApiFetchParamCreator(configuration).faltasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FaltasApiFetchParamCreator(configuration).faltasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20050> {
            const localVarFetchArgs = FaltasApiFetchParamCreator(configuration).faltasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Falta} body 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasPartialUpdate(body: Falta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Falta> {
            const localVarFetchArgs = FaltasApiFetchParamCreator(configuration).faltasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Falta> {
            const localVarFetchArgs = FaltasApiFetchParamCreator(configuration).faltasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Falta} body 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasUpdate(body: Falta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Falta> {
            const localVarFetchArgs = FaltasApiFetchParamCreator(configuration).faltasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FaltasApi - factory interface
 * @export
 */
export const FaltasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Falta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasCreate(body: Falta, options?: any) {
            return FaltasApiFp(configuration).faltasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasDelete(id: number, options?: any) {
            return FaltasApiFp(configuration).faltasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasList(limit?: number, offset?: number, options?: any) {
            return FaltasApiFp(configuration).faltasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Falta} body 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasPartialUpdate(body: Falta, id: number, options?: any) {
            return FaltasApiFp(configuration).faltasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasRead(id: number, options?: any) {
            return FaltasApiFp(configuration).faltasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Falta} body 
         * @param {number} id A unique integer value identifying this Falta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faltasUpdate(body: Falta, id: number, options?: any) {
            return FaltasApiFp(configuration).faltasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * FaltasApi - object-oriented interface
 * @export
 * @class FaltasApi
 * @extends {BaseAPI}
 */
export class FaltasApi extends BaseAPI {
    /**
     * 
     * @param {Falta} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaltasApi
     */
    public faltasCreate(body: Falta, options?: any) {
        return FaltasApiFp(this.configuration).faltasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Falta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaltasApi
     */
    public faltasDelete(id: number, options?: any) {
        return FaltasApiFp(this.configuration).faltasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaltasApi
     */
    public faltasList(limit?: number, offset?: number, options?: any) {
        return FaltasApiFp(this.configuration).faltasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Falta} body 
     * @param {number} id A unique integer value identifying this Falta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaltasApi
     */
    public faltasPartialUpdate(body: Falta, id: number, options?: any) {
        return FaltasApiFp(this.configuration).faltasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Falta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaltasApi
     */
    public faltasRead(id: number, options?: any) {
        return FaltasApiFp(this.configuration).faltasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Falta} body 
     * @param {number} id A unique integer value identifying this Falta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaltasApi
     */
    public faltasUpdate(body: Falta, id: number, options?: any) {
        return FaltasApiFp(this.configuration).faltasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * FiliacoesApi - fetch parameter creator
 * @export
 */
export const FiliacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Filiacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesCreate(body: Filiacao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling filiacoesCreate.');
            }
            const localVarPath = `/filiacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Filiacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling filiacoesDelete.');
            }
            const localVarPath = `/filiacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/filiacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Filiacao} body 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesPartialUpdate(body: Filiacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling filiacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling filiacoesPartialUpdate.');
            }
            const localVarPath = `/filiacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Filiacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling filiacoesRead.');
            }
            const localVarPath = `/filiacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Filiacao} body 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesUpdate(body: Filiacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling filiacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling filiacoesUpdate.');
            }
            const localVarPath = `/filiacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Filiacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FiliacoesApi - functional programming interface
 * @export
 */
export const FiliacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Filiacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesCreate(body: Filiacao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Filiacao> {
            const localVarFetchArgs = FiliacoesApiFetchParamCreator(configuration).filiacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FiliacoesApiFetchParamCreator(configuration).filiacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20051> {
            const localVarFetchArgs = FiliacoesApiFetchParamCreator(configuration).filiacoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Filiacao} body 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesPartialUpdate(body: Filiacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Filiacao> {
            const localVarFetchArgs = FiliacoesApiFetchParamCreator(configuration).filiacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Filiacao> {
            const localVarFetchArgs = FiliacoesApiFetchParamCreator(configuration).filiacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Filiacao} body 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesUpdate(body: Filiacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Filiacao> {
            const localVarFetchArgs = FiliacoesApiFetchParamCreator(configuration).filiacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FiliacoesApi - factory interface
 * @export
 */
export const FiliacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Filiacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesCreate(body: Filiacao, options?: any) {
            return FiliacoesApiFp(configuration).filiacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesDelete(id: number, options?: any) {
            return FiliacoesApiFp(configuration).filiacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesList(limit?: number, offset?: number, options?: any) {
            return FiliacoesApiFp(configuration).filiacoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Filiacao} body 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesPartialUpdate(body: Filiacao, id: number, options?: any) {
            return FiliacoesApiFp(configuration).filiacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesRead(id: number, options?: any) {
            return FiliacoesApiFp(configuration).filiacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Filiacao} body 
         * @param {number} id A unique integer value identifying this Filiação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filiacoesUpdate(body: Filiacao, id: number, options?: any) {
            return FiliacoesApiFp(configuration).filiacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * FiliacoesApi - object-oriented interface
 * @export
 * @class FiliacoesApi
 * @extends {BaseAPI}
 */
export class FiliacoesApi extends BaseAPI {
    /**
     * 
     * @param {Filiacao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiliacoesApi
     */
    public filiacoesCreate(body: Filiacao, options?: any) {
        return FiliacoesApiFp(this.configuration).filiacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Filiação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiliacoesApi
     */
    public filiacoesDelete(id: number, options?: any) {
        return FiliacoesApiFp(this.configuration).filiacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiliacoesApi
     */
    public filiacoesList(limit?: number, offset?: number, options?: any) {
        return FiliacoesApiFp(this.configuration).filiacoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Filiacao} body 
     * @param {number} id A unique integer value identifying this Filiação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiliacoesApi
     */
    public filiacoesPartialUpdate(body: Filiacao, id: number, options?: any) {
        return FiliacoesApiFp(this.configuration).filiacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Filiação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiliacoesApi
     */
    public filiacoesRead(id: number, options?: any) {
        return FiliacoesApiFp(this.configuration).filiacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Filiacao} body 
     * @param {number} id A unique integer value identifying this Filiação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiliacoesApi
     */
    public filiacoesUpdate(body: Filiacao, id: number, options?: any) {
        return FiliacoesApiFp(this.configuration).filiacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * FormasAtendimentoApi - fetch parameter creator
 * @export
 */
export const FormasAtendimentoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoCreate(body: FormaAtendimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formasAtendimentoCreate.');
            }
            const localVarPath = `/formas-atendimento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FormaAtendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formasAtendimentoDelete.');
            }
            const localVarPath = `/formas-atendimento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/formas-atendimento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoPartialUpdate(body: FormaAtendimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formasAtendimentoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formasAtendimentoPartialUpdate.');
            }
            const localVarPath = `/formas-atendimento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FormaAtendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formasAtendimentoRead.');
            }
            const localVarPath = `/formas-atendimento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoUpdate(body: FormaAtendimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formasAtendimentoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formasAtendimentoUpdate.');
            }
            const localVarPath = `/formas-atendimento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FormaAtendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormasAtendimentoApi - functional programming interface
 * @export
 */
export const FormasAtendimentoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoCreate(body: FormaAtendimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormaAtendimento> {
            const localVarFetchArgs = FormasAtendimentoApiFetchParamCreator(configuration).formasAtendimentoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FormasAtendimentoApiFetchParamCreator(configuration).formasAtendimentoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20052> {
            const localVarFetchArgs = FormasAtendimentoApiFetchParamCreator(configuration).formasAtendimentoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoPartialUpdate(body: FormaAtendimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormaAtendimento> {
            const localVarFetchArgs = FormasAtendimentoApiFetchParamCreator(configuration).formasAtendimentoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormaAtendimento> {
            const localVarFetchArgs = FormasAtendimentoApiFetchParamCreator(configuration).formasAtendimentoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoUpdate(body: FormaAtendimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormaAtendimento> {
            const localVarFetchArgs = FormasAtendimentoApiFetchParamCreator(configuration).formasAtendimentoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FormasAtendimentoApi - factory interface
 * @export
 */
export const FormasAtendimentoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoCreate(body: FormaAtendimento, options?: any) {
            return FormasAtendimentoApiFp(configuration).formasAtendimentoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoDelete(id: number, options?: any) {
            return FormasAtendimentoApiFp(configuration).formasAtendimentoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoList(limit?: number, offset?: number, options?: any) {
            return FormasAtendimentoApiFp(configuration).formasAtendimentoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoPartialUpdate(body: FormaAtendimento, id: number, options?: any) {
            return FormasAtendimentoApiFp(configuration).formasAtendimentoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoRead(id: number, options?: any) {
            return FormasAtendimentoApiFp(configuration).formasAtendimentoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FormaAtendimento} body 
         * @param {number} id A unique integer value identifying this Forma de atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formasAtendimentoUpdate(body: FormaAtendimento, id: number, options?: any) {
            return FormasAtendimentoApiFp(configuration).formasAtendimentoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * FormasAtendimentoApi - object-oriented interface
 * @export
 * @class FormasAtendimentoApi
 * @extends {BaseAPI}
 */
export class FormasAtendimentoApi extends BaseAPI {
    /**
     * 
     * @param {FormaAtendimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormasAtendimentoApi
     */
    public formasAtendimentoCreate(body: FormaAtendimento, options?: any) {
        return FormasAtendimentoApiFp(this.configuration).formasAtendimentoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Forma de atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormasAtendimentoApi
     */
    public formasAtendimentoDelete(id: number, options?: any) {
        return FormasAtendimentoApiFp(this.configuration).formasAtendimentoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormasAtendimentoApi
     */
    public formasAtendimentoList(limit?: number, offset?: number, options?: any) {
        return FormasAtendimentoApiFp(this.configuration).formasAtendimentoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FormaAtendimento} body 
     * @param {number} id A unique integer value identifying this Forma de atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormasAtendimentoApi
     */
    public formasAtendimentoPartialUpdate(body: FormaAtendimento, id: number, options?: any) {
        return FormasAtendimentoApiFp(this.configuration).formasAtendimentoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Forma de atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormasAtendimentoApi
     */
    public formasAtendimentoRead(id: number, options?: any) {
        return FormasAtendimentoApiFp(this.configuration).formasAtendimentoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FormaAtendimento} body 
     * @param {number} id A unique integer value identifying this Forma de atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormasAtendimentoApi
     */
    public formasAtendimentoUpdate(body: FormaAtendimento, id: number, options?: any) {
        return FormasAtendimentoApiFp(this.configuration).formasAtendimentoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * FormulariosApi - fetch parameter creator
 * @export
 */
export const FormulariosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Formulario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosCreate(body: Formulario, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosCreate.');
            }
            const localVarPath = `/formularios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Formulario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosDelete.');
            }
            const localVarPath = `/formularios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/formularios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Formulario} body 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPartialUpdate(body: Formulario, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosPartialUpdate.');
            }
            const localVarPath = `/formularios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Formulario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosRead.');
            }
            const localVarPath = `/formularios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Formulario} body 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosUpdate(body: Formulario, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosUpdate.');
            }
            const localVarPath = `/formularios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Formulario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormulariosApi - functional programming interface
 * @export
 */
export const FormulariosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Formulario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosCreate(body: Formulario, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Formulario> {
            const localVarFetchArgs = FormulariosApiFetchParamCreator(configuration).formulariosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FormulariosApiFetchParamCreator(configuration).formulariosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20055> {
            const localVarFetchArgs = FormulariosApiFetchParamCreator(configuration).formulariosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Formulario} body 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPartialUpdate(body: Formulario, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Formulario> {
            const localVarFetchArgs = FormulariosApiFetchParamCreator(configuration).formulariosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Formulario> {
            const localVarFetchArgs = FormulariosApiFetchParamCreator(configuration).formulariosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Formulario} body 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosUpdate(body: Formulario, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Formulario> {
            const localVarFetchArgs = FormulariosApiFetchParamCreator(configuration).formulariosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FormulariosApi - factory interface
 * @export
 */
export const FormulariosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Formulario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosCreate(body: Formulario, options?: any) {
            return FormulariosApiFp(configuration).formulariosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosDelete(id: number, options?: any) {
            return FormulariosApiFp(configuration).formulariosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosList(limit?: number, offset?: number, options?: any) {
            return FormulariosApiFp(configuration).formulariosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Formulario} body 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPartialUpdate(body: Formulario, id: number, options?: any) {
            return FormulariosApiFp(configuration).formulariosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRead(id: number, options?: any) {
            return FormulariosApiFp(configuration).formulariosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Formulario} body 
         * @param {number} id A unique integer value identifying this Formulário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosUpdate(body: Formulario, id: number, options?: any) {
            return FormulariosApiFp(configuration).formulariosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * FormulariosApi - object-oriented interface
 * @export
 * @class FormulariosApi
 * @extends {BaseAPI}
 */
export class FormulariosApi extends BaseAPI {
    /**
     * 
     * @param {Formulario} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosApi
     */
    public formulariosCreate(body: Formulario, options?: any) {
        return FormulariosApiFp(this.configuration).formulariosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Formulário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosApi
     */
    public formulariosDelete(id: number, options?: any) {
        return FormulariosApiFp(this.configuration).formulariosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosApi
     */
    public formulariosList(limit?: number, offset?: number, options?: any) {
        return FormulariosApiFp(this.configuration).formulariosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Formulario} body 
     * @param {number} id A unique integer value identifying this Formulário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosApi
     */
    public formulariosPartialUpdate(body: Formulario, id: number, options?: any) {
        return FormulariosApiFp(this.configuration).formulariosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Formulário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosApi
     */
    public formulariosRead(id: number, options?: any) {
        return FormulariosApiFp(this.configuration).formulariosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Formulario} body 
     * @param {number} id A unique integer value identifying this Formulário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosApi
     */
    public formulariosUpdate(body: Formulario, id: number, options?: any) {
        return FormulariosApiFp(this.configuration).formulariosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * FormulariosPerguntasApi - fetch parameter creator
 * @export
 */
export const FormulariosPerguntasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasCreate(body: FormularioPergunta, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosPerguntasCreate.');
            }
            const localVarPath = `/formularios-perguntas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FormularioPergunta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosPerguntasDelete.');
            }
            const localVarPath = `/formularios-perguntas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/formularios-perguntas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasPartialUpdate(body: FormularioPergunta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosPerguntasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosPerguntasPartialUpdate.');
            }
            const localVarPath = `/formularios-perguntas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FormularioPergunta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosPerguntasRead.');
            }
            const localVarPath = `/formularios-perguntas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasUpdate(body: FormularioPergunta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosPerguntasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosPerguntasUpdate.');
            }
            const localVarPath = `/formularios-perguntas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FormularioPergunta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormulariosPerguntasApi - functional programming interface
 * @export
 */
export const FormulariosPerguntasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasCreate(body: FormularioPergunta, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormularioPergunta> {
            const localVarFetchArgs = FormulariosPerguntasApiFetchParamCreator(configuration).formulariosPerguntasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FormulariosPerguntasApiFetchParamCreator(configuration).formulariosPerguntasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20053> {
            const localVarFetchArgs = FormulariosPerguntasApiFetchParamCreator(configuration).formulariosPerguntasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasPartialUpdate(body: FormularioPergunta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormularioPergunta> {
            const localVarFetchArgs = FormulariosPerguntasApiFetchParamCreator(configuration).formulariosPerguntasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormularioPergunta> {
            const localVarFetchArgs = FormulariosPerguntasApiFetchParamCreator(configuration).formulariosPerguntasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasUpdate(body: FormularioPergunta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormularioPergunta> {
            const localVarFetchArgs = FormulariosPerguntasApiFetchParamCreator(configuration).formulariosPerguntasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FormulariosPerguntasApi - factory interface
 * @export
 */
export const FormulariosPerguntasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasCreate(body: FormularioPergunta, options?: any) {
            return FormulariosPerguntasApiFp(configuration).formulariosPerguntasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasDelete(id: number, options?: any) {
            return FormulariosPerguntasApiFp(configuration).formulariosPerguntasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasList(limit?: number, offset?: number, options?: any) {
            return FormulariosPerguntasApiFp(configuration).formulariosPerguntasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasPartialUpdate(body: FormularioPergunta, id: number, options?: any) {
            return FormulariosPerguntasApiFp(configuration).formulariosPerguntasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasRead(id: number, options?: any) {
            return FormulariosPerguntasApiFp(configuration).formulariosPerguntasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FormularioPergunta} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosPerguntasUpdate(body: FormularioPergunta, id: number, options?: any) {
            return FormulariosPerguntasApiFp(configuration).formulariosPerguntasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * FormulariosPerguntasApi - object-oriented interface
 * @export
 * @class FormulariosPerguntasApi
 * @extends {BaseAPI}
 */
export class FormulariosPerguntasApi extends BaseAPI {
    /**
     * 
     * @param {FormularioPergunta} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosPerguntasApi
     */
    public formulariosPerguntasCreate(body: FormularioPergunta, options?: any) {
        return FormulariosPerguntasApiFp(this.configuration).formulariosPerguntasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Pergunta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosPerguntasApi
     */
    public formulariosPerguntasDelete(id: number, options?: any) {
        return FormulariosPerguntasApiFp(this.configuration).formulariosPerguntasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosPerguntasApi
     */
    public formulariosPerguntasList(limit?: number, offset?: number, options?: any) {
        return FormulariosPerguntasApiFp(this.configuration).formulariosPerguntasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FormularioPergunta} body 
     * @param {number} id A unique integer value identifying this Pergunta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosPerguntasApi
     */
    public formulariosPerguntasPartialUpdate(body: FormularioPergunta, id: number, options?: any) {
        return FormulariosPerguntasApiFp(this.configuration).formulariosPerguntasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Pergunta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosPerguntasApi
     */
    public formulariosPerguntasRead(id: number, options?: any) {
        return FormulariosPerguntasApiFp(this.configuration).formulariosPerguntasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FormularioPergunta} body 
     * @param {number} id A unique integer value identifying this Pergunta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosPerguntasApi
     */
    public formulariosPerguntasUpdate(body: FormularioPergunta, id: number, options?: any) {
        return FormulariosPerguntasApiFp(this.configuration).formulariosPerguntasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * FormulariosRespostasApi - fetch parameter creator
 * @export
 */
export const FormulariosRespostasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Resposta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasCreate(body: Resposta, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosRespostasCreate.');
            }
            const localVarPath = `/formularios-respostas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Resposta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosRespostasDelete.');
            }
            const localVarPath = `/formularios-respostas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/formularios-respostas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Resposta} body 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasPartialUpdate(body: Resposta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosRespostasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosRespostasPartialUpdate.');
            }
            const localVarPath = `/formularios-respostas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Resposta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosRespostasRead.');
            }
            const localVarPath = `/formularios-respostas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Resposta} body 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasUpdate(body: Resposta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling formulariosRespostasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling formulariosRespostasUpdate.');
            }
            const localVarPath = `/formularios-respostas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Resposta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormulariosRespostasApi - functional programming interface
 * @export
 */
export const FormulariosRespostasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Resposta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasCreate(body: Resposta, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Resposta> {
            const localVarFetchArgs = FormulariosRespostasApiFetchParamCreator(configuration).formulariosRespostasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FormulariosRespostasApiFetchParamCreator(configuration).formulariosRespostasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20054> {
            const localVarFetchArgs = FormulariosRespostasApiFetchParamCreator(configuration).formulariosRespostasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Resposta} body 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasPartialUpdate(body: Resposta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Resposta> {
            const localVarFetchArgs = FormulariosRespostasApiFetchParamCreator(configuration).formulariosRespostasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Resposta> {
            const localVarFetchArgs = FormulariosRespostasApiFetchParamCreator(configuration).formulariosRespostasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Resposta} body 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasUpdate(body: Resposta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Resposta> {
            const localVarFetchArgs = FormulariosRespostasApiFetchParamCreator(configuration).formulariosRespostasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FormulariosRespostasApi - factory interface
 * @export
 */
export const FormulariosRespostasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Resposta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasCreate(body: Resposta, options?: any) {
            return FormulariosRespostasApiFp(configuration).formulariosRespostasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasDelete(id: number, options?: any) {
            return FormulariosRespostasApiFp(configuration).formulariosRespostasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasList(limit?: number, offset?: number, options?: any) {
            return FormulariosRespostasApiFp(configuration).formulariosRespostasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Resposta} body 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasPartialUpdate(body: Resposta, id: number, options?: any) {
            return FormulariosRespostasApiFp(configuration).formulariosRespostasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasRead(id: number, options?: any) {
            return FormulariosRespostasApiFp(configuration).formulariosRespostasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Resposta} body 
         * @param {number} id A unique integer value identifying this Resposta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formulariosRespostasUpdate(body: Resposta, id: number, options?: any) {
            return FormulariosRespostasApiFp(configuration).formulariosRespostasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * FormulariosRespostasApi - object-oriented interface
 * @export
 * @class FormulariosRespostasApi
 * @extends {BaseAPI}
 */
export class FormulariosRespostasApi extends BaseAPI {
    /**
     * 
     * @param {Resposta} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosRespostasApi
     */
    public formulariosRespostasCreate(body: Resposta, options?: any) {
        return FormulariosRespostasApiFp(this.configuration).formulariosRespostasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Resposta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosRespostasApi
     */
    public formulariosRespostasDelete(id: number, options?: any) {
        return FormulariosRespostasApiFp(this.configuration).formulariosRespostasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosRespostasApi
     */
    public formulariosRespostasList(limit?: number, offset?: number, options?: any) {
        return FormulariosRespostasApiFp(this.configuration).formulariosRespostasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Resposta} body 
     * @param {number} id A unique integer value identifying this Resposta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosRespostasApi
     */
    public formulariosRespostasPartialUpdate(body: Resposta, id: number, options?: any) {
        return FormulariosRespostasApiFp(this.configuration).formulariosRespostasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Resposta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosRespostasApi
     */
    public formulariosRespostasRead(id: number, options?: any) {
        return FormulariosRespostasApiFp(this.configuration).formulariosRespostasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Resposta} body 
     * @param {number} id A unique integer value identifying this Resposta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormulariosRespostasApi
     */
    public formulariosRespostasUpdate(body: Resposta, id: number, options?: any) {
        return FormulariosRespostasApiFp(this.configuration).formulariosRespostasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * GetAuthTokenApi - fetch parameter creator
 * @export
 */
export const GetAuthTokenApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CustomAuthToken} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokenCreate(body: CustomAuthToken, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getAuthTokenCreate.');
            }
            const localVarPath = `/get-auth-token/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomAuthToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetAuthTokenApi - functional programming interface
 * @export
 */
export const GetAuthTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CustomAuthToken} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokenCreate(body: CustomAuthToken, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomAuthToken> {
            const localVarFetchArgs = GetAuthTokenApiFetchParamCreator(configuration).getAuthTokenCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GetAuthTokenApi - factory interface
 * @export
 */
export const GetAuthTokenApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CustomAuthToken} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokenCreate(body: CustomAuthToken, options?: any) {
            return GetAuthTokenApiFp(configuration).getAuthTokenCreate(body, options)(fetch, basePath);
        },
    };
};

/**
 * GetAuthTokenApi - object-oriented interface
 * @export
 * @class GetAuthTokenApi
 * @extends {BaseAPI}
 */
export class GetAuthTokenApi extends BaseAPI {
    /**
     * 
     * @param {CustomAuthToken} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetAuthTokenApi
     */
    public getAuthTokenCreate(body: CustomAuthToken, options?: any) {
        return GetAuthTokenApiFp(this.configuration).getAuthTokenCreate(body, options)(this.fetch, this.basePath);
    }

}
/**
 * GrausApi - fetch parameter creator
 * @export
 */
export const GrausApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grausList(options: any = {}): FetchArgs {
            const localVarPath = `/graus/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grausRead(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling grausRead.');
            }
            const localVarPath = `/graus/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GrausApi - functional programming interface
 * @export
 */
export const GrausApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grausList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GrausApiFetchParamCreator(configuration).grausList(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grausRead(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GrausApiFetchParamCreator(configuration).grausRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GrausApi - factory interface
 * @export
 */
export const GrausApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grausList(options?: any) {
            return GrausApiFp(configuration).grausList(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grausRead(id: string, options?: any) {
            return GrausApiFp(configuration).grausRead(id, options)(fetch, basePath);
        },
    };
};

/**
 * GrausApi - object-oriented interface
 * @export
 * @class GrausApi
 * @extends {BaseAPI}
 */
export class GrausApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrausApi
     */
    public grausList(options?: any) {
        return GrausApiFp(this.configuration).grausList(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrausApi
     */
    public grausRead(id: string, options?: any) {
        return GrausApiFp(this.configuration).grausRead(id, options)(this.fetch, this.basePath);
    }

}
/**
 * GruposAgendamentoApi - fetch parameter creator
 * @export
 */
export const GruposAgendamentoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoCreate(body: GrupoDeDefensoriasParaAgendamento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling gruposAgendamentoCreate.');
            }
            const localVarPath = `/grupos-agendamento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GrupoDeDefensoriasParaAgendamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gruposAgendamentoDelete.');
            }
            const localVarPath = `/grupos-agendamento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/grupos-agendamento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoPartialUpdate(body: GrupoDeDefensoriasParaAgendamento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling gruposAgendamentoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gruposAgendamentoPartialUpdate.');
            }
            const localVarPath = `/grupos-agendamento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GrupoDeDefensoriasParaAgendamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gruposAgendamentoRead.');
            }
            const localVarPath = `/grupos-agendamento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoUpdate(body: GrupoDeDefensoriasParaAgendamento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling gruposAgendamentoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gruposAgendamentoUpdate.');
            }
            const localVarPath = `/grupos-agendamento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GrupoDeDefensoriasParaAgendamento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GruposAgendamentoApi - functional programming interface
 * @export
 */
export const GruposAgendamentoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoCreate(body: GrupoDeDefensoriasParaAgendamento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GrupoDeDefensoriasParaAgendamento> {
            const localVarFetchArgs = GruposAgendamentoApiFetchParamCreator(configuration).gruposAgendamentoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GruposAgendamentoApiFetchParamCreator(configuration).gruposAgendamentoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20056> {
            const localVarFetchArgs = GruposAgendamentoApiFetchParamCreator(configuration).gruposAgendamentoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoPartialUpdate(body: GrupoDeDefensoriasParaAgendamento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GrupoDeDefensoriasParaAgendamento> {
            const localVarFetchArgs = GruposAgendamentoApiFetchParamCreator(configuration).gruposAgendamentoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GrupoDeDefensoriasParaAgendamento> {
            const localVarFetchArgs = GruposAgendamentoApiFetchParamCreator(configuration).gruposAgendamentoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoUpdate(body: GrupoDeDefensoriasParaAgendamento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GrupoDeDefensoriasParaAgendamento> {
            const localVarFetchArgs = GruposAgendamentoApiFetchParamCreator(configuration).gruposAgendamentoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GruposAgendamentoApi - factory interface
 * @export
 */
export const GruposAgendamentoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoCreate(body: GrupoDeDefensoriasParaAgendamento, options?: any) {
            return GruposAgendamentoApiFp(configuration).gruposAgendamentoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoDelete(id: number, options?: any) {
            return GruposAgendamentoApiFp(configuration).gruposAgendamentoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoList(limit?: number, offset?: number, options?: any) {
            return GruposAgendamentoApiFp(configuration).gruposAgendamentoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoPartialUpdate(body: GrupoDeDefensoriasParaAgendamento, id: number, options?: any) {
            return GruposAgendamentoApiFp(configuration).gruposAgendamentoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoRead(id: number, options?: any) {
            return GruposAgendamentoApiFp(configuration).gruposAgendamentoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GrupoDeDefensoriasParaAgendamento} body 
         * @param {number} id A unique integer value identifying this Grupo de Agendamento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gruposAgendamentoUpdate(body: GrupoDeDefensoriasParaAgendamento, id: number, options?: any) {
            return GruposAgendamentoApiFp(configuration).gruposAgendamentoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * GruposAgendamentoApi - object-oriented interface
 * @export
 * @class GruposAgendamentoApi
 * @extends {BaseAPI}
 */
export class GruposAgendamentoApi extends BaseAPI {
    /**
     * 
     * @param {GrupoDeDefensoriasParaAgendamento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GruposAgendamentoApi
     */
    public gruposAgendamentoCreate(body: GrupoDeDefensoriasParaAgendamento, options?: any) {
        return GruposAgendamentoApiFp(this.configuration).gruposAgendamentoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Grupo de Agendamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GruposAgendamentoApi
     */
    public gruposAgendamentoDelete(id: number, options?: any) {
        return GruposAgendamentoApiFp(this.configuration).gruposAgendamentoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GruposAgendamentoApi
     */
    public gruposAgendamentoList(limit?: number, offset?: number, options?: any) {
        return GruposAgendamentoApiFp(this.configuration).gruposAgendamentoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {GrupoDeDefensoriasParaAgendamento} body 
     * @param {number} id A unique integer value identifying this Grupo de Agendamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GruposAgendamentoApi
     */
    public gruposAgendamentoPartialUpdate(body: GrupoDeDefensoriasParaAgendamento, id: number, options?: any) {
        return GruposAgendamentoApiFp(this.configuration).gruposAgendamentoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Grupo de Agendamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GruposAgendamentoApi
     */
    public gruposAgendamentoRead(id: number, options?: any) {
        return GruposAgendamentoApiFp(this.configuration).gruposAgendamentoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {GrupoDeDefensoriasParaAgendamento} body 
     * @param {number} id A unique integer value identifying this Grupo de Agendamento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GruposAgendamentoApi
     */
    public gruposAgendamentoUpdate(body: GrupoDeDefensoriasParaAgendamento, id: number, options?: any) {
        return GruposAgendamentoApiFp(this.configuration).gruposAgendamentoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * GuichesApi - fetch parameter creator
 * @export
 */
export const GuichesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Guiche} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesCreate(body: Guiche, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling guichesCreate.');
            }
            const localVarPath = `/guiches/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Guiche" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling guichesDelete.');
            }
            const localVarPath = `/guiches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/guiches/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Guiche} body 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesPartialUpdate(body: Guiche, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling guichesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling guichesPartialUpdate.');
            }
            const localVarPath = `/guiches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Guiche" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling guichesRead.');
            }
            const localVarPath = `/guiches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Guiche} body 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesUpdate(body: Guiche, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling guichesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling guichesUpdate.');
            }
            const localVarPath = `/guiches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Guiche" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuichesApi - functional programming interface
 * @export
 */
export const GuichesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Guiche} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesCreate(body: Guiche, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Guiche> {
            const localVarFetchArgs = GuichesApiFetchParamCreator(configuration).guichesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GuichesApiFetchParamCreator(configuration).guichesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20057> {
            const localVarFetchArgs = GuichesApiFetchParamCreator(configuration).guichesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Guiche} body 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesPartialUpdate(body: Guiche, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Guiche> {
            const localVarFetchArgs = GuichesApiFetchParamCreator(configuration).guichesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Guiche> {
            const localVarFetchArgs = GuichesApiFetchParamCreator(configuration).guichesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Guiche} body 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesUpdate(body: Guiche, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Guiche> {
            const localVarFetchArgs = GuichesApiFetchParamCreator(configuration).guichesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GuichesApi - factory interface
 * @export
 */
export const GuichesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Guiche} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesCreate(body: Guiche, options?: any) {
            return GuichesApiFp(configuration).guichesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesDelete(id: number, options?: any) {
            return GuichesApiFp(configuration).guichesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesList(limit?: number, offset?: number, options?: any) {
            return GuichesApiFp(configuration).guichesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Guiche} body 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesPartialUpdate(body: Guiche, id: number, options?: any) {
            return GuichesApiFp(configuration).guichesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesRead(id: number, options?: any) {
            return GuichesApiFp(configuration).guichesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Guiche} body 
         * @param {number} id A unique integer value identifying this Guichê.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guichesUpdate(body: Guiche, id: number, options?: any) {
            return GuichesApiFp(configuration).guichesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * GuichesApi - object-oriented interface
 * @export
 * @class GuichesApi
 * @extends {BaseAPI}
 */
export class GuichesApi extends BaseAPI {
    /**
     * 
     * @param {Guiche} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuichesApi
     */
    public guichesCreate(body: Guiche, options?: any) {
        return GuichesApiFp(this.configuration).guichesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Guichê.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuichesApi
     */
    public guichesDelete(id: number, options?: any) {
        return GuichesApiFp(this.configuration).guichesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuichesApi
     */
    public guichesList(limit?: number, offset?: number, options?: any) {
        return GuichesApiFp(this.configuration).guichesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Guiche} body 
     * @param {number} id A unique integer value identifying this Guichê.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuichesApi
     */
    public guichesPartialUpdate(body: Guiche, id: number, options?: any) {
        return GuichesApiFp(this.configuration).guichesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Guichê.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuichesApi
     */
    public guichesRead(id: number, options?: any) {
        return GuichesApiFp(this.configuration).guichesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Guiche} body 
     * @param {number} id A unique integer value identifying this Guichê.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuichesApi
     */
    public guichesUpdate(body: Guiche, id: number, options?: any) {
        return GuichesApiFp(this.configuration).guichesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * HistoricosApi - fetch parameter creator
 * @export
 */
export const HistoricosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Historico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosCreate(body: Historico, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling historicosCreate.');
            }
            const localVarPath = `/historicos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Historico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling historicosDelete.');
            }
            const localVarPath = `/historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/historicos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Historico} body 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosPartialUpdate(body: Historico, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling historicosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling historicosPartialUpdate.');
            }
            const localVarPath = `/historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Historico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling historicosRead.');
            }
            const localVarPath = `/historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Historico} body 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosUpdate(body: Historico, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling historicosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling historicosUpdate.');
            }
            const localVarPath = `/historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Historico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoricosApi - functional programming interface
 * @export
 */
export const HistoricosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Historico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosCreate(body: Historico, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Historico> {
            const localVarFetchArgs = HistoricosApiFetchParamCreator(configuration).historicosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HistoricosApiFetchParamCreator(configuration).historicosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20059> {
            const localVarFetchArgs = HistoricosApiFetchParamCreator(configuration).historicosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Historico} body 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosPartialUpdate(body: Historico, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Historico> {
            const localVarFetchArgs = HistoricosApiFetchParamCreator(configuration).historicosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Historico> {
            const localVarFetchArgs = HistoricosApiFetchParamCreator(configuration).historicosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Historico} body 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosUpdate(body: Historico, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Historico> {
            const localVarFetchArgs = HistoricosApiFetchParamCreator(configuration).historicosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HistoricosApi - factory interface
 * @export
 */
export const HistoricosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Historico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosCreate(body: Historico, options?: any) {
            return HistoricosApiFp(configuration).historicosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosDelete(id: number, options?: any) {
            return HistoricosApiFp(configuration).historicosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosList(limit?: number, offset?: number, options?: any) {
            return HistoricosApiFp(configuration).historicosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Historico} body 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosPartialUpdate(body: Historico, id: number, options?: any) {
            return HistoricosApiFp(configuration).historicosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosRead(id: number, options?: any) {
            return HistoricosApiFp(configuration).historicosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Historico} body 
         * @param {number} id A unique integer value identifying this Histórico.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosUpdate(body: Historico, id: number, options?: any) {
            return HistoricosApiFp(configuration).historicosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * HistoricosApi - object-oriented interface
 * @export
 * @class HistoricosApi
 * @extends {BaseAPI}
 */
export class HistoricosApi extends BaseAPI {
    /**
     * 
     * @param {Historico} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosApi
     */
    public historicosCreate(body: Historico, options?: any) {
        return HistoricosApiFp(this.configuration).historicosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Histórico.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosApi
     */
    public historicosDelete(id: number, options?: any) {
        return HistoricosApiFp(this.configuration).historicosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosApi
     */
    public historicosList(limit?: number, offset?: number, options?: any) {
        return HistoricosApiFp(this.configuration).historicosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Historico} body 
     * @param {number} id A unique integer value identifying this Histórico.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosApi
     */
    public historicosPartialUpdate(body: Historico, id: number, options?: any) {
        return HistoricosApiFp(this.configuration).historicosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Histórico.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosApi
     */
    public historicosRead(id: number, options?: any) {
        return HistoricosApiFp(this.configuration).historicosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Historico} body 
     * @param {number} id A unique integer value identifying this Histórico.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosApi
     */
    public historicosUpdate(body: Historico, id: number, options?: any) {
        return HistoricosApiFp(this.configuration).historicosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * HistoricosTransferenciasPartesApi - fetch parameter creator
 * @export
 */
export const HistoricosTransferenciasPartesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesCreate(body: ParteHistoricoTransferencia, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling historicosTransferenciasPartesCreate.');
            }
            const localVarPath = `/historicos-transferencias-partes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteHistoricoTransferencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling historicosTransferenciasPartesDelete.');
            }
            const localVarPath = `/historicos-transferencias-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/historicos-transferencias-partes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesPartialUpdate(body: ParteHistoricoTransferencia, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling historicosTransferenciasPartesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling historicosTransferenciasPartesPartialUpdate.');
            }
            const localVarPath = `/historicos-transferencias-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteHistoricoTransferencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling historicosTransferenciasPartesRead.');
            }
            const localVarPath = `/historicos-transferencias-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesUpdate(body: ParteHistoricoTransferencia, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling historicosTransferenciasPartesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling historicosTransferenciasPartesUpdate.');
            }
            const localVarPath = `/historicos-transferencias-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteHistoricoTransferencia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoricosTransferenciasPartesApi - functional programming interface
 * @export
 */
export const HistoricosTransferenciasPartesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesCreate(body: ParteHistoricoTransferencia, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteHistoricoTransferencia> {
            const localVarFetchArgs = HistoricosTransferenciasPartesApiFetchParamCreator(configuration).historicosTransferenciasPartesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HistoricosTransferenciasPartesApiFetchParamCreator(configuration).historicosTransferenciasPartesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20058> {
            const localVarFetchArgs = HistoricosTransferenciasPartesApiFetchParamCreator(configuration).historicosTransferenciasPartesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesPartialUpdate(body: ParteHistoricoTransferencia, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteHistoricoTransferencia> {
            const localVarFetchArgs = HistoricosTransferenciasPartesApiFetchParamCreator(configuration).historicosTransferenciasPartesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteHistoricoTransferencia> {
            const localVarFetchArgs = HistoricosTransferenciasPartesApiFetchParamCreator(configuration).historicosTransferenciasPartesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesUpdate(body: ParteHistoricoTransferencia, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteHistoricoTransferencia> {
            const localVarFetchArgs = HistoricosTransferenciasPartesApiFetchParamCreator(configuration).historicosTransferenciasPartesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HistoricosTransferenciasPartesApi - factory interface
 * @export
 */
export const HistoricosTransferenciasPartesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesCreate(body: ParteHistoricoTransferencia, options?: any) {
            return HistoricosTransferenciasPartesApiFp(configuration).historicosTransferenciasPartesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesDelete(id: number, options?: any) {
            return HistoricosTransferenciasPartesApiFp(configuration).historicosTransferenciasPartesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesList(limit?: number, offset?: number, options?: any) {
            return HistoricosTransferenciasPartesApiFp(configuration).historicosTransferenciasPartesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesPartialUpdate(body: ParteHistoricoTransferencia, id: number, options?: any) {
            return HistoricosTransferenciasPartesApiFp(configuration).historicosTransferenciasPartesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesRead(id: number, options?: any) {
            return HistoricosTransferenciasPartesApiFp(configuration).historicosTransferenciasPartesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ParteHistoricoTransferencia} body 
         * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicosTransferenciasPartesUpdate(body: ParteHistoricoTransferencia, id: number, options?: any) {
            return HistoricosTransferenciasPartesApiFp(configuration).historicosTransferenciasPartesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * HistoricosTransferenciasPartesApi - object-oriented interface
 * @export
 * @class HistoricosTransferenciasPartesApi
 * @extends {BaseAPI}
 */
export class HistoricosTransferenciasPartesApi extends BaseAPI {
    /**
     * 
     * @param {ParteHistoricoTransferencia} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosTransferenciasPartesApi
     */
    public historicosTransferenciasPartesCreate(body: ParteHistoricoTransferencia, options?: any) {
        return HistoricosTransferenciasPartesApiFp(this.configuration).historicosTransferenciasPartesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosTransferenciasPartesApi
     */
    public historicosTransferenciasPartesDelete(id: number, options?: any) {
        return HistoricosTransferenciasPartesApiFp(this.configuration).historicosTransferenciasPartesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosTransferenciasPartesApi
     */
    public historicosTransferenciasPartesList(limit?: number, offset?: number, options?: any) {
        return HistoricosTransferenciasPartesApiFp(this.configuration).historicosTransferenciasPartesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ParteHistoricoTransferencia} body 
     * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosTransferenciasPartesApi
     */
    public historicosTransferenciasPartesPartialUpdate(body: ParteHistoricoTransferencia, id: number, options?: any) {
        return HistoricosTransferenciasPartesApiFp(this.configuration).historicosTransferenciasPartesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosTransferenciasPartesApi
     */
    public historicosTransferenciasPartesRead(id: number, options?: any) {
        return HistoricosTransferenciasPartesApiFp(this.configuration).historicosTransferenciasPartesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ParteHistoricoTransferencia} body 
     * @param {number} id A unique integer value identifying this Historico de Transferencia de Parte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricosTransferenciasPartesApi
     */
    public historicosTransferenciasPartesUpdate(body: ParteHistoricoTransferencia, id: number, options?: any) {
        return HistoricosTransferenciasPartesApiFp(this.configuration).historicosTransferenciasPartesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * HonorariosApi - fetch parameter creator
 * @export
 */
export const HonorariosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Honorario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosCreate(body: Honorario, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosCreate.');
            }
            const localVarPath = `/honorarios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Honorario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosDelete.');
            }
            const localVarPath = `/honorarios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/honorarios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Honorario} body 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosPartialUpdate(body: Honorario, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosPartialUpdate.');
            }
            const localVarPath = `/honorarios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Honorario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosRead.');
            }
            const localVarPath = `/honorarios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Honorario} body 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosUpdate(body: Honorario, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosUpdate.');
            }
            const localVarPath = `/honorarios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Honorario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HonorariosApi - functional programming interface
 * @export
 */
export const HonorariosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Honorario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosCreate(body: Honorario, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Honorario> {
            const localVarFetchArgs = HonorariosApiFetchParamCreator(configuration).honorariosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HonorariosApiFetchParamCreator(configuration).honorariosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20064> {
            const localVarFetchArgs = HonorariosApiFetchParamCreator(configuration).honorariosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Honorario} body 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosPartialUpdate(body: Honorario, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Honorario> {
            const localVarFetchArgs = HonorariosApiFetchParamCreator(configuration).honorariosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Honorario> {
            const localVarFetchArgs = HonorariosApiFetchParamCreator(configuration).honorariosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Honorario} body 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosUpdate(body: Honorario, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Honorario> {
            const localVarFetchArgs = HonorariosApiFetchParamCreator(configuration).honorariosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HonorariosApi - factory interface
 * @export
 */
export const HonorariosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Honorario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosCreate(body: Honorario, options?: any) {
            return HonorariosApiFp(configuration).honorariosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDelete(id: number, options?: any) {
            return HonorariosApiFp(configuration).honorariosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosList(limit?: number, offset?: number, options?: any) {
            return HonorariosApiFp(configuration).honorariosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Honorario} body 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosPartialUpdate(body: Honorario, id: number, options?: any) {
            return HonorariosApiFp(configuration).honorariosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosRead(id: number, options?: any) {
            return HonorariosApiFp(configuration).honorariosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Honorario} body 
         * @param {number} id A unique integer value identifying this Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosUpdate(body: Honorario, id: number, options?: any) {
            return HonorariosApiFp(configuration).honorariosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * HonorariosApi - object-oriented interface
 * @export
 * @class HonorariosApi
 * @extends {BaseAPI}
 */
export class HonorariosApi extends BaseAPI {
    /**
     * 
     * @param {Honorario} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosApi
     */
    public honorariosCreate(body: Honorario, options?: any) {
        return HonorariosApiFp(this.configuration).honorariosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Honoráio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosApi
     */
    public honorariosDelete(id: number, options?: any) {
        return HonorariosApiFp(this.configuration).honorariosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosApi
     */
    public honorariosList(limit?: number, offset?: number, options?: any) {
        return HonorariosApiFp(this.configuration).honorariosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Honorario} body 
     * @param {number} id A unique integer value identifying this Honoráio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosApi
     */
    public honorariosPartialUpdate(body: Honorario, id: number, options?: any) {
        return HonorariosApiFp(this.configuration).honorariosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Honoráio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosApi
     */
    public honorariosRead(id: number, options?: any) {
        return HonorariosApiFp(this.configuration).honorariosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Honorario} body 
     * @param {number} id A unique integer value identifying this Honoráio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosApi
     */
    public honorariosUpdate(body: Honorario, id: number, options?: any) {
        return HonorariosApiFp(this.configuration).honorariosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * HonorariosAlertasDeMovimentacoesApi - fetch parameter creator
 * @export
 */
export const HonorariosAlertasDeMovimentacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesCreate(body: AlertaProcessoMovimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosAlertasDeMovimentacoesCreate.');
            }
            const localVarPath = `/honorarios-alertas-de-movimentacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlertaProcessoMovimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosAlertasDeMovimentacoesDelete.');
            }
            const localVarPath = `/honorarios-alertas-de-movimentacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/honorarios-alertas-de-movimentacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesPartialUpdate(body: AlertaProcessoMovimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosAlertasDeMovimentacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosAlertasDeMovimentacoesPartialUpdate.');
            }
            const localVarPath = `/honorarios-alertas-de-movimentacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlertaProcessoMovimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosAlertasDeMovimentacoesRead.');
            }
            const localVarPath = `/honorarios-alertas-de-movimentacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesUpdate(body: AlertaProcessoMovimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosAlertasDeMovimentacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosAlertasDeMovimentacoesUpdate.');
            }
            const localVarPath = `/honorarios-alertas-de-movimentacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlertaProcessoMovimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HonorariosAlertasDeMovimentacoesApi - functional programming interface
 * @export
 */
export const HonorariosAlertasDeMovimentacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesCreate(body: AlertaProcessoMovimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertaProcessoMovimento> {
            const localVarFetchArgs = HonorariosAlertasDeMovimentacoesApiFetchParamCreator(configuration).honorariosAlertasDeMovimentacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HonorariosAlertasDeMovimentacoesApiFetchParamCreator(configuration).honorariosAlertasDeMovimentacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20060> {
            const localVarFetchArgs = HonorariosAlertasDeMovimentacoesApiFetchParamCreator(configuration).honorariosAlertasDeMovimentacoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesPartialUpdate(body: AlertaProcessoMovimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertaProcessoMovimento> {
            const localVarFetchArgs = HonorariosAlertasDeMovimentacoesApiFetchParamCreator(configuration).honorariosAlertasDeMovimentacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertaProcessoMovimento> {
            const localVarFetchArgs = HonorariosAlertasDeMovimentacoesApiFetchParamCreator(configuration).honorariosAlertasDeMovimentacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesUpdate(body: AlertaProcessoMovimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertaProcessoMovimento> {
            const localVarFetchArgs = HonorariosAlertasDeMovimentacoesApiFetchParamCreator(configuration).honorariosAlertasDeMovimentacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HonorariosAlertasDeMovimentacoesApi - factory interface
 * @export
 */
export const HonorariosAlertasDeMovimentacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesCreate(body: AlertaProcessoMovimento, options?: any) {
            return HonorariosAlertasDeMovimentacoesApiFp(configuration).honorariosAlertasDeMovimentacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesDelete(id: number, options?: any) {
            return HonorariosAlertasDeMovimentacoesApiFp(configuration).honorariosAlertasDeMovimentacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesList(limit?: number, offset?: number, options?: any) {
            return HonorariosAlertasDeMovimentacoesApiFp(configuration).honorariosAlertasDeMovimentacoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesPartialUpdate(body: AlertaProcessoMovimento, id: number, options?: any) {
            return HonorariosAlertasDeMovimentacoesApiFp(configuration).honorariosAlertasDeMovimentacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesRead(id: number, options?: any) {
            return HonorariosAlertasDeMovimentacoesApiFp(configuration).honorariosAlertasDeMovimentacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AlertaProcessoMovimento} body 
         * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAlertasDeMovimentacoesUpdate(body: AlertaProcessoMovimento, id: number, options?: any) {
            return HonorariosAlertasDeMovimentacoesApiFp(configuration).honorariosAlertasDeMovimentacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * HonorariosAlertasDeMovimentacoesApi - object-oriented interface
 * @export
 * @class HonorariosAlertasDeMovimentacoesApi
 * @extends {BaseAPI}
 */
export class HonorariosAlertasDeMovimentacoesApi extends BaseAPI {
    /**
     * 
     * @param {AlertaProcessoMovimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAlertasDeMovimentacoesApi
     */
    public honorariosAlertasDeMovimentacoesCreate(body: AlertaProcessoMovimento, options?: any) {
        return HonorariosAlertasDeMovimentacoesApiFp(this.configuration).honorariosAlertasDeMovimentacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAlertasDeMovimentacoesApi
     */
    public honorariosAlertasDeMovimentacoesDelete(id: number, options?: any) {
        return HonorariosAlertasDeMovimentacoesApiFp(this.configuration).honorariosAlertasDeMovimentacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAlertasDeMovimentacoesApi
     */
    public honorariosAlertasDeMovimentacoesList(limit?: number, offset?: number, options?: any) {
        return HonorariosAlertasDeMovimentacoesApiFp(this.configuration).honorariosAlertasDeMovimentacoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AlertaProcessoMovimento} body 
     * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAlertasDeMovimentacoesApi
     */
    public honorariosAlertasDeMovimentacoesPartialUpdate(body: AlertaProcessoMovimento, id: number, options?: any) {
        return HonorariosAlertasDeMovimentacoesApiFp(this.configuration).honorariosAlertasDeMovimentacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAlertasDeMovimentacoesApi
     */
    public honorariosAlertasDeMovimentacoesRead(id: number, options?: any) {
        return HonorariosAlertasDeMovimentacoesApiFp(this.configuration).honorariosAlertasDeMovimentacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AlertaProcessoMovimento} body 
     * @param {number} id A unique integer value identifying this Alerta de Movimentacao Honorario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAlertasDeMovimentacoesApi
     */
    public honorariosAlertasDeMovimentacoesUpdate(body: AlertaProcessoMovimento, id: number, options?: any) {
        return HonorariosAlertasDeMovimentacoesApiFp(this.configuration).honorariosAlertasDeMovimentacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * HonorariosAnalisesApi - fetch parameter creator
 * @export
 */
export const HonorariosAnalisesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Analise} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesCreate(body: Analise, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosAnalisesCreate.');
            }
            const localVarPath = `/honorarios-analises/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Analise" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosAnalisesDelete.');
            }
            const localVarPath = `/honorarios-analises/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/honorarios-analises/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Analise} body 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesPartialUpdate(body: Analise, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosAnalisesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosAnalisesPartialUpdate.');
            }
            const localVarPath = `/honorarios-analises/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Analise" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosAnalisesRead.');
            }
            const localVarPath = `/honorarios-analises/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Analise} body 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesUpdate(body: Analise, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosAnalisesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosAnalisesUpdate.');
            }
            const localVarPath = `/honorarios-analises/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Analise" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HonorariosAnalisesApi - functional programming interface
 * @export
 */
export const HonorariosAnalisesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Analise} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesCreate(body: Analise, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Analise> {
            const localVarFetchArgs = HonorariosAnalisesApiFetchParamCreator(configuration).honorariosAnalisesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HonorariosAnalisesApiFetchParamCreator(configuration).honorariosAnalisesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20061> {
            const localVarFetchArgs = HonorariosAnalisesApiFetchParamCreator(configuration).honorariosAnalisesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Analise} body 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesPartialUpdate(body: Analise, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Analise> {
            const localVarFetchArgs = HonorariosAnalisesApiFetchParamCreator(configuration).honorariosAnalisesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Analise> {
            const localVarFetchArgs = HonorariosAnalisesApiFetchParamCreator(configuration).honorariosAnalisesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Analise} body 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesUpdate(body: Analise, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Analise> {
            const localVarFetchArgs = HonorariosAnalisesApiFetchParamCreator(configuration).honorariosAnalisesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HonorariosAnalisesApi - factory interface
 * @export
 */
export const HonorariosAnalisesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Analise} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesCreate(body: Analise, options?: any) {
            return HonorariosAnalisesApiFp(configuration).honorariosAnalisesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesDelete(id: number, options?: any) {
            return HonorariosAnalisesApiFp(configuration).honorariosAnalisesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesList(limit?: number, offset?: number, options?: any) {
            return HonorariosAnalisesApiFp(configuration).honorariosAnalisesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Analise} body 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesPartialUpdate(body: Analise, id: number, options?: any) {
            return HonorariosAnalisesApiFp(configuration).honorariosAnalisesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesRead(id: number, options?: any) {
            return HonorariosAnalisesApiFp(configuration).honorariosAnalisesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Analise} body 
         * @param {number} id A unique integer value identifying this Análise de Honorário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosAnalisesUpdate(body: Analise, id: number, options?: any) {
            return HonorariosAnalisesApiFp(configuration).honorariosAnalisesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * HonorariosAnalisesApi - object-oriented interface
 * @export
 * @class HonorariosAnalisesApi
 * @extends {BaseAPI}
 */
export class HonorariosAnalisesApi extends BaseAPI {
    /**
     * 
     * @param {Analise} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAnalisesApi
     */
    public honorariosAnalisesCreate(body: Analise, options?: any) {
        return HonorariosAnalisesApiFp(this.configuration).honorariosAnalisesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Análise de Honorário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAnalisesApi
     */
    public honorariosAnalisesDelete(id: number, options?: any) {
        return HonorariosAnalisesApiFp(this.configuration).honorariosAnalisesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAnalisesApi
     */
    public honorariosAnalisesList(limit?: number, offset?: number, options?: any) {
        return HonorariosAnalisesApiFp(this.configuration).honorariosAnalisesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Analise} body 
     * @param {number} id A unique integer value identifying this Análise de Honorário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAnalisesApi
     */
    public honorariosAnalisesPartialUpdate(body: Analise, id: number, options?: any) {
        return HonorariosAnalisesApiFp(this.configuration).honorariosAnalisesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Análise de Honorário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAnalisesApi
     */
    public honorariosAnalisesRead(id: number, options?: any) {
        return HonorariosAnalisesApiFp(this.configuration).honorariosAnalisesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Analise} body 
     * @param {number} id A unique integer value identifying this Análise de Honorário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosAnalisesApi
     */
    public honorariosAnalisesUpdate(body: Analise, id: number, options?: any) {
        return HonorariosAnalisesApiFp(this.configuration).honorariosAnalisesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * HonorariosDocumentosApi - fetch parameter creator
 * @export
 */
export const HonorariosDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosCreate(body: HonorariosDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosDocumentosCreate.');
            }
            const localVarPath = `/honorarios-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HonorariosDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosDocumentosDelete.');
            }
            const localVarPath = `/honorarios-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/honorarios-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosPartialUpdate(body: HonorariosDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosDocumentosPartialUpdate.');
            }
            const localVarPath = `/honorarios-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HonorariosDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosDocumentosRead.');
            }
            const localVarPath = `/honorarios-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosUpdate(body: HonorariosDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosDocumentosUpdate.');
            }
            const localVarPath = `/honorarios-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HonorariosDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HonorariosDocumentosApi - functional programming interface
 * @export
 */
export const HonorariosDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosCreate(body: HonorariosDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HonorariosDocumento> {
            const localVarFetchArgs = HonorariosDocumentosApiFetchParamCreator(configuration).honorariosDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HonorariosDocumentosApiFetchParamCreator(configuration).honorariosDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20062> {
            const localVarFetchArgs = HonorariosDocumentosApiFetchParamCreator(configuration).honorariosDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosPartialUpdate(body: HonorariosDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HonorariosDocumento> {
            const localVarFetchArgs = HonorariosDocumentosApiFetchParamCreator(configuration).honorariosDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HonorariosDocumento> {
            const localVarFetchArgs = HonorariosDocumentosApiFetchParamCreator(configuration).honorariosDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosUpdate(body: HonorariosDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HonorariosDocumento> {
            const localVarFetchArgs = HonorariosDocumentosApiFetchParamCreator(configuration).honorariosDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HonorariosDocumentosApi - factory interface
 * @export
 */
export const HonorariosDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosCreate(body: HonorariosDocumento, options?: any) {
            return HonorariosDocumentosApiFp(configuration).honorariosDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosDelete(id: number, options?: any) {
            return HonorariosDocumentosApiFp(configuration).honorariosDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosList(limit?: number, offset?: number, options?: any) {
            return HonorariosDocumentosApiFp(configuration).honorariosDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosPartialUpdate(body: HonorariosDocumento, id: number, options?: any) {
            return HonorariosDocumentosApiFp(configuration).honorariosDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosRead(id: number, options?: any) {
            return HonorariosDocumentosApiFp(configuration).honorariosDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {HonorariosDocumento} body 
         * @param {number} id A unique integer value identifying this Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosDocumentosUpdate(body: HonorariosDocumento, id: number, options?: any) {
            return HonorariosDocumentosApiFp(configuration).honorariosDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * HonorariosDocumentosApi - object-oriented interface
 * @export
 * @class HonorariosDocumentosApi
 * @extends {BaseAPI}
 */
export class HonorariosDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {HonorariosDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosDocumentosApi
     */
    public honorariosDocumentosCreate(body: HonorariosDocumento, options?: any) {
        return HonorariosDocumentosApiFp(this.configuration).honorariosDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosDocumentosApi
     */
    public honorariosDocumentosDelete(id: number, options?: any) {
        return HonorariosDocumentosApiFp(this.configuration).honorariosDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosDocumentosApi
     */
    public honorariosDocumentosList(limit?: number, offset?: number, options?: any) {
        return HonorariosDocumentosApiFp(this.configuration).honorariosDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {HonorariosDocumento} body 
     * @param {number} id A unique integer value identifying this Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosDocumentosApi
     */
    public honorariosDocumentosPartialUpdate(body: HonorariosDocumento, id: number, options?: any) {
        return HonorariosDocumentosApiFp(this.configuration).honorariosDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosDocumentosApi
     */
    public honorariosDocumentosRead(id: number, options?: any) {
        return HonorariosDocumentosApiFp(this.configuration).honorariosDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {HonorariosDocumento} body 
     * @param {number} id A unique integer value identifying this Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosDocumentosApi
     */
    public honorariosDocumentosUpdate(body: HonorariosDocumento, id: number, options?: any) {
        return HonorariosDocumentosApiFp(this.configuration).honorariosDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * HonorariosMovimentosApi - fetch parameter creator
 * @export
 */
export const HonorariosMovimentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Movimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosCreate(body: Movimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosMovimentosCreate.');
            }
            const localVarPath = `/honorarios-movimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Movimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosMovimentosDelete.');
            }
            const localVarPath = `/honorarios-movimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/honorarios-movimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Movimento} body 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosPartialUpdate(body: Movimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosMovimentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosMovimentosPartialUpdate.');
            }
            const localVarPath = `/honorarios-movimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Movimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosMovimentosRead.');
            }
            const localVarPath = `/honorarios-movimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Movimento} body 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosUpdate(body: Movimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling honorariosMovimentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling honorariosMovimentosUpdate.');
            }
            const localVarPath = `/honorarios-movimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Movimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HonorariosMovimentosApi - functional programming interface
 * @export
 */
export const HonorariosMovimentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Movimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosCreate(body: Movimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Movimento> {
            const localVarFetchArgs = HonorariosMovimentosApiFetchParamCreator(configuration).honorariosMovimentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HonorariosMovimentosApiFetchParamCreator(configuration).honorariosMovimentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20063> {
            const localVarFetchArgs = HonorariosMovimentosApiFetchParamCreator(configuration).honorariosMovimentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Movimento} body 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosPartialUpdate(body: Movimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Movimento> {
            const localVarFetchArgs = HonorariosMovimentosApiFetchParamCreator(configuration).honorariosMovimentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Movimento> {
            const localVarFetchArgs = HonorariosMovimentosApiFetchParamCreator(configuration).honorariosMovimentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Movimento} body 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosUpdate(body: Movimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Movimento> {
            const localVarFetchArgs = HonorariosMovimentosApiFetchParamCreator(configuration).honorariosMovimentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HonorariosMovimentosApi - factory interface
 * @export
 */
export const HonorariosMovimentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Movimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosCreate(body: Movimento, options?: any) {
            return HonorariosMovimentosApiFp(configuration).honorariosMovimentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosDelete(id: number, options?: any) {
            return HonorariosMovimentosApiFp(configuration).honorariosMovimentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosList(limit?: number, offset?: number, options?: any) {
            return HonorariosMovimentosApiFp(configuration).honorariosMovimentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Movimento} body 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosPartialUpdate(body: Movimento, id: number, options?: any) {
            return HonorariosMovimentosApiFp(configuration).honorariosMovimentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosRead(id: number, options?: any) {
            return HonorariosMovimentosApiFp(configuration).honorariosMovimentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Movimento} body 
         * @param {number} id A unique integer value identifying this Movimento Honoráio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        honorariosMovimentosUpdate(body: Movimento, id: number, options?: any) {
            return HonorariosMovimentosApiFp(configuration).honorariosMovimentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * HonorariosMovimentosApi - object-oriented interface
 * @export
 * @class HonorariosMovimentosApi
 * @extends {BaseAPI}
 */
export class HonorariosMovimentosApi extends BaseAPI {
    /**
     * 
     * @param {Movimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosMovimentosApi
     */
    public honorariosMovimentosCreate(body: Movimento, options?: any) {
        return HonorariosMovimentosApiFp(this.configuration).honorariosMovimentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Movimento Honoráio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosMovimentosApi
     */
    public honorariosMovimentosDelete(id: number, options?: any) {
        return HonorariosMovimentosApiFp(this.configuration).honorariosMovimentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosMovimentosApi
     */
    public honorariosMovimentosList(limit?: number, offset?: number, options?: any) {
        return HonorariosMovimentosApiFp(this.configuration).honorariosMovimentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Movimento} body 
     * @param {number} id A unique integer value identifying this Movimento Honoráio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosMovimentosApi
     */
    public honorariosMovimentosPartialUpdate(body: Movimento, id: number, options?: any) {
        return HonorariosMovimentosApiFp(this.configuration).honorariosMovimentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Movimento Honoráio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosMovimentosApi
     */
    public honorariosMovimentosRead(id: number, options?: any) {
        return HonorariosMovimentosApiFp(this.configuration).honorariosMovimentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Movimento} body 
     * @param {number} id A unique integer value identifying this Movimento Honoráio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HonorariosMovimentosApi
     */
    public honorariosMovimentosUpdate(body: Movimento, id: number, options?: any) {
        return HonorariosMovimentosApiFp(this.configuration).honorariosMovimentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * IdentidadesGeneroApi - fetch parameter creator
 * @export
 */
export const IdentidadesGeneroApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroCreate(body: IdentidadeGenero, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling identidadesGeneroCreate.');
            }
            const localVarPath = `/identidades-genero/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdentidadeGenero" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling identidadesGeneroDelete.');
            }
            const localVarPath = `/identidades-genero/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/identidades-genero/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroPartialUpdate(body: IdentidadeGenero, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling identidadesGeneroPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling identidadesGeneroPartialUpdate.');
            }
            const localVarPath = `/identidades-genero/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdentidadeGenero" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling identidadesGeneroRead.');
            }
            const localVarPath = `/identidades-genero/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroUpdate(body: IdentidadeGenero, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling identidadesGeneroUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling identidadesGeneroUpdate.');
            }
            const localVarPath = `/identidades-genero/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdentidadeGenero" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentidadesGeneroApi - functional programming interface
 * @export
 */
export const IdentidadesGeneroApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroCreate(body: IdentidadeGenero, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IdentidadeGenero> {
            const localVarFetchArgs = IdentidadesGeneroApiFetchParamCreator(configuration).identidadesGeneroCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IdentidadesGeneroApiFetchParamCreator(configuration).identidadesGeneroDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20065> {
            const localVarFetchArgs = IdentidadesGeneroApiFetchParamCreator(configuration).identidadesGeneroList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroPartialUpdate(body: IdentidadeGenero, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IdentidadeGenero> {
            const localVarFetchArgs = IdentidadesGeneroApiFetchParamCreator(configuration).identidadesGeneroPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IdentidadeGenero> {
            const localVarFetchArgs = IdentidadesGeneroApiFetchParamCreator(configuration).identidadesGeneroRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroUpdate(body: IdentidadeGenero, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IdentidadeGenero> {
            const localVarFetchArgs = IdentidadesGeneroApiFetchParamCreator(configuration).identidadesGeneroUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IdentidadesGeneroApi - factory interface
 * @export
 */
export const IdentidadesGeneroApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroCreate(body: IdentidadeGenero, options?: any) {
            return IdentidadesGeneroApiFp(configuration).identidadesGeneroCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroDelete(id: number, options?: any) {
            return IdentidadesGeneroApiFp(configuration).identidadesGeneroDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroList(limit?: number, offset?: number, options?: any) {
            return IdentidadesGeneroApiFp(configuration).identidadesGeneroList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroPartialUpdate(body: IdentidadeGenero, id: number, options?: any) {
            return IdentidadesGeneroApiFp(configuration).identidadesGeneroPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroRead(id: number, options?: any) {
            return IdentidadesGeneroApiFp(configuration).identidadesGeneroRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {IdentidadeGenero} body 
         * @param {number} id A unique integer value identifying this Identidade de Gênero.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identidadesGeneroUpdate(body: IdentidadeGenero, id: number, options?: any) {
            return IdentidadesGeneroApiFp(configuration).identidadesGeneroUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * IdentidadesGeneroApi - object-oriented interface
 * @export
 * @class IdentidadesGeneroApi
 * @extends {BaseAPI}
 */
export class IdentidadesGeneroApi extends BaseAPI {
    /**
     * 
     * @param {IdentidadeGenero} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentidadesGeneroApi
     */
    public identidadesGeneroCreate(body: IdentidadeGenero, options?: any) {
        return IdentidadesGeneroApiFp(this.configuration).identidadesGeneroCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Identidade de Gênero.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentidadesGeneroApi
     */
    public identidadesGeneroDelete(id: number, options?: any) {
        return IdentidadesGeneroApiFp(this.configuration).identidadesGeneroDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentidadesGeneroApi
     */
    public identidadesGeneroList(limit?: number, offset?: number, options?: any) {
        return IdentidadesGeneroApiFp(this.configuration).identidadesGeneroList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {IdentidadeGenero} body 
     * @param {number} id A unique integer value identifying this Identidade de Gênero.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentidadesGeneroApi
     */
    public identidadesGeneroPartialUpdate(body: IdentidadeGenero, id: number, options?: any) {
        return IdentidadesGeneroApiFp(this.configuration).identidadesGeneroPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Identidade de Gênero.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentidadesGeneroApi
     */
    public identidadesGeneroRead(id: number, options?: any) {
        return IdentidadesGeneroApiFp(this.configuration).identidadesGeneroRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {IdentidadeGenero} body 
     * @param {number} id A unique integer value identifying this Identidade de Gênero.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentidadesGeneroApi
     */
    public identidadesGeneroUpdate(body: IdentidadeGenero, id: number, options?: any) {
        return IdentidadesGeneroApiFp(this.configuration).identidadesGeneroUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ImoveisApi - fetch parameter creator
 * @export
 */
export const ImoveisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Imovel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisCreate(body: Imovel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling imoveisCreate.');
            }
            const localVarPath = `/imoveis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Imovel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling imoveisDelete.');
            }
            const localVarPath = `/imoveis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/imoveis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Imovel} body 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisPartialUpdate(body: Imovel, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling imoveisPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling imoveisPartialUpdate.');
            }
            const localVarPath = `/imoveis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Imovel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling imoveisRead.');
            }
            const localVarPath = `/imoveis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Imovel} body 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisUpdate(body: Imovel, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling imoveisUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling imoveisUpdate.');
            }
            const localVarPath = `/imoveis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Imovel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImoveisApi - functional programming interface
 * @export
 */
export const ImoveisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Imovel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisCreate(body: Imovel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Imovel> {
            const localVarFetchArgs = ImoveisApiFetchParamCreator(configuration).imoveisCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ImoveisApiFetchParamCreator(configuration).imoveisDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20066> {
            const localVarFetchArgs = ImoveisApiFetchParamCreator(configuration).imoveisList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Imovel} body 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisPartialUpdate(body: Imovel, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Imovel> {
            const localVarFetchArgs = ImoveisApiFetchParamCreator(configuration).imoveisPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Imovel> {
            const localVarFetchArgs = ImoveisApiFetchParamCreator(configuration).imoveisRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Imovel} body 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisUpdate(body: Imovel, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Imovel> {
            const localVarFetchArgs = ImoveisApiFetchParamCreator(configuration).imoveisUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ImoveisApi - factory interface
 * @export
 */
export const ImoveisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Imovel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisCreate(body: Imovel, options?: any) {
            return ImoveisApiFp(configuration).imoveisCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisDelete(id: number, options?: any) {
            return ImoveisApiFp(configuration).imoveisDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisList(limit?: number, offset?: number, options?: any) {
            return ImoveisApiFp(configuration).imoveisList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Imovel} body 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisPartialUpdate(body: Imovel, id: number, options?: any) {
            return ImoveisApiFp(configuration).imoveisPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisRead(id: number, options?: any) {
            return ImoveisApiFp(configuration).imoveisRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Imovel} body 
         * @param {number} id A unique integer value identifying this imovel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imoveisUpdate(body: Imovel, id: number, options?: any) {
            return ImoveisApiFp(configuration).imoveisUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ImoveisApi - object-oriented interface
 * @export
 * @class ImoveisApi
 * @extends {BaseAPI}
 */
export class ImoveisApi extends BaseAPI {
    /**
     * 
     * @param {Imovel} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImoveisApi
     */
    public imoveisCreate(body: Imovel, options?: any) {
        return ImoveisApiFp(this.configuration).imoveisCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this imovel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImoveisApi
     */
    public imoveisDelete(id: number, options?: any) {
        return ImoveisApiFp(this.configuration).imoveisDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImoveisApi
     */
    public imoveisList(limit?: number, offset?: number, options?: any) {
        return ImoveisApiFp(this.configuration).imoveisList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Imovel} body 
     * @param {number} id A unique integer value identifying this imovel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImoveisApi
     */
    public imoveisPartialUpdate(body: Imovel, id: number, options?: any) {
        return ImoveisApiFp(this.configuration).imoveisPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this imovel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImoveisApi
     */
    public imoveisRead(id: number, options?: any) {
        return ImoveisApiFp(this.configuration).imoveisRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Imovel} body 
     * @param {number} id A unique integer value identifying this imovel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImoveisApi
     */
    public imoveisUpdate(body: Imovel, id: number, options?: any) {
        return ImoveisApiFp(this.configuration).imoveisUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ImpedimentosApi - fetch parameter creator
 * @export
 */
export const ImpedimentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Impedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosCreate(body: Impedimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling impedimentosCreate.');
            }
            const localVarPath = `/impedimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Impedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling impedimentosDelete.');
            }
            const localVarPath = `/impedimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/impedimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Impedimento} body 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosPartialUpdate(body: Impedimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling impedimentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling impedimentosPartialUpdate.');
            }
            const localVarPath = `/impedimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Impedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling impedimentosRead.');
            }
            const localVarPath = `/impedimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Impedimento} body 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosUpdate(body: Impedimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling impedimentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling impedimentosUpdate.');
            }
            const localVarPath = `/impedimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Impedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImpedimentosApi - functional programming interface
 * @export
 */
export const ImpedimentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Impedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosCreate(body: Impedimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Impedimento> {
            const localVarFetchArgs = ImpedimentosApiFetchParamCreator(configuration).impedimentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ImpedimentosApiFetchParamCreator(configuration).impedimentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20067> {
            const localVarFetchArgs = ImpedimentosApiFetchParamCreator(configuration).impedimentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Impedimento} body 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosPartialUpdate(body: Impedimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Impedimento> {
            const localVarFetchArgs = ImpedimentosApiFetchParamCreator(configuration).impedimentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Impedimento> {
            const localVarFetchArgs = ImpedimentosApiFetchParamCreator(configuration).impedimentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Impedimento} body 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosUpdate(body: Impedimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Impedimento> {
            const localVarFetchArgs = ImpedimentosApiFetchParamCreator(configuration).impedimentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ImpedimentosApi - factory interface
 * @export
 */
export const ImpedimentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Impedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosCreate(body: Impedimento, options?: any) {
            return ImpedimentosApiFp(configuration).impedimentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosDelete(id: number, options?: any) {
            return ImpedimentosApiFp(configuration).impedimentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosList(limit?: number, offset?: number, options?: any) {
            return ImpedimentosApiFp(configuration).impedimentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Impedimento} body 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosPartialUpdate(body: Impedimento, id: number, options?: any) {
            return ImpedimentosApiFp(configuration).impedimentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosRead(id: number, options?: any) {
            return ImpedimentosApiFp(configuration).impedimentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Impedimento} body 
         * @param {number} id A unique integer value identifying this impedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impedimentosUpdate(body: Impedimento, id: number, options?: any) {
            return ImpedimentosApiFp(configuration).impedimentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ImpedimentosApi - object-oriented interface
 * @export
 * @class ImpedimentosApi
 * @extends {BaseAPI}
 */
export class ImpedimentosApi extends BaseAPI {
    /**
     * 
     * @param {Impedimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImpedimentosApi
     */
    public impedimentosCreate(body: Impedimento, options?: any) {
        return ImpedimentosApiFp(this.configuration).impedimentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this impedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImpedimentosApi
     */
    public impedimentosDelete(id: number, options?: any) {
        return ImpedimentosApiFp(this.configuration).impedimentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImpedimentosApi
     */
    public impedimentosList(limit?: number, offset?: number, options?: any) {
        return ImpedimentosApiFp(this.configuration).impedimentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Impedimento} body 
     * @param {number} id A unique integer value identifying this impedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImpedimentosApi
     */
    public impedimentosPartialUpdate(body: Impedimento, id: number, options?: any) {
        return ImpedimentosApiFp(this.configuration).impedimentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this impedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImpedimentosApi
     */
    public impedimentosRead(id: number, options?: any) {
        return ImpedimentosApiFp(this.configuration).impedimentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Impedimento} body 
     * @param {number} id A unique integer value identifying this impedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImpedimentosApi
     */
    public impedimentosUpdate(body: Impedimento, id: number, options?: any) {
        return ImpedimentosApiFp(this.configuration).impedimentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * IndeferimentosApi - fetch parameter creator
 * @export
 */
export const IndeferimentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Indeferimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosCreate(body: Indeferimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling indeferimentosCreate.');
            }
            const localVarPath = `/indeferimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Indeferimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling indeferimentosDelete.');
            }
            const localVarPath = `/indeferimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/indeferimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Indeferimento} body 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosPartialUpdate(body: Indeferimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling indeferimentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling indeferimentosPartialUpdate.');
            }
            const localVarPath = `/indeferimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Indeferimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling indeferimentosRead.');
            }
            const localVarPath = `/indeferimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Indeferimento} body 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosUpdate(body: Indeferimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling indeferimentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling indeferimentosUpdate.');
            }
            const localVarPath = `/indeferimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Indeferimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IndeferimentosApi - functional programming interface
 * @export
 */
export const IndeferimentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Indeferimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosCreate(body: Indeferimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Indeferimento> {
            const localVarFetchArgs = IndeferimentosApiFetchParamCreator(configuration).indeferimentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IndeferimentosApiFetchParamCreator(configuration).indeferimentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20068> {
            const localVarFetchArgs = IndeferimentosApiFetchParamCreator(configuration).indeferimentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Indeferimento} body 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosPartialUpdate(body: Indeferimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Indeferimento> {
            const localVarFetchArgs = IndeferimentosApiFetchParamCreator(configuration).indeferimentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Indeferimento> {
            const localVarFetchArgs = IndeferimentosApiFetchParamCreator(configuration).indeferimentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Indeferimento} body 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosUpdate(body: Indeferimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Indeferimento> {
            const localVarFetchArgs = IndeferimentosApiFetchParamCreator(configuration).indeferimentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IndeferimentosApi - factory interface
 * @export
 */
export const IndeferimentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Indeferimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosCreate(body: Indeferimento, options?: any) {
            return IndeferimentosApiFp(configuration).indeferimentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosDelete(id: number, options?: any) {
            return IndeferimentosApiFp(configuration).indeferimentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosList(limit?: number, offset?: number, options?: any) {
            return IndeferimentosApiFp(configuration).indeferimentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Indeferimento} body 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosPartialUpdate(body: Indeferimento, id: number, options?: any) {
            return IndeferimentosApiFp(configuration).indeferimentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosRead(id: number, options?: any) {
            return IndeferimentosApiFp(configuration).indeferimentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Indeferimento} body 
         * @param {number} id A unique integer value identifying this indeferimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indeferimentosUpdate(body: Indeferimento, id: number, options?: any) {
            return IndeferimentosApiFp(configuration).indeferimentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * IndeferimentosApi - object-oriented interface
 * @export
 * @class IndeferimentosApi
 * @extends {BaseAPI}
 */
export class IndeferimentosApi extends BaseAPI {
    /**
     * 
     * @param {Indeferimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndeferimentosApi
     */
    public indeferimentosCreate(body: Indeferimento, options?: any) {
        return IndeferimentosApiFp(this.configuration).indeferimentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this indeferimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndeferimentosApi
     */
    public indeferimentosDelete(id: number, options?: any) {
        return IndeferimentosApiFp(this.configuration).indeferimentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndeferimentosApi
     */
    public indeferimentosList(limit?: number, offset?: number, options?: any) {
        return IndeferimentosApiFp(this.configuration).indeferimentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Indeferimento} body 
     * @param {number} id A unique integer value identifying this indeferimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndeferimentosApi
     */
    public indeferimentosPartialUpdate(body: Indeferimento, id: number, options?: any) {
        return IndeferimentosApiFp(this.configuration).indeferimentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this indeferimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndeferimentosApi
     */
    public indeferimentosRead(id: number, options?: any) {
        return IndeferimentosApiFp(this.configuration).indeferimentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Indeferimento} body 
     * @param {number} id A unique integer value identifying this indeferimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndeferimentosApi
     */
    public indeferimentosUpdate(body: Indeferimento, id: number, options?: any) {
        return IndeferimentosApiFp(this.configuration).indeferimentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * InformacoesApi - fetch parameter creator
 * @export
 */
export const InformacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Informacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesCreate(body: Informacao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling informacoesCreate.');
            }
            const localVarPath = `/informacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Informacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling informacoesDelete.');
            }
            const localVarPath = `/informacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/informacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Informacao} body 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesPartialUpdate(body: Informacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling informacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling informacoesPartialUpdate.');
            }
            const localVarPath = `/informacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Informacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling informacoesRead.');
            }
            const localVarPath = `/informacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Informacao} body 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesUpdate(body: Informacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling informacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling informacoesUpdate.');
            }
            const localVarPath = `/informacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Informacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InformacoesApi - functional programming interface
 * @export
 */
export const InformacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Informacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesCreate(body: Informacao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Informacao> {
            const localVarFetchArgs = InformacoesApiFetchParamCreator(configuration).informacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InformacoesApiFetchParamCreator(configuration).informacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20069> {
            const localVarFetchArgs = InformacoesApiFetchParamCreator(configuration).informacoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Informacao} body 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesPartialUpdate(body: Informacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Informacao> {
            const localVarFetchArgs = InformacoesApiFetchParamCreator(configuration).informacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Informacao> {
            const localVarFetchArgs = InformacoesApiFetchParamCreator(configuration).informacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Informacao} body 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesUpdate(body: Informacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Informacao> {
            const localVarFetchArgs = InformacoesApiFetchParamCreator(configuration).informacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InformacoesApi - factory interface
 * @export
 */
export const InformacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Informacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesCreate(body: Informacao, options?: any) {
            return InformacoesApiFp(configuration).informacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesDelete(id: number, options?: any) {
            return InformacoesApiFp(configuration).informacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesList(limit?: number, offset?: number, options?: any) {
            return InformacoesApiFp(configuration).informacoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Informacao} body 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesPartialUpdate(body: Informacao, id: number, options?: any) {
            return InformacoesApiFp(configuration).informacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesRead(id: number, options?: any) {
            return InformacoesApiFp(configuration).informacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Informacao} body 
         * @param {number} id A unique integer value identifying this Informação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        informacoesUpdate(body: Informacao, id: number, options?: any) {
            return InformacoesApiFp(configuration).informacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * InformacoesApi - object-oriented interface
 * @export
 * @class InformacoesApi
 * @extends {BaseAPI}
 */
export class InformacoesApi extends BaseAPI {
    /**
     * 
     * @param {Informacao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformacoesApi
     */
    public informacoesCreate(body: Informacao, options?: any) {
        return InformacoesApiFp(this.configuration).informacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Informação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformacoesApi
     */
    public informacoesDelete(id: number, options?: any) {
        return InformacoesApiFp(this.configuration).informacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformacoesApi
     */
    public informacoesList(limit?: number, offset?: number, options?: any) {
        return InformacoesApiFp(this.configuration).informacoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Informacao} body 
     * @param {number} id A unique integer value identifying this Informação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformacoesApi
     */
    public informacoesPartialUpdate(body: Informacao, id: number, options?: any) {
        return InformacoesApiFp(this.configuration).informacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Informação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformacoesApi
     */
    public informacoesRead(id: number, options?: any) {
        return InformacoesApiFp(this.configuration).informacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Informacao} body 
     * @param {number} id A unique integer value identifying this Informação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformacoesApi
     */
    public informacoesUpdate(body: Informacao, id: number, options?: any) {
        return InformacoesApiFp(this.configuration).informacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * InterrupcoesApi - fetch parameter creator
 * @export
 */
export const InterrupcoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Interrupcao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesCreate(body: Interrupcao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling interrupcoesCreate.');
            }
            const localVarPath = `/interrupcoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Interrupcao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling interrupcoesDelete.');
            }
            const localVarPath = `/interrupcoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/interrupcoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Interrupcao} body 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesPartialUpdate(body: Interrupcao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling interrupcoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling interrupcoesPartialUpdate.');
            }
            const localVarPath = `/interrupcoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Interrupcao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling interrupcoesRead.');
            }
            const localVarPath = `/interrupcoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Interrupcao} body 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesUpdate(body: Interrupcao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling interrupcoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling interrupcoesUpdate.');
            }
            const localVarPath = `/interrupcoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Interrupcao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterrupcoesApi - functional programming interface
 * @export
 */
export const InterrupcoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Interrupcao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesCreate(body: Interrupcao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Interrupcao> {
            const localVarFetchArgs = InterrupcoesApiFetchParamCreator(configuration).interrupcoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InterrupcoesApiFetchParamCreator(configuration).interrupcoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20070> {
            const localVarFetchArgs = InterrupcoesApiFetchParamCreator(configuration).interrupcoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Interrupcao} body 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesPartialUpdate(body: Interrupcao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Interrupcao> {
            const localVarFetchArgs = InterrupcoesApiFetchParamCreator(configuration).interrupcoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Interrupcao> {
            const localVarFetchArgs = InterrupcoesApiFetchParamCreator(configuration).interrupcoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Interrupcao} body 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesUpdate(body: Interrupcao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Interrupcao> {
            const localVarFetchArgs = InterrupcoesApiFetchParamCreator(configuration).interrupcoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InterrupcoesApi - factory interface
 * @export
 */
export const InterrupcoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Interrupcao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesCreate(body: Interrupcao, options?: any) {
            return InterrupcoesApiFp(configuration).interrupcoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesDelete(id: number, options?: any) {
            return InterrupcoesApiFp(configuration).interrupcoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesList(limit?: number, offset?: number, options?: any) {
            return InterrupcoesApiFp(configuration).interrupcoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Interrupcao} body 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesPartialUpdate(body: Interrupcao, id: number, options?: any) {
            return InterrupcoesApiFp(configuration).interrupcoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesRead(id: number, options?: any) {
            return InterrupcoesApiFp(configuration).interrupcoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Interrupcao} body 
         * @param {number} id A unique integer value identifying this Interrupção.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrupcoesUpdate(body: Interrupcao, id: number, options?: any) {
            return InterrupcoesApiFp(configuration).interrupcoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * InterrupcoesApi - object-oriented interface
 * @export
 * @class InterrupcoesApi
 * @extends {BaseAPI}
 */
export class InterrupcoesApi extends BaseAPI {
    /**
     * 
     * @param {Interrupcao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterrupcoesApi
     */
    public interrupcoesCreate(body: Interrupcao, options?: any) {
        return InterrupcoesApiFp(this.configuration).interrupcoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Interrupção.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterrupcoesApi
     */
    public interrupcoesDelete(id: number, options?: any) {
        return InterrupcoesApiFp(this.configuration).interrupcoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterrupcoesApi
     */
    public interrupcoesList(limit?: number, offset?: number, options?: any) {
        return InterrupcoesApiFp(this.configuration).interrupcoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Interrupcao} body 
     * @param {number} id A unique integer value identifying this Interrupção.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterrupcoesApi
     */
    public interrupcoesPartialUpdate(body: Interrupcao, id: number, options?: any) {
        return InterrupcoesApiFp(this.configuration).interrupcoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Interrupção.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterrupcoesApi
     */
    public interrupcoesRead(id: number, options?: any) {
        return InterrupcoesApiFp(this.configuration).interrupcoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Interrupcao} body 
     * @param {number} id A unique integer value identifying this Interrupção.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterrupcoesApi
     */
    public interrupcoesUpdate(body: Interrupcao, id: number, options?: any) {
        return InterrupcoesApiFp(this.configuration).interrupcoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ItinerantesApi - fetch parameter creator
 * @export
 */
export const ItinerantesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesCreate(body: ItineranteEvento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling itinerantesCreate.');
            }
            const localVarPath = `/itinerantes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItineranteEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itinerantesDelete.');
            }
            const localVarPath = `/itinerantes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/itinerantes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesPartialUpdate(body: ItineranteEvento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling itinerantesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itinerantesPartialUpdate.');
            }
            const localVarPath = `/itinerantes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItineranteEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itinerantesRead.');
            }
            const localVarPath = `/itinerantes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesUpdate(body: ItineranteEvento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling itinerantesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itinerantesUpdate.');
            }
            const localVarPath = `/itinerantes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItineranteEvento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItinerantesApi - functional programming interface
 * @export
 */
export const ItinerantesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesCreate(body: ItineranteEvento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItineranteEvento> {
            const localVarFetchArgs = ItinerantesApiFetchParamCreator(configuration).itinerantesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ItinerantesApiFetchParamCreator(configuration).itinerantesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20071> {
            const localVarFetchArgs = ItinerantesApiFetchParamCreator(configuration).itinerantesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesPartialUpdate(body: ItineranteEvento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItineranteEvento> {
            const localVarFetchArgs = ItinerantesApiFetchParamCreator(configuration).itinerantesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItineranteEvento> {
            const localVarFetchArgs = ItinerantesApiFetchParamCreator(configuration).itinerantesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesUpdate(body: ItineranteEvento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItineranteEvento> {
            const localVarFetchArgs = ItinerantesApiFetchParamCreator(configuration).itinerantesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ItinerantesApi - factory interface
 * @export
 */
export const ItinerantesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesCreate(body: ItineranteEvento, options?: any) {
            return ItinerantesApiFp(configuration).itinerantesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesDelete(id: number, options?: any) {
            return ItinerantesApiFp(configuration).itinerantesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesList(limit?: number, offset?: number, options?: any) {
            return ItinerantesApiFp(configuration).itinerantesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesPartialUpdate(body: ItineranteEvento, id: number, options?: any) {
            return ItinerantesApiFp(configuration).itinerantesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesRead(id: number, options?: any) {
            return ItinerantesApiFp(configuration).itinerantesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ItineranteEvento} body 
         * @param {number} id A unique integer value identifying this Itinerante.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itinerantesUpdate(body: ItineranteEvento, id: number, options?: any) {
            return ItinerantesApiFp(configuration).itinerantesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ItinerantesApi - object-oriented interface
 * @export
 * @class ItinerantesApi
 * @extends {BaseAPI}
 */
export class ItinerantesApi extends BaseAPI {
    /**
     * 
     * @param {ItineranteEvento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItinerantesApi
     */
    public itinerantesCreate(body: ItineranteEvento, options?: any) {
        return ItinerantesApiFp(this.configuration).itinerantesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Itinerante.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItinerantesApi
     */
    public itinerantesDelete(id: number, options?: any) {
        return ItinerantesApiFp(this.configuration).itinerantesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItinerantesApi
     */
    public itinerantesList(limit?: number, offset?: number, options?: any) {
        return ItinerantesApiFp(this.configuration).itinerantesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ItineranteEvento} body 
     * @param {number} id A unique integer value identifying this Itinerante.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItinerantesApi
     */
    public itinerantesPartialUpdate(body: ItineranteEvento, id: number, options?: any) {
        return ItinerantesApiFp(this.configuration).itinerantesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Itinerante.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItinerantesApi
     */
    public itinerantesRead(id: number, options?: any) {
        return ItinerantesApiFp(this.configuration).itinerantesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ItineranteEvento} body 
     * @param {number} id A unique integer value identifying this Itinerante.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItinerantesApi
     */
    public itinerantesUpdate(body: ItineranteEvento, id: number, options?: any) {
        return ItinerantesApiFp(this.configuration).itinerantesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * JustificativasApi - fetch parameter creator
 * @export
 */
export const JustificativasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Justificativa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasCreate(body: Justificativa, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling justificativasCreate.');
            }
            const localVarPath = `/justificativas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Justificativa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling justificativasDelete.');
            }
            const localVarPath = `/justificativas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/justificativas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Justificativa} body 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasPartialUpdate(body: Justificativa, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling justificativasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling justificativasPartialUpdate.');
            }
            const localVarPath = `/justificativas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Justificativa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling justificativasRead.');
            }
            const localVarPath = `/justificativas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Justificativa} body 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasUpdate(body: Justificativa, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling justificativasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling justificativasUpdate.');
            }
            const localVarPath = `/justificativas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Justificativa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JustificativasApi - functional programming interface
 * @export
 */
export const JustificativasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Justificativa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasCreate(body: Justificativa, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Justificativa> {
            const localVarFetchArgs = JustificativasApiFetchParamCreator(configuration).justificativasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = JustificativasApiFetchParamCreator(configuration).justificativasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20072> {
            const localVarFetchArgs = JustificativasApiFetchParamCreator(configuration).justificativasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Justificativa} body 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasPartialUpdate(body: Justificativa, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Justificativa> {
            const localVarFetchArgs = JustificativasApiFetchParamCreator(configuration).justificativasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Justificativa> {
            const localVarFetchArgs = JustificativasApiFetchParamCreator(configuration).justificativasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Justificativa} body 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasUpdate(body: Justificativa, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Justificativa> {
            const localVarFetchArgs = JustificativasApiFetchParamCreator(configuration).justificativasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JustificativasApi - factory interface
 * @export
 */
export const JustificativasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Justificativa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasCreate(body: Justificativa, options?: any) {
            return JustificativasApiFp(configuration).justificativasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasDelete(id: number, options?: any) {
            return JustificativasApiFp(configuration).justificativasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasList(limit?: number, offset?: number, options?: any) {
            return JustificativasApiFp(configuration).justificativasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Justificativa} body 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasPartialUpdate(body: Justificativa, id: number, options?: any) {
            return JustificativasApiFp(configuration).justificativasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasRead(id: number, options?: any) {
            return JustificativasApiFp(configuration).justificativasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Justificativa} body 
         * @param {number} id A unique integer value identifying this justificativa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        justificativasUpdate(body: Justificativa, id: number, options?: any) {
            return JustificativasApiFp(configuration).justificativasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * JustificativasApi - object-oriented interface
 * @export
 * @class JustificativasApi
 * @extends {BaseAPI}
 */
export class JustificativasApi extends BaseAPI {
    /**
     * 
     * @param {Justificativa} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JustificativasApi
     */
    public justificativasCreate(body: Justificativa, options?: any) {
        return JustificativasApiFp(this.configuration).justificativasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this justificativa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JustificativasApi
     */
    public justificativasDelete(id: number, options?: any) {
        return JustificativasApiFp(this.configuration).justificativasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JustificativasApi
     */
    public justificativasList(limit?: number, offset?: number, options?: any) {
        return JustificativasApiFp(this.configuration).justificativasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Justificativa} body 
     * @param {number} id A unique integer value identifying this justificativa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JustificativasApi
     */
    public justificativasPartialUpdate(body: Justificativa, id: number, options?: any) {
        return JustificativasApiFp(this.configuration).justificativasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this justificativa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JustificativasApi
     */
    public justificativasRead(id: number, options?: any) {
        return JustificativasApiFp(this.configuration).justificativasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Justificativa} body 
     * @param {number} id A unique integer value identifying this justificativa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JustificativasApi
     */
    public justificativasUpdate(body: Justificativa, id: number, options?: any) {
        return JustificativasApiFp(this.configuration).justificativasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * JwtTokenApi - fetch parameter creator
 * @export
 */
export const JwtTokenApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {CustomTokenObtainPair} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenGetCreate(body: CustomTokenObtainPair, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling jwtTokenGetCreate.');
            }
            const localVarPath = `/jwt-token/get/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomTokenObtainPair" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenRefreshCreate(body: TokenRefresh, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling jwtTokenRefreshCreate.');
            }
            const localVarPath = `/jwt-token/refresh/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TokenRefresh" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token's fitness for a particular use.
         * @param {TokenVerify} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenVerifyCreate(body: TokenVerify, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling jwtTokenVerifyCreate.');
            }
            const localVarPath = `/jwt-token/verify/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TokenVerify" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JwtTokenApi - functional programming interface
 * @export
 */
export const JwtTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {CustomTokenObtainPair} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenGetCreate(body: CustomTokenObtainPair, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomTokenObtainPair> {
            const localVarFetchArgs = JwtTokenApiFetchParamCreator(configuration).jwtTokenGetCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenRefreshCreate(body: TokenRefresh, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TokenRefresh> {
            const localVarFetchArgs = JwtTokenApiFetchParamCreator(configuration).jwtTokenRefreshCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token's fitness for a particular use.
         * @param {TokenVerify} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenVerifyCreate(body: TokenVerify, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TokenVerify> {
            const localVarFetchArgs = JwtTokenApiFetchParamCreator(configuration).jwtTokenVerifyCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JwtTokenApi - factory interface
 * @export
 */
export const JwtTokenApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {CustomTokenObtainPair} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenGetCreate(body: CustomTokenObtainPair, options?: any) {
            return JwtTokenApiFp(configuration).jwtTokenGetCreate(body, options)(fetch, basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenRefreshCreate(body: TokenRefresh, options?: any) {
            return JwtTokenApiFp(configuration).jwtTokenRefreshCreate(body, options)(fetch, basePath);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token's fitness for a particular use.
         * @param {TokenVerify} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtTokenVerifyCreate(body: TokenVerify, options?: any) {
            return JwtTokenApiFp(configuration).jwtTokenVerifyCreate(body, options)(fetch, basePath);
        },
    };
};

/**
 * JwtTokenApi - object-oriented interface
 * @export
 * @class JwtTokenApi
 * @extends {BaseAPI}
 */
export class JwtTokenApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {CustomTokenObtainPair} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JwtTokenApi
     */
    public jwtTokenGetCreate(body: CustomTokenObtainPair, options?: any) {
        return JwtTokenApiFp(this.configuration).jwtTokenGetCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JwtTokenApi
     */
    public jwtTokenRefreshCreate(body: TokenRefresh, options?: any) {
        return JwtTokenApiFp(this.configuration).jwtTokenRefreshCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token's fitness for a particular use.
     * @param {TokenVerify} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JwtTokenApi
     */
    public jwtTokenVerifyCreate(body: TokenVerify, options?: any) {
        return JwtTokenApiFp(this.configuration).jwtTokenVerifyCreate(body, options)(this.fetch, this.basePath);
    }

}
/**
 * LocaisApi - fetch parameter creator
 * @export
 */
export const LocaisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Local} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisCreate(body: Local, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling locaisCreate.');
            }
            const localVarPath = `/locais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Local" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling locaisDelete.');
            }
            const localVarPath = `/locais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/locais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Local} body 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisPartialUpdate(body: Local, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling locaisPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling locaisPartialUpdate.');
            }
            const localVarPath = `/locais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Local" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling locaisRead.');
            }
            const localVarPath = `/locais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Local} body 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisUpdate(body: Local, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling locaisUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling locaisUpdate.');
            }
            const localVarPath = `/locais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Local" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocaisApi - functional programming interface
 * @export
 */
export const LocaisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Local} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisCreate(body: Local, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Local> {
            const localVarFetchArgs = LocaisApiFetchParamCreator(configuration).locaisCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LocaisApiFetchParamCreator(configuration).locaisDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20073> {
            const localVarFetchArgs = LocaisApiFetchParamCreator(configuration).locaisList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Local} body 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisPartialUpdate(body: Local, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Local> {
            const localVarFetchArgs = LocaisApiFetchParamCreator(configuration).locaisPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Local> {
            const localVarFetchArgs = LocaisApiFetchParamCreator(configuration).locaisRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Local} body 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisUpdate(body: Local, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Local> {
            const localVarFetchArgs = LocaisApiFetchParamCreator(configuration).locaisUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LocaisApi - factory interface
 * @export
 */
export const LocaisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Local} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisCreate(body: Local, options?: any) {
            return LocaisApiFp(configuration).locaisCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisDelete(id: number, options?: any) {
            return LocaisApiFp(configuration).locaisDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisList(limit?: number, offset?: number, options?: any) {
            return LocaisApiFp(configuration).locaisList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Local} body 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisPartialUpdate(body: Local, id: number, options?: any) {
            return LocaisApiFp(configuration).locaisPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisRead(id: number, options?: any) {
            return LocaisApiFp(configuration).locaisRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Local} body 
         * @param {number} id A unique integer value identifying this Local.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locaisUpdate(body: Local, id: number, options?: any) {
            return LocaisApiFp(configuration).locaisUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * LocaisApi - object-oriented interface
 * @export
 * @class LocaisApi
 * @extends {BaseAPI}
 */
export class LocaisApi extends BaseAPI {
    /**
     * 
     * @param {Local} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocaisApi
     */
    public locaisCreate(body: Local, options?: any) {
        return LocaisApiFp(this.configuration).locaisCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Local.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocaisApi
     */
    public locaisDelete(id: number, options?: any) {
        return LocaisApiFp(this.configuration).locaisDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocaisApi
     */
    public locaisList(limit?: number, offset?: number, options?: any) {
        return LocaisApiFp(this.configuration).locaisList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Local} body 
     * @param {number} id A unique integer value identifying this Local.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocaisApi
     */
    public locaisPartialUpdate(body: Local, id: number, options?: any) {
        return LocaisApiFp(this.configuration).locaisPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Local.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocaisApi
     */
    public locaisRead(id: number, options?: any) {
        return LocaisApiFp(this.configuration).locaisRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Local} body 
     * @param {number} id A unique integer value identifying this Local.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocaisApi
     */
    public locaisUpdate(body: Local, id: number, options?: any) {
        return LocaisApiFp(this.configuration).locaisUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * LoginHistoricosApi - fetch parameter creator
 * @export
 */
export const LoginHistoricosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosCreate(body: HistoricoLogin, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginHistoricosCreate.');
            }
            const localVarPath = `/login-historicos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HistoricoLogin" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling loginHistoricosDelete.');
            }
            const localVarPath = `/login-historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/login-historicos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosPartialUpdate(body: HistoricoLogin, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginHistoricosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling loginHistoricosPartialUpdate.');
            }
            const localVarPath = `/login-historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HistoricoLogin" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling loginHistoricosRead.');
            }
            const localVarPath = `/login-historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosUpdate(body: HistoricoLogin, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginHistoricosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling loginHistoricosUpdate.');
            }
            const localVarPath = `/login-historicos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HistoricoLogin" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginHistoricosApi - functional programming interface
 * @export
 */
export const LoginHistoricosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosCreate(body: HistoricoLogin, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HistoricoLogin> {
            const localVarFetchArgs = LoginHistoricosApiFetchParamCreator(configuration).loginHistoricosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LoginHistoricosApiFetchParamCreator(configuration).loginHistoricosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20074> {
            const localVarFetchArgs = LoginHistoricosApiFetchParamCreator(configuration).loginHistoricosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosPartialUpdate(body: HistoricoLogin, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HistoricoLogin> {
            const localVarFetchArgs = LoginHistoricosApiFetchParamCreator(configuration).loginHistoricosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HistoricoLogin> {
            const localVarFetchArgs = LoginHistoricosApiFetchParamCreator(configuration).loginHistoricosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosUpdate(body: HistoricoLogin, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HistoricoLogin> {
            const localVarFetchArgs = LoginHistoricosApiFetchParamCreator(configuration).loginHistoricosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LoginHistoricosApi - factory interface
 * @export
 */
export const LoginHistoricosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosCreate(body: HistoricoLogin, options?: any) {
            return LoginHistoricosApiFp(configuration).loginHistoricosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosDelete(id: number, options?: any) {
            return LoginHistoricosApiFp(configuration).loginHistoricosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosList(limit?: number, offset?: number, options?: any) {
            return LoginHistoricosApiFp(configuration).loginHistoricosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosPartialUpdate(body: HistoricoLogin, id: number, options?: any) {
            return LoginHistoricosApiFp(configuration).loginHistoricosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosRead(id: number, options?: any) {
            return LoginHistoricosApiFp(configuration).loginHistoricosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {HistoricoLogin} body 
         * @param {number} id A unique integer value identifying this Histórico Login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginHistoricosUpdate(body: HistoricoLogin, id: number, options?: any) {
            return LoginHistoricosApiFp(configuration).loginHistoricosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * LoginHistoricosApi - object-oriented interface
 * @export
 * @class LoginHistoricosApi
 * @extends {BaseAPI}
 */
export class LoginHistoricosApi extends BaseAPI {
    /**
     * 
     * @param {HistoricoLogin} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginHistoricosApi
     */
    public loginHistoricosCreate(body: HistoricoLogin, options?: any) {
        return LoginHistoricosApiFp(this.configuration).loginHistoricosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Histórico Login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginHistoricosApi
     */
    public loginHistoricosDelete(id: number, options?: any) {
        return LoginHistoricosApiFp(this.configuration).loginHistoricosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginHistoricosApi
     */
    public loginHistoricosList(limit?: number, offset?: number, options?: any) {
        return LoginHistoricosApiFp(this.configuration).loginHistoricosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {HistoricoLogin} body 
     * @param {number} id A unique integer value identifying this Histórico Login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginHistoricosApi
     */
    public loginHistoricosPartialUpdate(body: HistoricoLogin, id: number, options?: any) {
        return LoginHistoricosApiFp(this.configuration).loginHistoricosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Histórico Login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginHistoricosApi
     */
    public loginHistoricosRead(id: number, options?: any) {
        return LoginHistoricosApiFp(this.configuration).loginHistoricosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {HistoricoLogin} body 
     * @param {number} id A unique integer value identifying this Histórico Login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginHistoricosApi
     */
    public loginHistoricosUpdate(body: HistoricoLogin, id: number, options?: any) {
        return LoginHistoricosApiFp(this.configuration).loginHistoricosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ManifestacoesApi - fetch parameter creator
 * @export
 */
export const ManifestacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Manifestacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesCreate(body: Manifestacao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesCreate.');
            }
            const localVarPath = `/manifestacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Manifestacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesDelete.');
            }
            const localVarPath = `/manifestacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [cadastrado_por] 
         * @param {string} [defensoria] 
         * @param {string} [situacao] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesList(data_inicial?: string, data_final?: string, cadastrado_por?: string, defensoria?: string, situacao?: string, ativo?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/manifestacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (data_inicial !== undefined) {
                localVarQueryParameter['data_inicial'] = data_inicial;
            }

            if (data_final !== undefined) {
                localVarQueryParameter['data_final'] = data_final;
            }

            if (cadastrado_por !== undefined) {
                localVarQueryParameter['cadastrado_por'] = cadastrado_por;
            }

            if (defensoria !== undefined) {
                localVarQueryParameter['defensoria'] = defensoria;
            }

            if (situacao !== undefined) {
                localVarQueryParameter['situacao'] = situacao;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Manifestacao} body 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesPartialUpdate(body: Manifestacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesPartialUpdate.');
            }
            const localVarPath = `/manifestacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Manifestacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesRead.');
            }
            const localVarPath = `/manifestacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Manifestacao} body 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesUpdate(body: Manifestacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesUpdate.');
            }
            const localVarPath = `/manifestacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Manifestacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManifestacoesApi - functional programming interface
 * @export
 */
export const ManifestacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Manifestacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesCreate(body: Manifestacao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Manifestacao> {
            const localVarFetchArgs = ManifestacoesApiFetchParamCreator(configuration).manifestacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ManifestacoesApiFetchParamCreator(configuration).manifestacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [cadastrado_por] 
         * @param {string} [defensoria] 
         * @param {string} [situacao] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesList(data_inicial?: string, data_final?: string, cadastrado_por?: string, defensoria?: string, situacao?: string, ativo?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20077> {
            const localVarFetchArgs = ManifestacoesApiFetchParamCreator(configuration).manifestacoesList(data_inicial, data_final, cadastrado_por, defensoria, situacao, ativo, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Manifestacao} body 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesPartialUpdate(body: Manifestacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Manifestacao> {
            const localVarFetchArgs = ManifestacoesApiFetchParamCreator(configuration).manifestacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Manifestacao> {
            const localVarFetchArgs = ManifestacoesApiFetchParamCreator(configuration).manifestacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Manifestacao} body 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesUpdate(body: Manifestacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Manifestacao> {
            const localVarFetchArgs = ManifestacoesApiFetchParamCreator(configuration).manifestacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ManifestacoesApi - factory interface
 * @export
 */
export const ManifestacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Manifestacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesCreate(body: Manifestacao, options?: any) {
            return ManifestacoesApiFp(configuration).manifestacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDelete(id: number, options?: any) {
            return ManifestacoesApiFp(configuration).manifestacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [cadastrado_por] 
         * @param {string} [defensoria] 
         * @param {string} [situacao] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesList(data_inicial?: string, data_final?: string, cadastrado_por?: string, defensoria?: string, situacao?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
            return ManifestacoesApiFp(configuration).manifestacoesList(data_inicial, data_final, cadastrado_por, defensoria, situacao, ativo, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Manifestacao} body 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesPartialUpdate(body: Manifestacao, id: number, options?: any) {
            return ManifestacoesApiFp(configuration).manifestacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesRead(id: number, options?: any) {
            return ManifestacoesApiFp(configuration).manifestacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Manifestacao} body 
         * @param {number} id A unique integer value identifying this Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesUpdate(body: Manifestacao, id: number, options?: any) {
            return ManifestacoesApiFp(configuration).manifestacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ManifestacoesApi - object-oriented interface
 * @export
 * @class ManifestacoesApi
 * @extends {BaseAPI}
 */
export class ManifestacoesApi extends BaseAPI {
    /**
     * 
     * @param {Manifestacao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesApi
     */
    public manifestacoesCreate(body: Manifestacao, options?: any) {
        return ManifestacoesApiFp(this.configuration).manifestacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesApi
     */
    public manifestacoesDelete(id: number, options?: any) {
        return ManifestacoesApiFp(this.configuration).manifestacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [data_inicial] 
     * @param {string} [data_final] 
     * @param {string} [cadastrado_por] 
     * @param {string} [defensoria] 
     * @param {string} [situacao] 
     * @param {string} [ativo] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesApi
     */
    public manifestacoesList(data_inicial?: string, data_final?: string, cadastrado_por?: string, defensoria?: string, situacao?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
        return ManifestacoesApiFp(this.configuration).manifestacoesList(data_inicial, data_final, cadastrado_por, defensoria, situacao, ativo, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Manifestacao} body 
     * @param {number} id A unique integer value identifying this Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesApi
     */
    public manifestacoesPartialUpdate(body: Manifestacao, id: number, options?: any) {
        return ManifestacoesApiFp(this.configuration).manifestacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesApi
     */
    public manifestacoesRead(id: number, options?: any) {
        return ManifestacoesApiFp(this.configuration).manifestacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Manifestacao} body 
     * @param {number} id A unique integer value identifying this Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesApi
     */
    public manifestacoesUpdate(body: Manifestacao, id: number, options?: any) {
        return ManifestacoesApiFp(this.configuration).manifestacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ManifestacoesAvisosApi - fetch parameter creator
 * @export
 */
export const ManifestacoesAvisosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosCreate(body: ManifestacaoAviso, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesAvisosCreate.');
            }
            const localVarPath = `/manifestacoes-avisos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ManifestacaoAviso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesAvisosDelete.');
            }
            const localVarPath = `/manifestacoes-avisos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/manifestacoes-avisos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosPartialUpdate(body: ManifestacaoAviso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesAvisosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesAvisosPartialUpdate.');
            }
            const localVarPath = `/manifestacoes-avisos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ManifestacaoAviso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesAvisosRead.');
            }
            const localVarPath = `/manifestacoes-avisos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosUpdate(body: ManifestacaoAviso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesAvisosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesAvisosUpdate.');
            }
            const localVarPath = `/manifestacoes-avisos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ManifestacaoAviso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManifestacoesAvisosApi - functional programming interface
 * @export
 */
export const ManifestacoesAvisosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosCreate(body: ManifestacaoAviso, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ManifestacaoAviso> {
            const localVarFetchArgs = ManifestacoesAvisosApiFetchParamCreator(configuration).manifestacoesAvisosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ManifestacoesAvisosApiFetchParamCreator(configuration).manifestacoesAvisosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20075> {
            const localVarFetchArgs = ManifestacoesAvisosApiFetchParamCreator(configuration).manifestacoesAvisosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosPartialUpdate(body: ManifestacaoAviso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ManifestacaoAviso> {
            const localVarFetchArgs = ManifestacoesAvisosApiFetchParamCreator(configuration).manifestacoesAvisosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ManifestacaoAviso> {
            const localVarFetchArgs = ManifestacoesAvisosApiFetchParamCreator(configuration).manifestacoesAvisosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosUpdate(body: ManifestacaoAviso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ManifestacaoAviso> {
            const localVarFetchArgs = ManifestacoesAvisosApiFetchParamCreator(configuration).manifestacoesAvisosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ManifestacoesAvisosApi - factory interface
 * @export
 */
export const ManifestacoesAvisosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosCreate(body: ManifestacaoAviso, options?: any) {
            return ManifestacoesAvisosApiFp(configuration).manifestacoesAvisosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosDelete(id: number, options?: any) {
            return ManifestacoesAvisosApiFp(configuration).manifestacoesAvisosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosList(limit?: number, offset?: number, options?: any) {
            return ManifestacoesAvisosApiFp(configuration).manifestacoesAvisosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosPartialUpdate(body: ManifestacaoAviso, id: number, options?: any) {
            return ManifestacoesAvisosApiFp(configuration).manifestacoesAvisosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosRead(id: number, options?: any) {
            return ManifestacoesAvisosApiFp(configuration).manifestacoesAvisosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ManifestacaoAviso} body 
         * @param {number} id A unique integer value identifying this Aviso de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesAvisosUpdate(body: ManifestacaoAviso, id: number, options?: any) {
            return ManifestacoesAvisosApiFp(configuration).manifestacoesAvisosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ManifestacoesAvisosApi - object-oriented interface
 * @export
 * @class ManifestacoesAvisosApi
 * @extends {BaseAPI}
 */
export class ManifestacoesAvisosApi extends BaseAPI {
    /**
     * 
     * @param {ManifestacaoAviso} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesAvisosApi
     */
    public manifestacoesAvisosCreate(body: ManifestacaoAviso, options?: any) {
        return ManifestacoesAvisosApiFp(this.configuration).manifestacoesAvisosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Aviso de Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesAvisosApi
     */
    public manifestacoesAvisosDelete(id: number, options?: any) {
        return ManifestacoesAvisosApiFp(this.configuration).manifestacoesAvisosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesAvisosApi
     */
    public manifestacoesAvisosList(limit?: number, offset?: number, options?: any) {
        return ManifestacoesAvisosApiFp(this.configuration).manifestacoesAvisosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ManifestacaoAviso} body 
     * @param {number} id A unique integer value identifying this Aviso de Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesAvisosApi
     */
    public manifestacoesAvisosPartialUpdate(body: ManifestacaoAviso, id: number, options?: any) {
        return ManifestacoesAvisosApiFp(this.configuration).manifestacoesAvisosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Aviso de Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesAvisosApi
     */
    public manifestacoesAvisosRead(id: number, options?: any) {
        return ManifestacoesAvisosApiFp(this.configuration).manifestacoesAvisosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ManifestacaoAviso} body 
     * @param {number} id A unique integer value identifying this Aviso de Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesAvisosApi
     */
    public manifestacoesAvisosUpdate(body: ManifestacaoAviso, id: number, options?: any) {
        return ManifestacoesAvisosApiFp(this.configuration).manifestacoesAvisosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ManifestacoesDocumentosApi - fetch parameter creator
 * @export
 */
export const ManifestacoesDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosCreate(body: ManifestacaoDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesDocumentosCreate.');
            }
            const localVarPath = `/manifestacoes-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ManifestacaoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesDocumentosDelete.');
            }
            const localVarPath = `/manifestacoes-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/manifestacoes-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosPartialUpdate(body: ManifestacaoDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesDocumentosPartialUpdate.');
            }
            const localVarPath = `/manifestacoes-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ManifestacaoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesDocumentosRead.');
            }
            const localVarPath = `/manifestacoes-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosUpdate(body: ManifestacaoDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling manifestacoesDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling manifestacoesDocumentosUpdate.');
            }
            const localVarPath = `/manifestacoes-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ManifestacaoDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManifestacoesDocumentosApi - functional programming interface
 * @export
 */
export const ManifestacoesDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosCreate(body: ManifestacaoDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ManifestacaoDocumento> {
            const localVarFetchArgs = ManifestacoesDocumentosApiFetchParamCreator(configuration).manifestacoesDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ManifestacoesDocumentosApiFetchParamCreator(configuration).manifestacoesDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20076> {
            const localVarFetchArgs = ManifestacoesDocumentosApiFetchParamCreator(configuration).manifestacoesDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosPartialUpdate(body: ManifestacaoDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ManifestacaoDocumento> {
            const localVarFetchArgs = ManifestacoesDocumentosApiFetchParamCreator(configuration).manifestacoesDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ManifestacaoDocumento> {
            const localVarFetchArgs = ManifestacoesDocumentosApiFetchParamCreator(configuration).manifestacoesDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosUpdate(body: ManifestacaoDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ManifestacaoDocumento> {
            const localVarFetchArgs = ManifestacoesDocumentosApiFetchParamCreator(configuration).manifestacoesDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ManifestacoesDocumentosApi - factory interface
 * @export
 */
export const ManifestacoesDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosCreate(body: ManifestacaoDocumento, options?: any) {
            return ManifestacoesDocumentosApiFp(configuration).manifestacoesDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosDelete(id: number, options?: any) {
            return ManifestacoesDocumentosApiFp(configuration).manifestacoesDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosList(limit?: number, offset?: number, options?: any) {
            return ManifestacoesDocumentosApiFp(configuration).manifestacoesDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosPartialUpdate(body: ManifestacaoDocumento, id: number, options?: any) {
            return ManifestacoesDocumentosApiFp(configuration).manifestacoesDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosRead(id: number, options?: any) {
            return ManifestacoesDocumentosApiFp(configuration).manifestacoesDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ManifestacaoDocumento} body 
         * @param {number} id A unique integer value identifying this Documento de Manifestação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestacoesDocumentosUpdate(body: ManifestacaoDocumento, id: number, options?: any) {
            return ManifestacoesDocumentosApiFp(configuration).manifestacoesDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ManifestacoesDocumentosApi - object-oriented interface
 * @export
 * @class ManifestacoesDocumentosApi
 * @extends {BaseAPI}
 */
export class ManifestacoesDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {ManifestacaoDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesDocumentosApi
     */
    public manifestacoesDocumentosCreate(body: ManifestacaoDocumento, options?: any) {
        return ManifestacoesDocumentosApiFp(this.configuration).manifestacoesDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Documento de Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesDocumentosApi
     */
    public manifestacoesDocumentosDelete(id: number, options?: any) {
        return ManifestacoesDocumentosApiFp(this.configuration).manifestacoesDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesDocumentosApi
     */
    public manifestacoesDocumentosList(limit?: number, offset?: number, options?: any) {
        return ManifestacoesDocumentosApiFp(this.configuration).manifestacoesDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ManifestacaoDocumento} body 
     * @param {number} id A unique integer value identifying this Documento de Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesDocumentosApi
     */
    public manifestacoesDocumentosPartialUpdate(body: ManifestacaoDocumento, id: number, options?: any) {
        return ManifestacoesDocumentosApiFp(this.configuration).manifestacoesDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Documento de Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesDocumentosApi
     */
    public manifestacoesDocumentosRead(id: number, options?: any) {
        return ManifestacoesDocumentosApiFp(this.configuration).manifestacoesDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ManifestacaoDocumento} body 
     * @param {number} id A unique integer value identifying this Documento de Manifestação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestacoesDocumentosApi
     */
    public manifestacoesDocumentosUpdate(body: ManifestacaoDocumento, id: number, options?: any) {
        return ManifestacoesDocumentosApiFp(this.configuration).manifestacoesDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MenusApi - fetch parameter creator
 * @export
 */
export const MenusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusList(options: any = {}): FetchArgs {
            const localVarPath = `/menus/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenusApi - functional programming interface
 * @export
 */
export const MenusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UsuarioMenus>> {
            const localVarFetchArgs = MenusApiFetchParamCreator(configuration).menusList(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MenusApi - factory interface
 * @export
 */
export const MenusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusList(options?: any) {
            return MenusApiFp(configuration).menusList(options)(fetch, basePath);
        },
    };
};

/**
 * MenusApi - object-oriented interface
 * @export
 * @class MenusApi
 * @extends {BaseAPI}
 */
export class MenusApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenusApi
     */
    public menusList(options?: any) {
        return MenusApiFp(this.configuration).menusList(options)(this.fetch, this.basePath);
    }

}
/**
 * MenusExtrasApi - fetch parameter creator
 * @export
 */
export const MenusExtrasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MenuExtra} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasCreate(body: MenuExtra, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling menusExtrasCreate.');
            }
            const localVarPath = `/menus-extras/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MenuExtra" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling menusExtrasDelete.');
            }
            const localVarPath = `/menus-extras/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/menus-extras/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MenuExtra} body 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasPartialUpdate(body: MenuExtra, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling menusExtrasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling menusExtrasPartialUpdate.');
            }
            const localVarPath = `/menus-extras/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MenuExtra" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling menusExtrasRead.');
            }
            const localVarPath = `/menus-extras/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MenuExtra} body 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasUpdate(body: MenuExtra, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling menusExtrasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling menusExtrasUpdate.');
            }
            const localVarPath = `/menus-extras/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MenuExtra" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenusExtrasApi - functional programming interface
 * @export
 */
export const MenusExtrasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MenuExtra} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasCreate(body: MenuExtra, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MenuExtra> {
            const localVarFetchArgs = MenusExtrasApiFetchParamCreator(configuration).menusExtrasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MenusExtrasApiFetchParamCreator(configuration).menusExtrasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20078> {
            const localVarFetchArgs = MenusExtrasApiFetchParamCreator(configuration).menusExtrasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MenuExtra} body 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasPartialUpdate(body: MenuExtra, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MenuExtra> {
            const localVarFetchArgs = MenusExtrasApiFetchParamCreator(configuration).menusExtrasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MenuExtra> {
            const localVarFetchArgs = MenusExtrasApiFetchParamCreator(configuration).menusExtrasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MenuExtra} body 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasUpdate(body: MenuExtra, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MenuExtra> {
            const localVarFetchArgs = MenusExtrasApiFetchParamCreator(configuration).menusExtrasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MenusExtrasApi - factory interface
 * @export
 */
export const MenusExtrasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {MenuExtra} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasCreate(body: MenuExtra, options?: any) {
            return MenusExtrasApiFp(configuration).menusExtrasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasDelete(id: number, options?: any) {
            return MenusExtrasApiFp(configuration).menusExtrasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasList(limit?: number, offset?: number, options?: any) {
            return MenusExtrasApiFp(configuration).menusExtrasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MenuExtra} body 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasPartialUpdate(body: MenuExtra, id: number, options?: any) {
            return MenusExtrasApiFp(configuration).menusExtrasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasRead(id: number, options?: any) {
            return MenusExtrasApiFp(configuration).menusExtrasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MenuExtra} body 
         * @param {number} id A unique integer value identifying this Menu Extra.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusExtrasUpdate(body: MenuExtra, id: number, options?: any) {
            return MenusExtrasApiFp(configuration).menusExtrasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * MenusExtrasApi - object-oriented interface
 * @export
 * @class MenusExtrasApi
 * @extends {BaseAPI}
 */
export class MenusExtrasApi extends BaseAPI {
    /**
     * 
     * @param {MenuExtra} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenusExtrasApi
     */
    public menusExtrasCreate(body: MenuExtra, options?: any) {
        return MenusExtrasApiFp(this.configuration).menusExtrasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Menu Extra.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenusExtrasApi
     */
    public menusExtrasDelete(id: number, options?: any) {
        return MenusExtrasApiFp(this.configuration).menusExtrasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenusExtrasApi
     */
    public menusExtrasList(limit?: number, offset?: number, options?: any) {
        return MenusExtrasApiFp(this.configuration).menusExtrasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MenuExtra} body 
     * @param {number} id A unique integer value identifying this Menu Extra.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenusExtrasApi
     */
    public menusExtrasPartialUpdate(body: MenuExtra, id: number, options?: any) {
        return MenusExtrasApiFp(this.configuration).menusExtrasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Menu Extra.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenusExtrasApi
     */
    public menusExtrasRead(id: number, options?: any) {
        return MenusExtrasApiFp(this.configuration).menusExtrasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MenuExtra} body 
     * @param {number} id A unique integer value identifying this Menu Extra.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenusExtrasApi
     */
    public menusExtrasUpdate(body: MenuExtra, id: number, options?: any) {
        return MenusExtrasApiFp(this.configuration).menusExtrasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ModelosDocumentoApi - fetch parameter creator
 * @export
 */
export const ModelosDocumentoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoCreate(body: AtendimentoModeloDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modelosDocumentoCreate.');
            }
            const localVarPath = `/modelos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoModeloDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modelosDocumentoDelete.');
            }
            const localVarPath = `/modelos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/modelos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoPartialUpdate(body: AtendimentoModeloDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modelosDocumentoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modelosDocumentoPartialUpdate.');
            }
            const localVarPath = `/modelos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoModeloDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modelosDocumentoRead.');
            }
            const localVarPath = `/modelos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoUpdate(body: AtendimentoModeloDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modelosDocumentoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modelosDocumentoUpdate.');
            }
            const localVarPath = `/modelos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtendimentoModeloDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelosDocumentoApi - functional programming interface
 * @export
 */
export const ModelosDocumentoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoCreate(body: AtendimentoModeloDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoModeloDocumento> {
            const localVarFetchArgs = ModelosDocumentoApiFetchParamCreator(configuration).modelosDocumentoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModelosDocumentoApiFetchParamCreator(configuration).modelosDocumentoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20079> {
            const localVarFetchArgs = ModelosDocumentoApiFetchParamCreator(configuration).modelosDocumentoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoPartialUpdate(body: AtendimentoModeloDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoModeloDocumento> {
            const localVarFetchArgs = ModelosDocumentoApiFetchParamCreator(configuration).modelosDocumentoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoModeloDocumento> {
            const localVarFetchArgs = ModelosDocumentoApiFetchParamCreator(configuration).modelosDocumentoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoUpdate(body: AtendimentoModeloDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoModeloDocumento> {
            const localVarFetchArgs = ModelosDocumentoApiFetchParamCreator(configuration).modelosDocumentoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModelosDocumentoApi - factory interface
 * @export
 */
export const ModelosDocumentoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoCreate(body: AtendimentoModeloDocumento, options?: any) {
            return ModelosDocumentoApiFp(configuration).modelosDocumentoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoDelete(id: number, options?: any) {
            return ModelosDocumentoApiFp(configuration).modelosDocumentoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoList(limit?: number, offset?: number, options?: any) {
            return ModelosDocumentoApiFp(configuration).modelosDocumentoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoPartialUpdate(body: AtendimentoModeloDocumento, id: number, options?: any) {
            return ModelosDocumentoApiFp(configuration).modelosDocumentoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoRead(id: number, options?: any) {
            return ModelosDocumentoApiFp(configuration).modelosDocumentoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtendimentoModeloDocumento} body 
         * @param {number} id A unique integer value identifying this modelo documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelosDocumentoUpdate(body: AtendimentoModeloDocumento, id: number, options?: any) {
            return ModelosDocumentoApiFp(configuration).modelosDocumentoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ModelosDocumentoApi - object-oriented interface
 * @export
 * @class ModelosDocumentoApi
 * @extends {BaseAPI}
 */
export class ModelosDocumentoApi extends BaseAPI {
    /**
     * 
     * @param {AtendimentoModeloDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelosDocumentoApi
     */
    public modelosDocumentoCreate(body: AtendimentoModeloDocumento, options?: any) {
        return ModelosDocumentoApiFp(this.configuration).modelosDocumentoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this modelo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelosDocumentoApi
     */
    public modelosDocumentoDelete(id: number, options?: any) {
        return ModelosDocumentoApiFp(this.configuration).modelosDocumentoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelosDocumentoApi
     */
    public modelosDocumentoList(limit?: number, offset?: number, options?: any) {
        return ModelosDocumentoApiFp(this.configuration).modelosDocumentoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtendimentoModeloDocumento} body 
     * @param {number} id A unique integer value identifying this modelo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelosDocumentoApi
     */
    public modelosDocumentoPartialUpdate(body: AtendimentoModeloDocumento, id: number, options?: any) {
        return ModelosDocumentoApiFp(this.configuration).modelosDocumentoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this modelo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelosDocumentoApi
     */
    public modelosDocumentoRead(id: number, options?: any) {
        return ModelosDocumentoApiFp(this.configuration).modelosDocumentoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtendimentoModeloDocumento} body 
     * @param {number} id A unique integer value identifying this modelo documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelosDocumentoApi
     */
    public modelosDocumentoUpdate(body: AtendimentoModeloDocumento, id: number, options?: any) {
        return ModelosDocumentoApiFp(this.configuration).modelosDocumentoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MotivosExclusaoApi - fetch parameter creator
 * @export
 */
export const MotivosExclusaoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoCreate(body: MotivoExclusao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling motivosExclusaoCreate.');
            }
            const localVarPath = `/motivos-exclusao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MotivoExclusao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling motivosExclusaoDelete.');
            }
            const localVarPath = `/motivos-exclusao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/motivos-exclusao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoPartialUpdate(body: MotivoExclusao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling motivosExclusaoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling motivosExclusaoPartialUpdate.');
            }
            const localVarPath = `/motivos-exclusao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MotivoExclusao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling motivosExclusaoRead.');
            }
            const localVarPath = `/motivos-exclusao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoUpdate(body: MotivoExclusao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling motivosExclusaoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling motivosExclusaoUpdate.');
            }
            const localVarPath = `/motivos-exclusao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MotivoExclusao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MotivosExclusaoApi - functional programming interface
 * @export
 */
export const MotivosExclusaoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoCreate(body: MotivoExclusao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotivoExclusao> {
            const localVarFetchArgs = MotivosExclusaoApiFetchParamCreator(configuration).motivosExclusaoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MotivosExclusaoApiFetchParamCreator(configuration).motivosExclusaoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20080> {
            const localVarFetchArgs = MotivosExclusaoApiFetchParamCreator(configuration).motivosExclusaoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoPartialUpdate(body: MotivoExclusao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotivoExclusao> {
            const localVarFetchArgs = MotivosExclusaoApiFetchParamCreator(configuration).motivosExclusaoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotivoExclusao> {
            const localVarFetchArgs = MotivosExclusaoApiFetchParamCreator(configuration).motivosExclusaoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoUpdate(body: MotivoExclusao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotivoExclusao> {
            const localVarFetchArgs = MotivosExclusaoApiFetchParamCreator(configuration).motivosExclusaoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MotivosExclusaoApi - factory interface
 * @export
 */
export const MotivosExclusaoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoCreate(body: MotivoExclusao, options?: any) {
            return MotivosExclusaoApiFp(configuration).motivosExclusaoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoDelete(id: number, options?: any) {
            return MotivosExclusaoApiFp(configuration).motivosExclusaoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoList(limit?: number, offset?: number, options?: any) {
            return MotivosExclusaoApiFp(configuration).motivosExclusaoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoPartialUpdate(body: MotivoExclusao, id: number, options?: any) {
            return MotivosExclusaoApiFp(configuration).motivosExclusaoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoRead(id: number, options?: any) {
            return MotivosExclusaoApiFp(configuration).motivosExclusaoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MotivoExclusao} body 
         * @param {number} id A unique integer value identifying this Motivo de Exclusão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosExclusaoUpdate(body: MotivoExclusao, id: number, options?: any) {
            return MotivosExclusaoApiFp(configuration).motivosExclusaoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * MotivosExclusaoApi - object-oriented interface
 * @export
 * @class MotivosExclusaoApi
 * @extends {BaseAPI}
 */
export class MotivosExclusaoApi extends BaseAPI {
    /**
     * 
     * @param {MotivoExclusao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosExclusaoApi
     */
    public motivosExclusaoCreate(body: MotivoExclusao, options?: any) {
        return MotivosExclusaoApiFp(this.configuration).motivosExclusaoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Motivo de Exclusão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosExclusaoApi
     */
    public motivosExclusaoDelete(id: number, options?: any) {
        return MotivosExclusaoApiFp(this.configuration).motivosExclusaoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosExclusaoApi
     */
    public motivosExclusaoList(limit?: number, offset?: number, options?: any) {
        return MotivosExclusaoApiFp(this.configuration).motivosExclusaoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MotivoExclusao} body 
     * @param {number} id A unique integer value identifying this Motivo de Exclusão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosExclusaoApi
     */
    public motivosExclusaoPartialUpdate(body: MotivoExclusao, id: number, options?: any) {
        return MotivosExclusaoApiFp(this.configuration).motivosExclusaoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Motivo de Exclusão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosExclusaoApi
     */
    public motivosExclusaoRead(id: number, options?: any) {
        return MotivosExclusaoApiFp(this.configuration).motivosExclusaoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MotivoExclusao} body 
     * @param {number} id A unique integer value identifying this Motivo de Exclusão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosExclusaoApi
     */
    public motivosExclusaoUpdate(body: MotivoExclusao, id: number, options?: any) {
        return MotivosExclusaoApiFp(this.configuration).motivosExclusaoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MotivosParaBaixaPrisaoApi - fetch parameter creator
 * @export
 */
export const MotivosParaBaixaPrisaoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoCreate(body: MotivoBaixaPrisao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling motivosParaBaixaPrisaoCreate.');
            }
            const localVarPath = `/motivos-para-baixa-prisao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MotivoBaixaPrisao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling motivosParaBaixaPrisaoDelete.');
            }
            const localVarPath = `/motivos-para-baixa-prisao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/motivos-para-baixa-prisao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoPartialUpdate(body: MotivoBaixaPrisao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling motivosParaBaixaPrisaoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling motivosParaBaixaPrisaoPartialUpdate.');
            }
            const localVarPath = `/motivos-para-baixa-prisao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MotivoBaixaPrisao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling motivosParaBaixaPrisaoRead.');
            }
            const localVarPath = `/motivos-para-baixa-prisao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoUpdate(body: MotivoBaixaPrisao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling motivosParaBaixaPrisaoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling motivosParaBaixaPrisaoUpdate.');
            }
            const localVarPath = `/motivos-para-baixa-prisao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MotivoBaixaPrisao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MotivosParaBaixaPrisaoApi - functional programming interface
 * @export
 */
export const MotivosParaBaixaPrisaoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoCreate(body: MotivoBaixaPrisao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotivoBaixaPrisao> {
            const localVarFetchArgs = MotivosParaBaixaPrisaoApiFetchParamCreator(configuration).motivosParaBaixaPrisaoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MotivosParaBaixaPrisaoApiFetchParamCreator(configuration).motivosParaBaixaPrisaoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20081> {
            const localVarFetchArgs = MotivosParaBaixaPrisaoApiFetchParamCreator(configuration).motivosParaBaixaPrisaoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoPartialUpdate(body: MotivoBaixaPrisao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotivoBaixaPrisao> {
            const localVarFetchArgs = MotivosParaBaixaPrisaoApiFetchParamCreator(configuration).motivosParaBaixaPrisaoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotivoBaixaPrisao> {
            const localVarFetchArgs = MotivosParaBaixaPrisaoApiFetchParamCreator(configuration).motivosParaBaixaPrisaoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoUpdate(body: MotivoBaixaPrisao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotivoBaixaPrisao> {
            const localVarFetchArgs = MotivosParaBaixaPrisaoApiFetchParamCreator(configuration).motivosParaBaixaPrisaoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MotivosParaBaixaPrisaoApi - factory interface
 * @export
 */
export const MotivosParaBaixaPrisaoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoCreate(body: MotivoBaixaPrisao, options?: any) {
            return MotivosParaBaixaPrisaoApiFp(configuration).motivosParaBaixaPrisaoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoDelete(id: number, options?: any) {
            return MotivosParaBaixaPrisaoApiFp(configuration).motivosParaBaixaPrisaoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoList(limit?: number, offset?: number, options?: any) {
            return MotivosParaBaixaPrisaoApiFp(configuration).motivosParaBaixaPrisaoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoPartialUpdate(body: MotivoBaixaPrisao, id: number, options?: any) {
            return MotivosParaBaixaPrisaoApiFp(configuration).motivosParaBaixaPrisaoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoRead(id: number, options?: any) {
            return MotivosParaBaixaPrisaoApiFp(configuration).motivosParaBaixaPrisaoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MotivoBaixaPrisao} body 
         * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        motivosParaBaixaPrisaoUpdate(body: MotivoBaixaPrisao, id: number, options?: any) {
            return MotivosParaBaixaPrisaoApiFp(configuration).motivosParaBaixaPrisaoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * MotivosParaBaixaPrisaoApi - object-oriented interface
 * @export
 * @class MotivosParaBaixaPrisaoApi
 * @extends {BaseAPI}
 */
export class MotivosParaBaixaPrisaoApi extends BaseAPI {
    /**
     * 
     * @param {MotivoBaixaPrisao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosParaBaixaPrisaoApi
     */
    public motivosParaBaixaPrisaoCreate(body: MotivoBaixaPrisao, options?: any) {
        return MotivosParaBaixaPrisaoApiFp(this.configuration).motivosParaBaixaPrisaoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosParaBaixaPrisaoApi
     */
    public motivosParaBaixaPrisaoDelete(id: number, options?: any) {
        return MotivosParaBaixaPrisaoApiFp(this.configuration).motivosParaBaixaPrisaoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosParaBaixaPrisaoApi
     */
    public motivosParaBaixaPrisaoList(limit?: number, offset?: number, options?: any) {
        return MotivosParaBaixaPrisaoApiFp(this.configuration).motivosParaBaixaPrisaoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MotivoBaixaPrisao} body 
     * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosParaBaixaPrisaoApi
     */
    public motivosParaBaixaPrisaoPartialUpdate(body: MotivoBaixaPrisao, id: number, options?: any) {
        return MotivosParaBaixaPrisaoApiFp(this.configuration).motivosParaBaixaPrisaoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosParaBaixaPrisaoApi
     */
    public motivosParaBaixaPrisaoRead(id: number, options?: any) {
        return MotivosParaBaixaPrisaoApiFp(this.configuration).motivosParaBaixaPrisaoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MotivoBaixaPrisao} body 
     * @param {number} id A unique integer value identifying this Motivo para Baixa de Prisão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotivosParaBaixaPrisaoApi
     */
    public motivosParaBaixaPrisaoUpdate(body: MotivoBaixaPrisao, id: number, options?: any) {
        return MotivosParaBaixaPrisaoApiFp(this.configuration).motivosParaBaixaPrisaoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MoveisApi - fetch parameter creator
 * @export
 */
export const MoveisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Movel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisCreate(body: Movel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling moveisCreate.');
            }
            const localVarPath = `/moveis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Movel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveisDelete.');
            }
            const localVarPath = `/moveis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/moveis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Movel} body 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisPartialUpdate(body: Movel, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling moveisPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveisPartialUpdate.');
            }
            const localVarPath = `/moveis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Movel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveisRead.');
            }
            const localVarPath = `/moveis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Movel} body 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisUpdate(body: Movel, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling moveisUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveisUpdate.');
            }
            const localVarPath = `/moveis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Movel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoveisApi - functional programming interface
 * @export
 */
export const MoveisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Movel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisCreate(body: Movel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Movel> {
            const localVarFetchArgs = MoveisApiFetchParamCreator(configuration).moveisCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MoveisApiFetchParamCreator(configuration).moveisDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20082> {
            const localVarFetchArgs = MoveisApiFetchParamCreator(configuration).moveisList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Movel} body 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisPartialUpdate(body: Movel, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Movel> {
            const localVarFetchArgs = MoveisApiFetchParamCreator(configuration).moveisPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Movel> {
            const localVarFetchArgs = MoveisApiFetchParamCreator(configuration).moveisRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Movel} body 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisUpdate(body: Movel, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Movel> {
            const localVarFetchArgs = MoveisApiFetchParamCreator(configuration).moveisUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MoveisApi - factory interface
 * @export
 */
export const MoveisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Movel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisCreate(body: Movel, options?: any) {
            return MoveisApiFp(configuration).moveisCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisDelete(id: number, options?: any) {
            return MoveisApiFp(configuration).moveisDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisList(limit?: number, offset?: number, options?: any) {
            return MoveisApiFp(configuration).moveisList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Movel} body 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisPartialUpdate(body: Movel, id: number, options?: any) {
            return MoveisApiFp(configuration).moveisPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisRead(id: number, options?: any) {
            return MoveisApiFp(configuration).moveisRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Movel} body 
         * @param {number} id A unique integer value identifying this movel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveisUpdate(body: Movel, id: number, options?: any) {
            return MoveisApiFp(configuration).moveisUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * MoveisApi - object-oriented interface
 * @export
 * @class MoveisApi
 * @extends {BaseAPI}
 */
export class MoveisApi extends BaseAPI {
    /**
     * 
     * @param {Movel} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoveisApi
     */
    public moveisCreate(body: Movel, options?: any) {
        return MoveisApiFp(this.configuration).moveisCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this movel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoveisApi
     */
    public moveisDelete(id: number, options?: any) {
        return MoveisApiFp(this.configuration).moveisDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoveisApi
     */
    public moveisList(limit?: number, offset?: number, options?: any) {
        return MoveisApiFp(this.configuration).moveisList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Movel} body 
     * @param {number} id A unique integer value identifying this movel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoveisApi
     */
    public moveisPartialUpdate(body: Movel, id: number, options?: any) {
        return MoveisApiFp(this.configuration).moveisPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this movel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoveisApi
     */
    public moveisRead(id: number, options?: any) {
        return MoveisApiFp(this.configuration).moveisRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Movel} body 
     * @param {number} id A unique integer value identifying this movel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoveisApi
     */
    public moveisUpdate(body: Movel, id: number, options?: any) {
        return MoveisApiFp(this.configuration).moveisUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MudancasDeRegimeApi - fetch parameter creator
 * @export
 */
export const MudancasDeRegimeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeCreate(body: MudancaRegime, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling mudancasDeRegimeCreate.');
            }
            const localVarPath = `/mudancas-de-regime/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MudancaRegime" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling mudancasDeRegimeDelete.');
            }
            const localVarPath = `/mudancas-de-regime/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/mudancas-de-regime/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimePartialUpdate(body: MudancaRegime, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling mudancasDeRegimePartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling mudancasDeRegimePartialUpdate.');
            }
            const localVarPath = `/mudancas-de-regime/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MudancaRegime" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling mudancasDeRegimeRead.');
            }
            const localVarPath = `/mudancas-de-regime/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeUpdate(body: MudancaRegime, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling mudancasDeRegimeUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling mudancasDeRegimeUpdate.');
            }
            const localVarPath = `/mudancas-de-regime/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MudancaRegime" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MudancasDeRegimeApi - functional programming interface
 * @export
 */
export const MudancasDeRegimeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeCreate(body: MudancaRegime, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MudancaRegime> {
            const localVarFetchArgs = MudancasDeRegimeApiFetchParamCreator(configuration).mudancasDeRegimeCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MudancasDeRegimeApiFetchParamCreator(configuration).mudancasDeRegimeDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20083> {
            const localVarFetchArgs = MudancasDeRegimeApiFetchParamCreator(configuration).mudancasDeRegimeList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimePartialUpdate(body: MudancaRegime, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MudancaRegime> {
            const localVarFetchArgs = MudancasDeRegimeApiFetchParamCreator(configuration).mudancasDeRegimePartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MudancaRegime> {
            const localVarFetchArgs = MudancasDeRegimeApiFetchParamCreator(configuration).mudancasDeRegimeRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeUpdate(body: MudancaRegime, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MudancaRegime> {
            const localVarFetchArgs = MudancasDeRegimeApiFetchParamCreator(configuration).mudancasDeRegimeUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MudancasDeRegimeApi - factory interface
 * @export
 */
export const MudancasDeRegimeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeCreate(body: MudancaRegime, options?: any) {
            return MudancasDeRegimeApiFp(configuration).mudancasDeRegimeCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeDelete(id: number, options?: any) {
            return MudancasDeRegimeApiFp(configuration).mudancasDeRegimeDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeList(limit?: number, offset?: number, options?: any) {
            return MudancasDeRegimeApiFp(configuration).mudancasDeRegimeList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimePartialUpdate(body: MudancaRegime, id: number, options?: any) {
            return MudancasDeRegimeApiFp(configuration).mudancasDeRegimePartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeRead(id: number, options?: any) {
            return MudancasDeRegimeApiFp(configuration).mudancasDeRegimeRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MudancaRegime} body 
         * @param {number} id A unique integer value identifying this Mudança de Regime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mudancasDeRegimeUpdate(body: MudancaRegime, id: number, options?: any) {
            return MudancasDeRegimeApiFp(configuration).mudancasDeRegimeUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * MudancasDeRegimeApi - object-oriented interface
 * @export
 * @class MudancasDeRegimeApi
 * @extends {BaseAPI}
 */
export class MudancasDeRegimeApi extends BaseAPI {
    /**
     * 
     * @param {MudancaRegime} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MudancasDeRegimeApi
     */
    public mudancasDeRegimeCreate(body: MudancaRegime, options?: any) {
        return MudancasDeRegimeApiFp(this.configuration).mudancasDeRegimeCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Mudança de Regime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MudancasDeRegimeApi
     */
    public mudancasDeRegimeDelete(id: number, options?: any) {
        return MudancasDeRegimeApiFp(this.configuration).mudancasDeRegimeDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MudancasDeRegimeApi
     */
    public mudancasDeRegimeList(limit?: number, offset?: number, options?: any) {
        return MudancasDeRegimeApiFp(this.configuration).mudancasDeRegimeList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MudancaRegime} body 
     * @param {number} id A unique integer value identifying this Mudança de Regime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MudancasDeRegimeApi
     */
    public mudancasDeRegimePartialUpdate(body: MudancaRegime, id: number, options?: any) {
        return MudancasDeRegimeApiFp(this.configuration).mudancasDeRegimePartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Mudança de Regime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MudancasDeRegimeApi
     */
    public mudancasDeRegimeRead(id: number, options?: any) {
        return MudancasDeRegimeApiFp(this.configuration).mudancasDeRegimeRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MudancaRegime} body 
     * @param {number} id A unique integer value identifying this Mudança de Regime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MudancasDeRegimeApi
     */
    public mudancasDeRegimeUpdate(body: MudancaRegime, id: number, options?: any) {
        return MudancasDeRegimeApiFp(this.configuration).mudancasDeRegimeUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MunicipiosApi - fetch parameter creator
 * @export
 */
export const MunicipiosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Municipio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosCreate(body: Municipio, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling municipiosCreate.');
            }
            const localVarPath = `/municipios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Municipio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling municipiosDelete.');
            }
            const localVarPath = `/municipios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [estado] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosList(estado?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/municipios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (estado !== undefined) {
                localVarQueryParameter['estado'] = estado;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Municipio} body 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosPartialUpdate(body: Municipio, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling municipiosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling municipiosPartialUpdate.');
            }
            const localVarPath = `/municipios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Municipio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling municipiosRead.');
            }
            const localVarPath = `/municipios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Municipio} body 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosUpdate(body: Municipio, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling municipiosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling municipiosUpdate.');
            }
            const localVarPath = `/municipios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Municipio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MunicipiosApi - functional programming interface
 * @export
 */
export const MunicipiosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Municipio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosCreate(body: Municipio, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Municipio> {
            const localVarFetchArgs = MunicipiosApiFetchParamCreator(configuration).municipiosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MunicipiosApiFetchParamCreator(configuration).municipiosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [estado] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosList(estado?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20084> {
            const localVarFetchArgs = MunicipiosApiFetchParamCreator(configuration).municipiosList(estado, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Municipio} body 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosPartialUpdate(body: Municipio, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Municipio> {
            const localVarFetchArgs = MunicipiosApiFetchParamCreator(configuration).municipiosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Municipio> {
            const localVarFetchArgs = MunicipiosApiFetchParamCreator(configuration).municipiosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Municipio} body 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosUpdate(body: Municipio, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Municipio> {
            const localVarFetchArgs = MunicipiosApiFetchParamCreator(configuration).municipiosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MunicipiosApi - factory interface
 * @export
 */
export const MunicipiosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Municipio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosCreate(body: Municipio, options?: any) {
            return MunicipiosApiFp(configuration).municipiosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosDelete(id: number, options?: any) {
            return MunicipiosApiFp(configuration).municipiosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [estado] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosList(estado?: string, limit?: number, offset?: number, options?: any) {
            return MunicipiosApiFp(configuration).municipiosList(estado, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Municipio} body 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosPartialUpdate(body: Municipio, id: number, options?: any) {
            return MunicipiosApiFp(configuration).municipiosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosRead(id: number, options?: any) {
            return MunicipiosApiFp(configuration).municipiosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Municipio} body 
         * @param {number} id A unique integer value identifying this Município.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        municipiosUpdate(body: Municipio, id: number, options?: any) {
            return MunicipiosApiFp(configuration).municipiosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * MunicipiosApi - object-oriented interface
 * @export
 * @class MunicipiosApi
 * @extends {BaseAPI}
 */
export class MunicipiosApi extends BaseAPI {
    /**
     * 
     * @param {Municipio} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipiosApi
     */
    public municipiosCreate(body: Municipio, options?: any) {
        return MunicipiosApiFp(this.configuration).municipiosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Município.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipiosApi
     */
    public municipiosDelete(id: number, options?: any) {
        return MunicipiosApiFp(this.configuration).municipiosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [estado] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipiosApi
     */
    public municipiosList(estado?: string, limit?: number, offset?: number, options?: any) {
        return MunicipiosApiFp(this.configuration).municipiosList(estado, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Municipio} body 
     * @param {number} id A unique integer value identifying this Município.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipiosApi
     */
    public municipiosPartialUpdate(body: Municipio, id: number, options?: any) {
        return MunicipiosApiFp(this.configuration).municipiosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Município.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipiosApi
     */
    public municipiosRead(id: number, options?: any) {
        return MunicipiosApiFp(this.configuration).municipiosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Municipio} body 
     * @param {number} id A unique integer value identifying this Município.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MunicipiosApi
     */
    public municipiosUpdate(body: Municipio, id: number, options?: any) {
        return MunicipiosApiFp(this.configuration).municipiosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * NucleosApi - fetch parameter creator
 * @export
 */
export const NucleosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Nucleo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosCreate(body: Nucleo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling nucleosCreate.');
            }
            const localVarPath = `/nucleos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Nucleo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling nucleosDelete.');
            }
            const localVarPath = `/nucleos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/nucleos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Nucleo} body 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosPartialUpdate(body: Nucleo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling nucleosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling nucleosPartialUpdate.');
            }
            const localVarPath = `/nucleos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Nucleo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling nucleosRead.');
            }
            const localVarPath = `/nucleos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Nucleo} body 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosUpdate(body: Nucleo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling nucleosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling nucleosUpdate.');
            }
            const localVarPath = `/nucleos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Nucleo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NucleosApi - functional programming interface
 * @export
 */
export const NucleosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Nucleo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosCreate(body: Nucleo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Nucleo> {
            const localVarFetchArgs = NucleosApiFetchParamCreator(configuration).nucleosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NucleosApiFetchParamCreator(configuration).nucleosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20085> {
            const localVarFetchArgs = NucleosApiFetchParamCreator(configuration).nucleosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Nucleo} body 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosPartialUpdate(body: Nucleo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Nucleo> {
            const localVarFetchArgs = NucleosApiFetchParamCreator(configuration).nucleosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Nucleo> {
            const localVarFetchArgs = NucleosApiFetchParamCreator(configuration).nucleosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Nucleo} body 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosUpdate(body: Nucleo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Nucleo> {
            const localVarFetchArgs = NucleosApiFetchParamCreator(configuration).nucleosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NucleosApi - factory interface
 * @export
 */
export const NucleosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Nucleo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosCreate(body: Nucleo, options?: any) {
            return NucleosApiFp(configuration).nucleosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosDelete(id: number, options?: any) {
            return NucleosApiFp(configuration).nucleosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosList(limit?: number, offset?: number, options?: any) {
            return NucleosApiFp(configuration).nucleosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Nucleo} body 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosPartialUpdate(body: Nucleo, id: number, options?: any) {
            return NucleosApiFp(configuration).nucleosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosRead(id: number, options?: any) {
            return NucleosApiFp(configuration).nucleosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Nucleo} body 
         * @param {number} id A unique integer value identifying this Núcleo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nucleosUpdate(body: Nucleo, id: number, options?: any) {
            return NucleosApiFp(configuration).nucleosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * NucleosApi - object-oriented interface
 * @export
 * @class NucleosApi
 * @extends {BaseAPI}
 */
export class NucleosApi extends BaseAPI {
    /**
     * 
     * @param {Nucleo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleosApi
     */
    public nucleosCreate(body: Nucleo, options?: any) {
        return NucleosApiFp(this.configuration).nucleosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Núcleo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleosApi
     */
    public nucleosDelete(id: number, options?: any) {
        return NucleosApiFp(this.configuration).nucleosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleosApi
     */
    public nucleosList(limit?: number, offset?: number, options?: any) {
        return NucleosApiFp(this.configuration).nucleosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Nucleo} body 
     * @param {number} id A unique integer value identifying this Núcleo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleosApi
     */
    public nucleosPartialUpdate(body: Nucleo, id: number, options?: any) {
        return NucleosApiFp(this.configuration).nucleosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Núcleo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleosApi
     */
    public nucleosRead(id: number, options?: any) {
        return NucleosApiFp(this.configuration).nucleosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Nucleo} body 
     * @param {number} id A unique integer value identifying this Núcleo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleosApi
     */
    public nucleosUpdate(body: Nucleo, id: number, options?: any) {
        return NucleosApiFp(this.configuration).nucleosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * OrientacoesSexuaisApi - fetch parameter creator
 * @export
 */
export const OrientacoesSexuaisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisCreate(body: OrientacaoSexual, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling orientacoesSexuaisCreate.');
            }
            const localVarPath = `/orientacoes-sexuais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrientacaoSexual" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orientacoesSexuaisDelete.');
            }
            const localVarPath = `/orientacoes-sexuais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/orientacoes-sexuais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisPartialUpdate(body: OrientacaoSexual, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling orientacoesSexuaisPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orientacoesSexuaisPartialUpdate.');
            }
            const localVarPath = `/orientacoes-sexuais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrientacaoSexual" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orientacoesSexuaisRead.');
            }
            const localVarPath = `/orientacoes-sexuais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisUpdate(body: OrientacaoSexual, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling orientacoesSexuaisUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orientacoesSexuaisUpdate.');
            }
            const localVarPath = `/orientacoes-sexuais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrientacaoSexual" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrientacoesSexuaisApi - functional programming interface
 * @export
 */
export const OrientacoesSexuaisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisCreate(body: OrientacaoSexual, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrientacaoSexual> {
            const localVarFetchArgs = OrientacoesSexuaisApiFetchParamCreator(configuration).orientacoesSexuaisCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrientacoesSexuaisApiFetchParamCreator(configuration).orientacoesSexuaisDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20086> {
            const localVarFetchArgs = OrientacoesSexuaisApiFetchParamCreator(configuration).orientacoesSexuaisList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisPartialUpdate(body: OrientacaoSexual, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrientacaoSexual> {
            const localVarFetchArgs = OrientacoesSexuaisApiFetchParamCreator(configuration).orientacoesSexuaisPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrientacaoSexual> {
            const localVarFetchArgs = OrientacoesSexuaisApiFetchParamCreator(configuration).orientacoesSexuaisRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisUpdate(body: OrientacaoSexual, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrientacaoSexual> {
            const localVarFetchArgs = OrientacoesSexuaisApiFetchParamCreator(configuration).orientacoesSexuaisUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrientacoesSexuaisApi - factory interface
 * @export
 */
export const OrientacoesSexuaisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisCreate(body: OrientacaoSexual, options?: any) {
            return OrientacoesSexuaisApiFp(configuration).orientacoesSexuaisCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisDelete(id: number, options?: any) {
            return OrientacoesSexuaisApiFp(configuration).orientacoesSexuaisDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisList(limit?: number, offset?: number, options?: any) {
            return OrientacoesSexuaisApiFp(configuration).orientacoesSexuaisList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisPartialUpdate(body: OrientacaoSexual, id: number, options?: any) {
            return OrientacoesSexuaisApiFp(configuration).orientacoesSexuaisPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisRead(id: number, options?: any) {
            return OrientacoesSexuaisApiFp(configuration).orientacoesSexuaisRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {OrientacaoSexual} body 
         * @param {number} id A unique integer value identifying this Orientação Sexual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orientacoesSexuaisUpdate(body: OrientacaoSexual, id: number, options?: any) {
            return OrientacoesSexuaisApiFp(configuration).orientacoesSexuaisUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * OrientacoesSexuaisApi - object-oriented interface
 * @export
 * @class OrientacoesSexuaisApi
 * @extends {BaseAPI}
 */
export class OrientacoesSexuaisApi extends BaseAPI {
    /**
     * 
     * @param {OrientacaoSexual} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrientacoesSexuaisApi
     */
    public orientacoesSexuaisCreate(body: OrientacaoSexual, options?: any) {
        return OrientacoesSexuaisApiFp(this.configuration).orientacoesSexuaisCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Orientação Sexual.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrientacoesSexuaisApi
     */
    public orientacoesSexuaisDelete(id: number, options?: any) {
        return OrientacoesSexuaisApiFp(this.configuration).orientacoesSexuaisDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrientacoesSexuaisApi
     */
    public orientacoesSexuaisList(limit?: number, offset?: number, options?: any) {
        return OrientacoesSexuaisApiFp(this.configuration).orientacoesSexuaisList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {OrientacaoSexual} body 
     * @param {number} id A unique integer value identifying this Orientação Sexual.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrientacoesSexuaisApi
     */
    public orientacoesSexuaisPartialUpdate(body: OrientacaoSexual, id: number, options?: any) {
        return OrientacoesSexuaisApiFp(this.configuration).orientacoesSexuaisPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Orientação Sexual.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrientacoesSexuaisApi
     */
    public orientacoesSexuaisRead(id: number, options?: any) {
        return OrientacoesSexuaisApiFp(this.configuration).orientacoesSexuaisRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {OrientacaoSexual} body 
     * @param {number} id A unique integer value identifying this Orientação Sexual.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrientacoesSexuaisApi
     */
    public orientacoesSexuaisUpdate(body: OrientacaoSexual, id: number, options?: any) {
        return OrientacoesSexuaisApiFp(this.configuration).orientacoesSexuaisUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PainelApi - fetch parameter creator
 * @export
 */
export const PainelApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} comarca 
         * @param {string} situacao 
         * @param {string} [predio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        painelRecepcaoList(comarca: string, situacao: string, predio?: string, options: any = {}): FetchArgs {
            // verify required parameter 'comarca' is not null or undefined
            if (comarca === null || comarca === undefined) {
                throw new RequiredError('comarca','Required parameter comarca was null or undefined when calling painelRecepcaoList.');
            }
            // verify required parameter 'situacao' is not null or undefined
            if (situacao === null || situacao === undefined) {
                throw new RequiredError('situacao','Required parameter situacao was null or undefined when calling painelRecepcaoList.');
            }
            const localVarPath = `/painel/recepcao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (comarca !== undefined) {
                localVarQueryParameter['comarca'] = comarca;
            }

            if (predio !== undefined) {
                localVarQueryParameter['predio'] = predio;
            }

            if (situacao !== undefined) {
                localVarQueryParameter['situacao'] = situacao;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PainelApi - functional programming interface
 * @export
 */
export const PainelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} comarca 
         * @param {string} situacao 
         * @param {string} [predio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        painelRecepcaoList(comarca: string, situacao: string, predio?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtendimentoRecepcao> {
            const localVarFetchArgs = PainelApiFetchParamCreator(configuration).painelRecepcaoList(comarca, situacao, predio, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PainelApi - factory interface
 * @export
 */
export const PainelApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} comarca 
         * @param {string} situacao 
         * @param {string} [predio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        painelRecepcaoList(comarca: string, situacao: string, predio?: string, options?: any) {
            return PainelApiFp(configuration).painelRecepcaoList(comarca, situacao, predio, options)(fetch, basePath);
        },
    };
};

/**
 * PainelApi - object-oriented interface
 * @export
 * @class PainelApi
 * @extends {BaseAPI}
 */
export class PainelApi extends BaseAPI {
    /**
     * 
     * @param {string} comarca 
     * @param {string} situacao 
     * @param {string} [predio] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PainelApi
     */
    public painelRecepcaoList(comarca: string, situacao: string, predio?: string, options?: any) {
        return PainelApiFp(this.configuration).painelRecepcaoList(comarca, situacao, predio, options)(this.fetch, this.basePath);
    }

}
/**
 * PaisesApi - fetch parameter creator
 * @export
 */
export const PaisesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pais} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesCreate(body: Pais, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling paisesCreate.');
            }
            const localVarPath = `/paises/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pais" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling paisesDelete.');
            }
            const localVarPath = `/paises/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/paises/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pais} body 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesPartialUpdate(body: Pais, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling paisesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling paisesPartialUpdate.');
            }
            const localVarPath = `/paises/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pais" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling paisesRead.');
            }
            const localVarPath = `/paises/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pais} body 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesUpdate(body: Pais, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling paisesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling paisesUpdate.');
            }
            const localVarPath = `/paises/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Pais" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaisesApi - functional programming interface
 * @export
 */
export const PaisesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pais} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesCreate(body: Pais, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pais> {
            const localVarFetchArgs = PaisesApiFetchParamCreator(configuration).paisesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PaisesApiFetchParamCreator(configuration).paisesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20087> {
            const localVarFetchArgs = PaisesApiFetchParamCreator(configuration).paisesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Pais} body 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesPartialUpdate(body: Pais, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pais> {
            const localVarFetchArgs = PaisesApiFetchParamCreator(configuration).paisesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pais> {
            const localVarFetchArgs = PaisesApiFetchParamCreator(configuration).paisesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Pais} body 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesUpdate(body: Pais, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pais> {
            const localVarFetchArgs = PaisesApiFetchParamCreator(configuration).paisesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaisesApi - factory interface
 * @export
 */
export const PaisesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Pais} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesCreate(body: Pais, options?: any) {
            return PaisesApiFp(configuration).paisesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesDelete(id: number, options?: any) {
            return PaisesApiFp(configuration).paisesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesList(limit?: number, offset?: number, options?: any) {
            return PaisesApiFp(configuration).paisesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Pais} body 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesPartialUpdate(body: Pais, id: number, options?: any) {
            return PaisesApiFp(configuration).paisesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesRead(id: number, options?: any) {
            return PaisesApiFp(configuration).paisesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Pais} body 
         * @param {number} id A unique integer value identifying this País.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paisesUpdate(body: Pais, id: number, options?: any) {
            return PaisesApiFp(configuration).paisesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PaisesApi - object-oriented interface
 * @export
 * @class PaisesApi
 * @extends {BaseAPI}
 */
export class PaisesApi extends BaseAPI {
    /**
     * 
     * @param {Pais} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaisesApi
     */
    public paisesCreate(body: Pais, options?: any) {
        return PaisesApiFp(this.configuration).paisesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this País.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaisesApi
     */
    public paisesDelete(id: number, options?: any) {
        return PaisesApiFp(this.configuration).paisesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaisesApi
     */
    public paisesList(limit?: number, offset?: number, options?: any) {
        return PaisesApiFp(this.configuration).paisesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Pais} body 
     * @param {number} id A unique integer value identifying this País.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaisesApi
     */
    public paisesPartialUpdate(body: Pais, id: number, options?: any) {
        return PaisesApiFp(this.configuration).paisesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this País.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaisesApi
     */
    public paisesRead(id: number, options?: any) {
        return PaisesApiFp(this.configuration).paisesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Pais} body 
     * @param {number} id A unique integer value identifying this País.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaisesApi
     */
    public paisesUpdate(body: Pais, id: number, options?: any) {
        return PaisesApiFp(this.configuration).paisesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PapeisApi - fetch parameter creator
 * @export
 */
export const PapeisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Papel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisCreate(body: Papel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling papeisCreate.');
            }
            const localVarPath = `/papeis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Papel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling papeisDelete.');
            }
            const localVarPath = `/papeis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/papeis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Papel} body 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisPartialUpdate(body: Papel, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling papeisPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling papeisPartialUpdate.');
            }
            const localVarPath = `/papeis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Papel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling papeisRead.');
            }
            const localVarPath = `/papeis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Papel} body 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisUpdate(body: Papel, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling papeisUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling papeisUpdate.');
            }
            const localVarPath = `/papeis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Papel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PapeisApi - functional programming interface
 * @export
 */
export const PapeisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Papel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisCreate(body: Papel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Papel> {
            const localVarFetchArgs = PapeisApiFetchParamCreator(configuration).papeisCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PapeisApiFetchParamCreator(configuration).papeisDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20088> {
            const localVarFetchArgs = PapeisApiFetchParamCreator(configuration).papeisList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Papel} body 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisPartialUpdate(body: Papel, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Papel> {
            const localVarFetchArgs = PapeisApiFetchParamCreator(configuration).papeisPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Papel> {
            const localVarFetchArgs = PapeisApiFetchParamCreator(configuration).papeisRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Papel} body 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisUpdate(body: Papel, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Papel> {
            const localVarFetchArgs = PapeisApiFetchParamCreator(configuration).papeisUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PapeisApi - factory interface
 * @export
 */
export const PapeisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Papel} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisCreate(body: Papel, options?: any) {
            return PapeisApiFp(configuration).papeisCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisDelete(id: number, options?: any) {
            return PapeisApiFp(configuration).papeisDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisList(limit?: number, offset?: number, options?: any) {
            return PapeisApiFp(configuration).papeisList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Papel} body 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisPartialUpdate(body: Papel, id: number, options?: any) {
            return PapeisApiFp(configuration).papeisPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisRead(id: number, options?: any) {
            return PapeisApiFp(configuration).papeisRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Papel} body 
         * @param {number} id A unique integer value identifying this Papel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papeisUpdate(body: Papel, id: number, options?: any) {
            return PapeisApiFp(configuration).papeisUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PapeisApi - object-oriented interface
 * @export
 * @class PapeisApi
 * @extends {BaseAPI}
 */
export class PapeisApi extends BaseAPI {
    /**
     * 
     * @param {Papel} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PapeisApi
     */
    public papeisCreate(body: Papel, options?: any) {
        return PapeisApiFp(this.configuration).papeisCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Papel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PapeisApi
     */
    public papeisDelete(id: number, options?: any) {
        return PapeisApiFp(this.configuration).papeisDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PapeisApi
     */
    public papeisList(limit?: number, offset?: number, options?: any) {
        return PapeisApiFp(this.configuration).papeisList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Papel} body 
     * @param {number} id A unique integer value identifying this Papel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PapeisApi
     */
    public papeisPartialUpdate(body: Papel, id: number, options?: any) {
        return PapeisApiFp(this.configuration).papeisPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Papel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PapeisApi
     */
    public papeisRead(id: number, options?: any) {
        return PapeisApiFp(this.configuration).papeisRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Papel} body 
     * @param {number} id A unique integer value identifying this Papel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PapeisApi
     */
    public papeisUpdate(body: Papel, id: number, options?: any) {
        return PapeisApiFp(this.configuration).papeisUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PastasDocumentosApi - fetch parameter creator
 * @export
 */
export const PastasDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosCreate(body: PastaDocumento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pastasDocumentosCreate.');
            }
            const localVarPath = `/pastas-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PastaDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pastasDocumentosDelete.');
            }
            const localVarPath = `/pastas-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/pastas-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosPartialUpdate(body: PastaDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pastasDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pastasDocumentosPartialUpdate.');
            }
            const localVarPath = `/pastas-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PastaDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pastasDocumentosRead.');
            }
            const localVarPath = `/pastas-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosUpdate(body: PastaDocumento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pastasDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pastasDocumentosUpdate.');
            }
            const localVarPath = `/pastas-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PastaDocumento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PastasDocumentosApi - functional programming interface
 * @export
 */
export const PastasDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosCreate(body: PastaDocumento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PastaDocumento> {
            const localVarFetchArgs = PastasDocumentosApiFetchParamCreator(configuration).pastasDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PastasDocumentosApiFetchParamCreator(configuration).pastasDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20089> {
            const localVarFetchArgs = PastasDocumentosApiFetchParamCreator(configuration).pastasDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosPartialUpdate(body: PastaDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PastaDocumento> {
            const localVarFetchArgs = PastasDocumentosApiFetchParamCreator(configuration).pastasDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PastaDocumento> {
            const localVarFetchArgs = PastasDocumentosApiFetchParamCreator(configuration).pastasDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosUpdate(body: PastaDocumento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PastaDocumento> {
            const localVarFetchArgs = PastasDocumentosApiFetchParamCreator(configuration).pastasDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PastasDocumentosApi - factory interface
 * @export
 */
export const PastasDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosCreate(body: PastaDocumento, options?: any) {
            return PastasDocumentosApiFp(configuration).pastasDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosDelete(id: number, options?: any) {
            return PastasDocumentosApiFp(configuration).pastasDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosList(limit?: number, offset?: number, options?: any) {
            return PastasDocumentosApiFp(configuration).pastasDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosPartialUpdate(body: PastaDocumento, id: number, options?: any) {
            return PastasDocumentosApiFp(configuration).pastasDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosRead(id: number, options?: any) {
            return PastasDocumentosApiFp(configuration).pastasDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PastaDocumento} body 
         * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pastasDocumentosUpdate(body: PastaDocumento, id: number, options?: any) {
            return PastasDocumentosApiFp(configuration).pastasDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PastasDocumentosApi - object-oriented interface
 * @export
 * @class PastasDocumentosApi
 * @extends {BaseAPI}
 */
export class PastasDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {PastaDocumento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PastasDocumentosApi
     */
    public pastasDocumentosCreate(body: PastaDocumento, options?: any) {
        return PastasDocumentosApiFp(this.configuration).pastasDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PastasDocumentosApi
     */
    public pastasDocumentosDelete(id: number, options?: any) {
        return PastasDocumentosApiFp(this.configuration).pastasDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PastasDocumentosApi
     */
    public pastasDocumentosList(limit?: number, offset?: number, options?: any) {
        return PastasDocumentosApiFp(this.configuration).pastasDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PastaDocumento} body 
     * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PastasDocumentosApi
     */
    public pastasDocumentosPartialUpdate(body: PastaDocumento, id: number, options?: any) {
        return PastasDocumentosApiFp(this.configuration).pastasDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PastasDocumentosApi
     */
    public pastasDocumentosRead(id: number, options?: any) {
        return PastasDocumentosApiFp(this.configuration).pastasDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PastaDocumento} body 
     * @param {number} id A unique integer value identifying this Pastas doc. atendimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PastasDocumentosApi
     */
    public pastasDocumentosUpdate(body: PastaDocumento, id: number, options?: any) {
        return PastasDocumentosApiFp(this.configuration).pastasDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PatrimoniaisApi - fetch parameter creator
 * @export
 */
export const PatrimoniaisApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Patrimonial} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisCreate(body: Patrimonial, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patrimoniaisCreate.');
            }
            const localVarPath = `/patrimoniais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Patrimonial" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patrimoniaisDelete.');
            }
            const localVarPath = `/patrimoniais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/patrimoniais/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Patrimonial} body 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisPartialUpdate(body: Patrimonial, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patrimoniaisPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patrimoniaisPartialUpdate.');
            }
            const localVarPath = `/patrimoniais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Patrimonial" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patrimoniaisRead.');
            }
            const localVarPath = `/patrimoniais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Patrimonial} body 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisUpdate(body: Patrimonial, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patrimoniaisUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patrimoniaisUpdate.');
            }
            const localVarPath = `/patrimoniais/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Patrimonial" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatrimoniaisApi - functional programming interface
 * @export
 */
export const PatrimoniaisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Patrimonial} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisCreate(body: Patrimonial, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Patrimonial> {
            const localVarFetchArgs = PatrimoniaisApiFetchParamCreator(configuration).patrimoniaisCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PatrimoniaisApiFetchParamCreator(configuration).patrimoniaisDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20090> {
            const localVarFetchArgs = PatrimoniaisApiFetchParamCreator(configuration).patrimoniaisList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Patrimonial} body 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisPartialUpdate(body: Patrimonial, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Patrimonial> {
            const localVarFetchArgs = PatrimoniaisApiFetchParamCreator(configuration).patrimoniaisPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Patrimonial> {
            const localVarFetchArgs = PatrimoniaisApiFetchParamCreator(configuration).patrimoniaisRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Patrimonial} body 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisUpdate(body: Patrimonial, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Patrimonial> {
            const localVarFetchArgs = PatrimoniaisApiFetchParamCreator(configuration).patrimoniaisUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PatrimoniaisApi - factory interface
 * @export
 */
export const PatrimoniaisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Patrimonial} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisCreate(body: Patrimonial, options?: any) {
            return PatrimoniaisApiFp(configuration).patrimoniaisCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisDelete(id: number, options?: any) {
            return PatrimoniaisApiFp(configuration).patrimoniaisDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisList(limit?: number, offset?: number, options?: any) {
            return PatrimoniaisApiFp(configuration).patrimoniaisList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Patrimonial} body 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisPartialUpdate(body: Patrimonial, id: number, options?: any) {
            return PatrimoniaisApiFp(configuration).patrimoniaisPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisRead(id: number, options?: any) {
            return PatrimoniaisApiFp(configuration).patrimoniaisRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Patrimonial} body 
         * @param {number} id A unique integer value identifying this patrimonial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniaisUpdate(body: Patrimonial, id: number, options?: any) {
            return PatrimoniaisApiFp(configuration).patrimoniaisUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PatrimoniaisApi - object-oriented interface
 * @export
 * @class PatrimoniaisApi
 * @extends {BaseAPI}
 */
export class PatrimoniaisApi extends BaseAPI {
    /**
     * 
     * @param {Patrimonial} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniaisApi
     */
    public patrimoniaisCreate(body: Patrimonial, options?: any) {
        return PatrimoniaisApiFp(this.configuration).patrimoniaisCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this patrimonial.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniaisApi
     */
    public patrimoniaisDelete(id: number, options?: any) {
        return PatrimoniaisApiFp(this.configuration).patrimoniaisDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniaisApi
     */
    public patrimoniaisList(limit?: number, offset?: number, options?: any) {
        return PatrimoniaisApiFp(this.configuration).patrimoniaisList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Patrimonial} body 
     * @param {number} id A unique integer value identifying this patrimonial.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniaisApi
     */
    public patrimoniaisPartialUpdate(body: Patrimonial, id: number, options?: any) {
        return PatrimoniaisApiFp(this.configuration).patrimoniaisPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this patrimonial.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniaisApi
     */
    public patrimoniaisRead(id: number, options?: any) {
        return PatrimoniaisApiFp(this.configuration).patrimoniaisRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Patrimonial} body 
     * @param {number} id A unique integer value identifying this patrimonial.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniaisApi
     */
    public patrimoniaisUpdate(body: Patrimonial, id: number, options?: any) {
        return PatrimoniaisApiFp(this.configuration).patrimoniaisUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PatrimoniosApi - fetch parameter creator
 * @export
 */
export const PatrimoniosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Patrimonio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosCreate(body: Patrimonio, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patrimoniosCreate.');
            }
            const localVarPath = `/patrimonios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Patrimonio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patrimoniosDelete.');
            }
            const localVarPath = `/patrimonios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/patrimonios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Patrimonio} body 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosPartialUpdate(body: Patrimonio, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patrimoniosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patrimoniosPartialUpdate.');
            }
            const localVarPath = `/patrimonios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Patrimonio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patrimoniosRead.');
            }
            const localVarPath = `/patrimonios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Patrimonio} body 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosUpdate(body: Patrimonio, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patrimoniosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patrimoniosUpdate.');
            }
            const localVarPath = `/patrimonios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Patrimonio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatrimoniosApi - functional programming interface
 * @export
 */
export const PatrimoniosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Patrimonio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosCreate(body: Patrimonio, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Patrimonio> {
            const localVarFetchArgs = PatrimoniosApiFetchParamCreator(configuration).patrimoniosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PatrimoniosApiFetchParamCreator(configuration).patrimoniosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20091> {
            const localVarFetchArgs = PatrimoniosApiFetchParamCreator(configuration).patrimoniosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Patrimonio} body 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosPartialUpdate(body: Patrimonio, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Patrimonio> {
            const localVarFetchArgs = PatrimoniosApiFetchParamCreator(configuration).patrimoniosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Patrimonio> {
            const localVarFetchArgs = PatrimoniosApiFetchParamCreator(configuration).patrimoniosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Patrimonio} body 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosUpdate(body: Patrimonio, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Patrimonio> {
            const localVarFetchArgs = PatrimoniosApiFetchParamCreator(configuration).patrimoniosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PatrimoniosApi - factory interface
 * @export
 */
export const PatrimoniosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Patrimonio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosCreate(body: Patrimonio, options?: any) {
            return PatrimoniosApiFp(configuration).patrimoniosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosDelete(id: number, options?: any) {
            return PatrimoniosApiFp(configuration).patrimoniosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosList(limit?: number, offset?: number, options?: any) {
            return PatrimoniosApiFp(configuration).patrimoniosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Patrimonio} body 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosPartialUpdate(body: Patrimonio, id: number, options?: any) {
            return PatrimoniosApiFp(configuration).patrimoniosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosRead(id: number, options?: any) {
            return PatrimoniosApiFp(configuration).patrimoniosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Patrimonio} body 
         * @param {number} id A unique integer value identifying this patrimonio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patrimoniosUpdate(body: Patrimonio, id: number, options?: any) {
            return PatrimoniosApiFp(configuration).patrimoniosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PatrimoniosApi - object-oriented interface
 * @export
 * @class PatrimoniosApi
 * @extends {BaseAPI}
 */
export class PatrimoniosApi extends BaseAPI {
    /**
     * 
     * @param {Patrimonio} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniosApi
     */
    public patrimoniosCreate(body: Patrimonio, options?: any) {
        return PatrimoniosApiFp(this.configuration).patrimoniosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this patrimonio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniosApi
     */
    public patrimoniosDelete(id: number, options?: any) {
        return PatrimoniosApiFp(this.configuration).patrimoniosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniosApi
     */
    public patrimoniosList(limit?: number, offset?: number, options?: any) {
        return PatrimoniosApiFp(this.configuration).patrimoniosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Patrimonio} body 
     * @param {number} id A unique integer value identifying this patrimonio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniosApi
     */
    public patrimoniosPartialUpdate(body: Patrimonio, id: number, options?: any) {
        return PatrimoniosApiFp(this.configuration).patrimoniosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this patrimonio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniosApi
     */
    public patrimoniosRead(id: number, options?: any) {
        return PatrimoniosApiFp(this.configuration).patrimoniosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Patrimonio} body 
     * @param {number} id A unique integer value identifying this patrimonio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoniosApi
     */
    public patrimoniosUpdate(body: Patrimonio, id: number, options?: any) {
        return PatrimoniosApiFp(this.configuration).patrimoniosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PenasRestritivasApi - fetch parameter creator
 * @export
 */
export const PenasRestritivasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasCreate(body: PenaRestritiva, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling penasRestritivasCreate.');
            }
            const localVarPath = `/penas-restritivas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PenaRestritiva" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling penasRestritivasDelete.');
            }
            const localVarPath = `/penas-restritivas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/penas-restritivas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasPartialUpdate(body: PenaRestritiva, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling penasRestritivasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling penasRestritivasPartialUpdate.');
            }
            const localVarPath = `/penas-restritivas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PenaRestritiva" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling penasRestritivasRead.');
            }
            const localVarPath = `/penas-restritivas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasUpdate(body: PenaRestritiva, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling penasRestritivasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling penasRestritivasUpdate.');
            }
            const localVarPath = `/penas-restritivas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PenaRestritiva" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PenasRestritivasApi - functional programming interface
 * @export
 */
export const PenasRestritivasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasCreate(body: PenaRestritiva, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PenaRestritiva> {
            const localVarFetchArgs = PenasRestritivasApiFetchParamCreator(configuration).penasRestritivasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PenasRestritivasApiFetchParamCreator(configuration).penasRestritivasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20092> {
            const localVarFetchArgs = PenasRestritivasApiFetchParamCreator(configuration).penasRestritivasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasPartialUpdate(body: PenaRestritiva, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PenaRestritiva> {
            const localVarFetchArgs = PenasRestritivasApiFetchParamCreator(configuration).penasRestritivasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PenaRestritiva> {
            const localVarFetchArgs = PenasRestritivasApiFetchParamCreator(configuration).penasRestritivasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasUpdate(body: PenaRestritiva, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PenaRestritiva> {
            const localVarFetchArgs = PenasRestritivasApiFetchParamCreator(configuration).penasRestritivasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PenasRestritivasApi - factory interface
 * @export
 */
export const PenasRestritivasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasCreate(body: PenaRestritiva, options?: any) {
            return PenasRestritivasApiFp(configuration).penasRestritivasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasDelete(id: number, options?: any) {
            return PenasRestritivasApiFp(configuration).penasRestritivasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasList(limit?: number, offset?: number, options?: any) {
            return PenasRestritivasApiFp(configuration).penasRestritivasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasPartialUpdate(body: PenaRestritiva, id: number, options?: any) {
            return PenasRestritivasApiFp(configuration).penasRestritivasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasRead(id: number, options?: any) {
            return PenasRestritivasApiFp(configuration).penasRestritivasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PenaRestritiva} body 
         * @param {number} id A unique integer value identifying this Pena Restritiva.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penasRestritivasUpdate(body: PenaRestritiva, id: number, options?: any) {
            return PenasRestritivasApiFp(configuration).penasRestritivasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PenasRestritivasApi - object-oriented interface
 * @export
 * @class PenasRestritivasApi
 * @extends {BaseAPI}
 */
export class PenasRestritivasApi extends BaseAPI {
    /**
     * 
     * @param {PenaRestritiva} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PenasRestritivasApi
     */
    public penasRestritivasCreate(body: PenaRestritiva, options?: any) {
        return PenasRestritivasApiFp(this.configuration).penasRestritivasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Pena Restritiva.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PenasRestritivasApi
     */
    public penasRestritivasDelete(id: number, options?: any) {
        return PenasRestritivasApiFp(this.configuration).penasRestritivasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PenasRestritivasApi
     */
    public penasRestritivasList(limit?: number, offset?: number, options?: any) {
        return PenasRestritivasApiFp(this.configuration).penasRestritivasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PenaRestritiva} body 
     * @param {number} id A unique integer value identifying this Pena Restritiva.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PenasRestritivasApi
     */
    public penasRestritivasPartialUpdate(body: PenaRestritiva, id: number, options?: any) {
        return PenasRestritivasApiFp(this.configuration).penasRestritivasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Pena Restritiva.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PenasRestritivasApi
     */
    public penasRestritivasRead(id: number, options?: any) {
        return PenasRestritivasApiFp(this.configuration).penasRestritivasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PenaRestritiva} body 
     * @param {number} id A unique integer value identifying this Pena Restritiva.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PenasRestritivasApi
     */
    public penasRestritivasUpdate(body: PenaRestritiva, id: number, options?: any) {
        return PenasRestritivasApiFp(this.configuration).penasRestritivasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PerfilApi - fetch parameter creator
 * @export
 */
export const PerfilApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfilDefensoriasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/perfil/defensorias/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfilSupervisoresList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/perfil/supervisores/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PerfilApi - functional programming interface
 * @export
 */
export const PerfilApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfilDefensoriasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20093> {
            const localVarFetchArgs = PerfilApiFetchParamCreator(configuration).perfilDefensoriasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfilSupervisoresList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20093> {
            const localVarFetchArgs = PerfilApiFetchParamCreator(configuration).perfilSupervisoresList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PerfilApi - factory interface
 * @export
 */
export const PerfilApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfilDefensoriasList(limit?: number, offset?: number, options?: any) {
            return PerfilApiFp(configuration).perfilDefensoriasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfilSupervisoresList(limit?: number, offset?: number, options?: any) {
            return PerfilApiFp(configuration).perfilSupervisoresList(limit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * PerfilApi - object-oriented interface
 * @export
 * @class PerfilApi
 * @extends {BaseAPI}
 */
export class PerfilApi extends BaseAPI {
    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerfilApi
     */
    public perfilDefensoriasList(limit?: number, offset?: number, options?: any) {
        return PerfilApiFp(this.configuration).perfilDefensoriasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerfilApi
     */
    public perfilSupervisoresList(limit?: number, offset?: number, options?: any) {
        return PerfilApiFp(this.configuration).perfilSupervisoresList(limit, offset, options)(this.fetch, this.basePath);
    }

}
/**
 * PerfisCamposObrigatoriosApi - fetch parameter creator
 * @export
 */
export const PerfisCamposObrigatoriosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosCreate(body: PerfilCamposObrigatorios, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling perfisCamposObrigatoriosCreate.');
            }
            const localVarPath = `/perfis-campos-obrigatorios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PerfilCamposObrigatorios" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling perfisCamposObrigatoriosDelete.');
            }
            const localVarPath = `/perfis-campos-obrigatorios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/perfis-campos-obrigatorios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosPartialUpdate(body: PerfilCamposObrigatorios, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling perfisCamposObrigatoriosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling perfisCamposObrigatoriosPartialUpdate.');
            }
            const localVarPath = `/perfis-campos-obrigatorios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PerfilCamposObrigatorios" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling perfisCamposObrigatoriosRead.');
            }
            const localVarPath = `/perfis-campos-obrigatorios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosUpdate(body: PerfilCamposObrigatorios, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling perfisCamposObrigatoriosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling perfisCamposObrigatoriosUpdate.');
            }
            const localVarPath = `/perfis-campos-obrigatorios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PerfilCamposObrigatorios" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PerfisCamposObrigatoriosApi - functional programming interface
 * @export
 */
export const PerfisCamposObrigatoriosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosCreate(body: PerfilCamposObrigatorios, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerfilCamposObrigatorios> {
            const localVarFetchArgs = PerfisCamposObrigatoriosApiFetchParamCreator(configuration).perfisCamposObrigatoriosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PerfisCamposObrigatoriosApiFetchParamCreator(configuration).perfisCamposObrigatoriosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20094> {
            const localVarFetchArgs = PerfisCamposObrigatoriosApiFetchParamCreator(configuration).perfisCamposObrigatoriosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosPartialUpdate(body: PerfilCamposObrigatorios, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerfilCamposObrigatorios> {
            const localVarFetchArgs = PerfisCamposObrigatoriosApiFetchParamCreator(configuration).perfisCamposObrigatoriosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerfilCamposObrigatorios> {
            const localVarFetchArgs = PerfisCamposObrigatoriosApiFetchParamCreator(configuration).perfisCamposObrigatoriosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosUpdate(body: PerfilCamposObrigatorios, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerfilCamposObrigatorios> {
            const localVarFetchArgs = PerfisCamposObrigatoriosApiFetchParamCreator(configuration).perfisCamposObrigatoriosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PerfisCamposObrigatoriosApi - factory interface
 * @export
 */
export const PerfisCamposObrigatoriosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosCreate(body: PerfilCamposObrigatorios, options?: any) {
            return PerfisCamposObrigatoriosApiFp(configuration).perfisCamposObrigatoriosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosDelete(id: number, options?: any) {
            return PerfisCamposObrigatoriosApiFp(configuration).perfisCamposObrigatoriosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosList(limit?: number, offset?: number, options?: any) {
            return PerfisCamposObrigatoriosApiFp(configuration).perfisCamposObrigatoriosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosPartialUpdate(body: PerfilCamposObrigatorios, id: number, options?: any) {
            return PerfisCamposObrigatoriosApiFp(configuration).perfisCamposObrigatoriosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosRead(id: number, options?: any) {
            return PerfisCamposObrigatoriosApiFp(configuration).perfisCamposObrigatoriosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PerfilCamposObrigatorios} body 
         * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perfisCamposObrigatoriosUpdate(body: PerfilCamposObrigatorios, id: number, options?: any) {
            return PerfisCamposObrigatoriosApiFp(configuration).perfisCamposObrigatoriosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PerfisCamposObrigatoriosApi - object-oriented interface
 * @export
 * @class PerfisCamposObrigatoriosApi
 * @extends {BaseAPI}
 */
export class PerfisCamposObrigatoriosApi extends BaseAPI {
    /**
     * 
     * @param {PerfilCamposObrigatorios} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerfisCamposObrigatoriosApi
     */
    public perfisCamposObrigatoriosCreate(body: PerfilCamposObrigatorios, options?: any) {
        return PerfisCamposObrigatoriosApiFp(this.configuration).perfisCamposObrigatoriosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerfisCamposObrigatoriosApi
     */
    public perfisCamposObrigatoriosDelete(id: number, options?: any) {
        return PerfisCamposObrigatoriosApiFp(this.configuration).perfisCamposObrigatoriosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerfisCamposObrigatoriosApi
     */
    public perfisCamposObrigatoriosList(limit?: number, offset?: number, options?: any) {
        return PerfisCamposObrigatoriosApiFp(this.configuration).perfisCamposObrigatoriosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PerfilCamposObrigatorios} body 
     * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerfisCamposObrigatoriosApi
     */
    public perfisCamposObrigatoriosPartialUpdate(body: PerfilCamposObrigatorios, id: number, options?: any) {
        return PerfisCamposObrigatoriosApiFp(this.configuration).perfisCamposObrigatoriosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerfisCamposObrigatoriosApi
     */
    public perfisCamposObrigatoriosRead(id: number, options?: any) {
        return PerfisCamposObrigatoriosApiFp(this.configuration).perfisCamposObrigatoriosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PerfilCamposObrigatorios} body 
     * @param {number} id A unique integer value identifying this Perfil de Campos Obrigatórios.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerfisCamposObrigatoriosApi
     */
    public perfisCamposObrigatoriosUpdate(body: PerfilCamposObrigatorios, id: number, options?: any) {
        return PerfisCamposObrigatoriosApiFp(this.configuration).perfisCamposObrigatoriosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PerguntasApi - fetch parameter creator
 * @export
 */
export const PerguntasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasCreate(body: PerguntaAtendimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling perguntasCreate.');
            }
            const localVarPath = `/perguntas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PerguntaAtendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling perguntasDelete.');
            }
            const localVarPath = `/perguntas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/perguntas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasPartialUpdate(body: PerguntaAtendimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling perguntasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling perguntasPartialUpdate.');
            }
            const localVarPath = `/perguntas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PerguntaAtendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling perguntasRead.');
            }
            const localVarPath = `/perguntas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasUpdate(body: PerguntaAtendimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling perguntasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling perguntasUpdate.');
            }
            const localVarPath = `/perguntas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PerguntaAtendimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PerguntasApi - functional programming interface
 * @export
 */
export const PerguntasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasCreate(body: PerguntaAtendimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerguntaAtendimento> {
            const localVarFetchArgs = PerguntasApiFetchParamCreator(configuration).perguntasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PerguntasApiFetchParamCreator(configuration).perguntasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20095> {
            const localVarFetchArgs = PerguntasApiFetchParamCreator(configuration).perguntasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasPartialUpdate(body: PerguntaAtendimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerguntaAtendimento> {
            const localVarFetchArgs = PerguntasApiFetchParamCreator(configuration).perguntasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerguntaAtendimento> {
            const localVarFetchArgs = PerguntasApiFetchParamCreator(configuration).perguntasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasUpdate(body: PerguntaAtendimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PerguntaAtendimento> {
            const localVarFetchArgs = PerguntasApiFetchParamCreator(configuration).perguntasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PerguntasApi - factory interface
 * @export
 */
export const PerguntasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasCreate(body: PerguntaAtendimento, options?: any) {
            return PerguntasApiFp(configuration).perguntasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasDelete(id: number, options?: any) {
            return PerguntasApiFp(configuration).perguntasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasList(limit?: number, offset?: number, options?: any) {
            return PerguntasApiFp(configuration).perguntasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasPartialUpdate(body: PerguntaAtendimento, id: number, options?: any) {
            return PerguntasApiFp(configuration).perguntasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasRead(id: number, options?: any) {
            return PerguntasApiFp(configuration).perguntasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PerguntaAtendimento} body 
         * @param {number} id A unique integer value identifying this Pergunta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        perguntasUpdate(body: PerguntaAtendimento, id: number, options?: any) {
            return PerguntasApiFp(configuration).perguntasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PerguntasApi - object-oriented interface
 * @export
 * @class PerguntasApi
 * @extends {BaseAPI}
 */
export class PerguntasApi extends BaseAPI {
    /**
     * 
     * @param {PerguntaAtendimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerguntasApi
     */
    public perguntasCreate(body: PerguntaAtendimento, options?: any) {
        return PerguntasApiFp(this.configuration).perguntasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Pergunta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerguntasApi
     */
    public perguntasDelete(id: number, options?: any) {
        return PerguntasApiFp(this.configuration).perguntasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerguntasApi
     */
    public perguntasList(limit?: number, offset?: number, options?: any) {
        return PerguntasApiFp(this.configuration).perguntasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PerguntaAtendimento} body 
     * @param {number} id A unique integer value identifying this Pergunta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerguntasApi
     */
    public perguntasPartialUpdate(body: PerguntaAtendimento, id: number, options?: any) {
        return PerguntasApiFp(this.configuration).perguntasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Pergunta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerguntasApi
     */
    public perguntasRead(id: number, options?: any) {
        return PerguntasApiFp(this.configuration).perguntasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PerguntaAtendimento} body 
     * @param {number} id A unique integer value identifying this Pergunta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerguntasApi
     */
    public perguntasUpdate(body: PerguntaAtendimento, id: number, options?: any) {
        return PerguntasApiFp(this.configuration).perguntasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PermissoesApi - fetch parameter creator
 * @export
 */
export const PermissoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissoesList(options: any = {}): FetchArgs {
            const localVarPath = `/permissoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissoesApi - functional programming interface
 * @export
 */
export const PermissoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissoesList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsuarioPermissoes> {
            const localVarFetchArgs = PermissoesApiFetchParamCreator(configuration).permissoesList(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PermissoesApi - factory interface
 * @export
 */
export const PermissoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissoesList(options?: any) {
            return PermissoesApiFp(configuration).permissoesList(options)(fetch, basePath);
        },
    };
};

/**
 * PermissoesApi - object-oriented interface
 * @export
 * @class PermissoesApi
 * @extends {BaseAPI}
 */
export class PermissoesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissoesApi
     */
    public permissoesList(options?: any) {
        return PermissoesApiFp(this.configuration).permissoesList(options)(this.fetch, this.basePath);
    }

}
/**
 * PeticoesTotaisPorMesApi - fetch parameter creator
 * @export
 */
export const PeticoesTotaisPorMesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} usuario_defensor_id 
         * @param {number} area_id 
         * @param {number} ano 
         * @param {number} mes 
         * @param {string} [vara_id] Valores múltiplos podem ser separados por vírgulas.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peticoesTotaisPorMesList(usuario_defensor_id: number, area_id: number, ano: number, mes: number, vara_id?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'usuario_defensor_id' is not null or undefined
            if (usuario_defensor_id === null || usuario_defensor_id === undefined) {
                throw new RequiredError('usuario_defensor_id','Required parameter usuario_defensor_id was null or undefined when calling peticoesTotaisPorMesList.');
            }
            // verify required parameter 'area_id' is not null or undefined
            if (area_id === null || area_id === undefined) {
                throw new RequiredError('area_id','Required parameter area_id was null or undefined when calling peticoesTotaisPorMesList.');
            }
            // verify required parameter 'ano' is not null or undefined
            if (ano === null || ano === undefined) {
                throw new RequiredError('ano','Required parameter ano was null or undefined when calling peticoesTotaisPorMesList.');
            }
            // verify required parameter 'mes' is not null or undefined
            if (mes === null || mes === undefined) {
                throw new RequiredError('mes','Required parameter mes was null or undefined when calling peticoesTotaisPorMesList.');
            }
            const localVarPath = `/peticoes-totais-por-mes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (usuario_defensor_id !== undefined) {
                localVarQueryParameter['usuario_defensor_id'] = usuario_defensor_id;
            }

            if (area_id !== undefined) {
                localVarQueryParameter['area_id'] = area_id;
            }

            if (vara_id !== undefined) {
                localVarQueryParameter['vara_id'] = vara_id;
            }

            if (ano !== undefined) {
                localVarQueryParameter['ano'] = ano;
            }

            if (mes !== undefined) {
                localVarQueryParameter['mes'] = mes;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeticoesTotaisPorMesApi - functional programming interface
 * @export
 */
export const PeticoesTotaisPorMesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} usuario_defensor_id 
         * @param {number} area_id 
         * @param {number} ano 
         * @param {number} mes 
         * @param {string} [vara_id] Valores múltiplos podem ser separados por vírgulas.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peticoesTotaisPorMesList(usuario_defensor_id: number, area_id: number, ano: number, mes: number, vara_id?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20096> {
            const localVarFetchArgs = PeticoesTotaisPorMesApiFetchParamCreator(configuration).peticoesTotaisPorMesList(usuario_defensor_id, area_id, ano, mes, vara_id, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PeticoesTotaisPorMesApi - factory interface
 * @export
 */
export const PeticoesTotaisPorMesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} usuario_defensor_id 
         * @param {number} area_id 
         * @param {number} ano 
         * @param {number} mes 
         * @param {string} [vara_id] Valores múltiplos podem ser separados por vírgulas.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peticoesTotaisPorMesList(usuario_defensor_id: number, area_id: number, ano: number, mes: number, vara_id?: string, limit?: number, offset?: number, options?: any) {
            return PeticoesTotaisPorMesApiFp(configuration).peticoesTotaisPorMesList(usuario_defensor_id, area_id, ano, mes, vara_id, limit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * PeticoesTotaisPorMesApi - object-oriented interface
 * @export
 * @class PeticoesTotaisPorMesApi
 * @extends {BaseAPI}
 */
export class PeticoesTotaisPorMesApi extends BaseAPI {
    /**
     * 
     * @param {number} usuario_defensor_id 
     * @param {number} area_id 
     * @param {number} ano 
     * @param {number} mes 
     * @param {string} [vara_id] Valores múltiplos podem ser separados por vírgulas.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeticoesTotaisPorMesApi
     */
    public peticoesTotaisPorMesList(usuario_defensor_id: number, area_id: number, ano: number, mes: number, vara_id?: string, limit?: number, offset?: number, options?: any) {
        return PeticoesTotaisPorMesApiFp(this.configuration).peticoesTotaisPorMesList(usuario_defensor_id, area_id, ano, mes, vara_id, limit, offset, options)(this.fetch, this.basePath);
    }

}
/**
 * PrediosApi - fetch parameter creator
 * @export
 */
export const PrediosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PredioCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosCreate(body: PredioCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prediosCreate.');
            }
            const localVarPath = `/predios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PredioCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prediosDelete.');
            }
            const localVarPath = `/predios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] A search term.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosList(search?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/predios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PredioList} body 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosPartialUpdate(body: PredioList, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prediosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prediosPartialUpdate.');
            }
            const localVarPath = `/predios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PredioList" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prediosRead.');
            }
            const localVarPath = `/predios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PredioCreate} body 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosUpdate(body: PredioCreate, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prediosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prediosUpdate.');
            }
            const localVarPath = `/predios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PredioCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrediosApi - functional programming interface
 * @export
 */
export const PrediosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PredioCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosCreate(body: PredioCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PredioCreate> {
            const localVarFetchArgs = PrediosApiFetchParamCreator(configuration).prediosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PrediosApiFetchParamCreator(configuration).prediosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [search] A search term.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosList(search?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20097> {
            const localVarFetchArgs = PrediosApiFetchParamCreator(configuration).prediosList(search, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PredioList} body 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosPartialUpdate(body: PredioList, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PredioList> {
            const localVarFetchArgs = PrediosApiFetchParamCreator(configuration).prediosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PredioRetrieve> {
            const localVarFetchArgs = PrediosApiFetchParamCreator(configuration).prediosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PredioCreate} body 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosUpdate(body: PredioCreate, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PredioCreate> {
            const localVarFetchArgs = PrediosApiFetchParamCreator(configuration).prediosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PrediosApi - factory interface
 * @export
 */
export const PrediosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PredioCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosCreate(body: PredioCreate, options?: any) {
            return PrediosApiFp(configuration).prediosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosDelete(id: number, options?: any) {
            return PrediosApiFp(configuration).prediosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [search] A search term.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosList(search?: string, limit?: number, offset?: number, options?: any) {
            return PrediosApiFp(configuration).prediosList(search, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PredioList} body 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosPartialUpdate(body: PredioList, id: number, options?: any) {
            return PrediosApiFp(configuration).prediosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosRead(id: number, options?: any) {
            return PrediosApiFp(configuration).prediosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PredioCreate} body 
         * @param {number} id A unique integer value identifying this Prédio.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prediosUpdate(body: PredioCreate, id: number, options?: any) {
            return PrediosApiFp(configuration).prediosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PrediosApi - object-oriented interface
 * @export
 * @class PrediosApi
 * @extends {BaseAPI}
 */
export class PrediosApi extends BaseAPI {
    /**
     * 
     * @param {PredioCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrediosApi
     */
    public prediosCreate(body: PredioCreate, options?: any) {
        return PrediosApiFp(this.configuration).prediosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Prédio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrediosApi
     */
    public prediosDelete(id: number, options?: any) {
        return PrediosApiFp(this.configuration).prediosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [search] A search term.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrediosApi
     */
    public prediosList(search?: string, limit?: number, offset?: number, options?: any) {
        return PrediosApiFp(this.configuration).prediosList(search, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PredioList} body 
     * @param {number} id A unique integer value identifying this Prédio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrediosApi
     */
    public prediosPartialUpdate(body: PredioList, id: number, options?: any) {
        return PrediosApiFp(this.configuration).prediosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Prédio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrediosApi
     */
    public prediosRead(id: number, options?: any) {
        return PrediosApiFp(this.configuration).prediosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PredioCreate} body 
     * @param {number} id A unique integer value identifying this Prédio.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrediosApi
     */
    public prediosUpdate(body: PredioCreate, id: number, options?: any) {
        return PrediosApiFp(this.configuration).prediosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PrioridadesApi - fetch parameter creator
 * @export
 */
export const PrioridadesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesCreate(body: ParteProcesso, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prioridadesCreate.');
            }
            const localVarPath = `/prioridades/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prioridadesDelete.');
            }
            const localVarPath = `/prioridades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/prioridades/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesPartialUpdate(body: ParteProcesso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prioridadesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prioridadesPartialUpdate.');
            }
            const localVarPath = `/prioridades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prioridadesRead.');
            }
            const localVarPath = `/prioridades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesUpdate(body: ParteProcesso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prioridadesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prioridadesUpdate.');
            }
            const localVarPath = `/prioridades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrioridadesApi - functional programming interface
 * @export
 */
export const PrioridadesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesCreate(body: ParteProcesso, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteProcesso> {
            const localVarFetchArgs = PrioridadesApiFetchParamCreator(configuration).prioridadesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PrioridadesApiFetchParamCreator(configuration).prioridadesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20098> {
            const localVarFetchArgs = PrioridadesApiFetchParamCreator(configuration).prioridadesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesPartialUpdate(body: ParteProcesso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteProcesso> {
            const localVarFetchArgs = PrioridadesApiFetchParamCreator(configuration).prioridadesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteProcesso> {
            const localVarFetchArgs = PrioridadesApiFetchParamCreator(configuration).prioridadesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesUpdate(body: ParteProcesso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteProcesso> {
            const localVarFetchArgs = PrioridadesApiFetchParamCreator(configuration).prioridadesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PrioridadesApi - factory interface
 * @export
 */
export const PrioridadesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesCreate(body: ParteProcesso, options?: any) {
            return PrioridadesApiFp(configuration).prioridadesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesDelete(id: number, options?: any) {
            return PrioridadesApiFp(configuration).prioridadesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesList(limit?: number, offset?: number, options?: any) {
            return PrioridadesApiFp(configuration).prioridadesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesPartialUpdate(body: ParteProcesso, id: number, options?: any) {
            return PrioridadesApiFp(configuration).prioridadesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesRead(id: number, options?: any) {
            return PrioridadesApiFp(configuration).prioridadesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Prioridade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prioridadesUpdate(body: ParteProcesso, id: number, options?: any) {
            return PrioridadesApiFp(configuration).prioridadesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PrioridadesApi - object-oriented interface
 * @export
 * @class PrioridadesApi
 * @extends {BaseAPI}
 */
export class PrioridadesApi extends BaseAPI {
    /**
     * 
     * @param {ParteProcesso} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrioridadesApi
     */
    public prioridadesCreate(body: ParteProcesso, options?: any) {
        return PrioridadesApiFp(this.configuration).prioridadesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Prioridade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrioridadesApi
     */
    public prioridadesDelete(id: number, options?: any) {
        return PrioridadesApiFp(this.configuration).prioridadesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrioridadesApi
     */
    public prioridadesList(limit?: number, offset?: number, options?: any) {
        return PrioridadesApiFp(this.configuration).prioridadesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ParteProcesso} body 
     * @param {number} id A unique integer value identifying this Prioridade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrioridadesApi
     */
    public prioridadesPartialUpdate(body: ParteProcesso, id: number, options?: any) {
        return PrioridadesApiFp(this.configuration).prioridadesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Prioridade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrioridadesApi
     */
    public prioridadesRead(id: number, options?: any) {
        return PrioridadesApiFp(this.configuration).prioridadesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ParteProcesso} body 
     * @param {number} id A unique integer value identifying this Prioridade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrioridadesApi
     */
    public prioridadesUpdate(body: ParteProcesso, id: number, options?: any) {
        return PrioridadesApiFp(this.configuration).prioridadesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PrisoesApi - fetch parameter creator
 * @export
 */
export const PrisoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Prisao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesCreate(body: Prisao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prisoesCreate.');
            }
            const localVarPath = `/prisoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Prisao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prisoesDelete.');
            }
            const localVarPath = `/prisoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/prisoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Prisao} body 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesPartialUpdate(body: Prisao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prisoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prisoesPartialUpdate.');
            }
            const localVarPath = `/prisoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Prisao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prisoesRead.');
            }
            const localVarPath = `/prisoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Prisao} body 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesUpdate(body: Prisao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prisoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling prisoesUpdate.');
            }
            const localVarPath = `/prisoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Prisao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrisoesApi - functional programming interface
 * @export
 */
export const PrisoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Prisao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesCreate(body: Prisao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Prisao> {
            const localVarFetchArgs = PrisoesApiFetchParamCreator(configuration).prisoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PrisoesApiFetchParamCreator(configuration).prisoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20099> {
            const localVarFetchArgs = PrisoesApiFetchParamCreator(configuration).prisoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Prisao} body 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesPartialUpdate(body: Prisao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Prisao> {
            const localVarFetchArgs = PrisoesApiFetchParamCreator(configuration).prisoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Prisao> {
            const localVarFetchArgs = PrisoesApiFetchParamCreator(configuration).prisoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Prisao} body 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesUpdate(body: Prisao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Prisao> {
            const localVarFetchArgs = PrisoesApiFetchParamCreator(configuration).prisoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PrisoesApi - factory interface
 * @export
 */
export const PrisoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Prisao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesCreate(body: Prisao, options?: any) {
            return PrisoesApiFp(configuration).prisoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesDelete(id: number, options?: any) {
            return PrisoesApiFp(configuration).prisoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesList(limit?: number, offset?: number, options?: any) {
            return PrisoesApiFp(configuration).prisoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Prisao} body 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesPartialUpdate(body: Prisao, id: number, options?: any) {
            return PrisoesApiFp(configuration).prisoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesRead(id: number, options?: any) {
            return PrisoesApiFp(configuration).prisoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Prisao} body 
         * @param {number} id A unique integer value identifying this Prisão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prisoesUpdate(body: Prisao, id: number, options?: any) {
            return PrisoesApiFp(configuration).prisoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PrisoesApi - object-oriented interface
 * @export
 * @class PrisoesApi
 * @extends {BaseAPI}
 */
export class PrisoesApi extends BaseAPI {
    /**
     * 
     * @param {Prisao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrisoesApi
     */
    public prisoesCreate(body: Prisao, options?: any) {
        return PrisoesApiFp(this.configuration).prisoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Prisão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrisoesApi
     */
    public prisoesDelete(id: number, options?: any) {
        return PrisoesApiFp(this.configuration).prisoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrisoesApi
     */
    public prisoesList(limit?: number, offset?: number, options?: any) {
        return PrisoesApiFp(this.configuration).prisoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Prisao} body 
     * @param {number} id A unique integer value identifying this Prisão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrisoesApi
     */
    public prisoesPartialUpdate(body: Prisao, id: number, options?: any) {
        return PrisoesApiFp(this.configuration).prisoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Prisão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrisoesApi
     */
    public prisoesRead(id: number, options?: any) {
        return PrisoesApiFp(this.configuration).prisoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Prisao} body 
     * @param {number} id A unique integer value identifying this Prisão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrisoesApi
     */
    public prisoesUpdate(body: Prisao, id: number, options?: any) {
        return PrisoesApiFp(this.configuration).prisoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcedimentosApi - fetch parameter creator
 * @export
 */
export const ProcedimentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Procedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosCreate(body: Procedimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling procedimentosCreate.');
            }
            const localVarPath = `/procedimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Procedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling procedimentosDelete.');
            }
            const localVarPath = `/procedimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/procedimentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Procedimento} body 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosPartialUpdate(body: Procedimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling procedimentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling procedimentosPartialUpdate.');
            }
            const localVarPath = `/procedimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Procedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling procedimentosRead.');
            }
            const localVarPath = `/procedimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Procedimento} body 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosUpdate(body: Procedimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling procedimentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling procedimentosUpdate.');
            }
            const localVarPath = `/procedimentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Procedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcedimentosApi - functional programming interface
 * @export
 */
export const ProcedimentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Procedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosCreate(body: Procedimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Procedimento> {
            const localVarFetchArgs = ProcedimentosApiFetchParamCreator(configuration).procedimentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcedimentosApiFetchParamCreator(configuration).procedimentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200100> {
            const localVarFetchArgs = ProcedimentosApiFetchParamCreator(configuration).procedimentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Procedimento} body 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosPartialUpdate(body: Procedimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Procedimento> {
            const localVarFetchArgs = ProcedimentosApiFetchParamCreator(configuration).procedimentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Procedimento> {
            const localVarFetchArgs = ProcedimentosApiFetchParamCreator(configuration).procedimentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Procedimento} body 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosUpdate(body: Procedimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Procedimento> {
            const localVarFetchArgs = ProcedimentosApiFetchParamCreator(configuration).procedimentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcedimentosApi - factory interface
 * @export
 */
export const ProcedimentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Procedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosCreate(body: Procedimento, options?: any) {
            return ProcedimentosApiFp(configuration).procedimentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosDelete(id: number, options?: any) {
            return ProcedimentosApiFp(configuration).procedimentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosList(limit?: number, offset?: number, options?: any) {
            return ProcedimentosApiFp(configuration).procedimentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Procedimento} body 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosPartialUpdate(body: Procedimento, id: number, options?: any) {
            return ProcedimentosApiFp(configuration).procedimentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosRead(id: number, options?: any) {
            return ProcedimentosApiFp(configuration).procedimentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Procedimento} body 
         * @param {number} id A unique integer value identifying this procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        procedimentosUpdate(body: Procedimento, id: number, options?: any) {
            return ProcedimentosApiFp(configuration).procedimentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcedimentosApi - object-oriented interface
 * @export
 * @class ProcedimentosApi
 * @extends {BaseAPI}
 */
export class ProcedimentosApi extends BaseAPI {
    /**
     * 
     * @param {Procedimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedimentosApi
     */
    public procedimentosCreate(body: Procedimento, options?: any) {
        return ProcedimentosApiFp(this.configuration).procedimentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this procedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedimentosApi
     */
    public procedimentosDelete(id: number, options?: any) {
        return ProcedimentosApiFp(this.configuration).procedimentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedimentosApi
     */
    public procedimentosList(limit?: number, offset?: number, options?: any) {
        return ProcedimentosApiFp(this.configuration).procedimentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Procedimento} body 
     * @param {number} id A unique integer value identifying this procedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedimentosApi
     */
    public procedimentosPartialUpdate(body: Procedimento, id: number, options?: any) {
        return ProcedimentosApiFp(this.configuration).procedimentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this procedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedimentosApi
     */
    public procedimentosRead(id: number, options?: any) {
        return ProcedimentosApiFp(this.configuration).procedimentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Procedimento} body 
     * @param {number} id A unique integer value identifying this procedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedimentosApi
     */
    public procedimentosUpdate(body: Procedimento, id: number, options?: any) {
        return ProcedimentosApiFp(this.configuration).procedimentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosApi - fetch parameter creator
 * @export
 */
export const ProcessosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Processo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosCreate(body: Processo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosCreate.');
            }
            const localVarPath = `/processos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Processo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosDelete.');
            }
            const localVarPath = `/processos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [defensor] 
         * @param {string} [defensoria] 
         * @param {string} [ativo] 
         * @param {string} [incluir_partes] 
         * @param {string} [filtro] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosList(data_inicial?: string, data_final?: string, defensor?: string, defensoria?: string, ativo?: string, incluir_partes?: string, filtro?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (data_inicial !== undefined) {
                localVarQueryParameter['data_inicial'] = data_inicial;
            }

            if (data_final !== undefined) {
                localVarQueryParameter['data_final'] = data_final;
            }

            if (defensor !== undefined) {
                localVarQueryParameter['defensor'] = defensor;
            }

            if (defensoria !== undefined) {
                localVarQueryParameter['defensoria'] = defensoria;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (incluir_partes !== undefined) {
                localVarQueryParameter['incluir_partes'] = incluir_partes;
            }

            if (filtro !== undefined) {
                localVarQueryParameter['filtro'] = filtro;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Processo} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartialUpdate(body: Processo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPartialUpdate.');
            }
            const localVarPath = `/processos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Processo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosRead.');
            }
            const localVarPath = `/processos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Processo} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosUpdate(body: Processo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosUpdate.');
            }
            const localVarPath = `/processos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Processo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosApi - functional programming interface
 * @export
 */
export const ProcessosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Processo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosCreate(body: Processo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Processo> {
            const localVarFetchArgs = ProcessosApiFetchParamCreator(configuration).processosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosApiFetchParamCreator(configuration).processosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [defensor] 
         * @param {string} [defensoria] 
         * @param {string} [ativo] 
         * @param {string} [incluir_partes] 
         * @param {string} [filtro] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosList(data_inicial?: string, data_final?: string, defensor?: string, defensoria?: string, ativo?: string, incluir_partes?: string, filtro?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200110> {
            const localVarFetchArgs = ProcessosApiFetchParamCreator(configuration).processosList(data_inicial, data_final, defensor, defensoria, ativo, incluir_partes, filtro, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Processo} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartialUpdate(body: Processo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Processo> {
            const localVarFetchArgs = ProcessosApiFetchParamCreator(configuration).processosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Processo> {
            const localVarFetchArgs = ProcessosApiFetchParamCreator(configuration).processosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Processo} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosUpdate(body: Processo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Processo> {
            const localVarFetchArgs = ProcessosApiFetchParamCreator(configuration).processosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosApi - factory interface
 * @export
 */
export const ProcessosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Processo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosCreate(body: Processo, options?: any) {
            return ProcessosApiFp(configuration).processosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDelete(id: number, options?: any) {
            return ProcessosApiFp(configuration).processosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [data_inicial] 
         * @param {string} [data_final] 
         * @param {string} [defensor] 
         * @param {string} [defensoria] 
         * @param {string} [ativo] 
         * @param {string} [incluir_partes] 
         * @param {string} [filtro] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosList(data_inicial?: string, data_final?: string, defensor?: string, defensoria?: string, ativo?: string, incluir_partes?: string, filtro?: string, limit?: number, offset?: number, options?: any) {
            return ProcessosApiFp(configuration).processosList(data_inicial, data_final, defensor, defensoria, ativo, incluir_partes, filtro, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Processo} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartialUpdate(body: Processo, id: number, options?: any) {
            return ProcessosApiFp(configuration).processosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosRead(id: number, options?: any) {
            return ProcessosApiFp(configuration).processosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Processo} body 
         * @param {number} id A unique integer value identifying this processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosUpdate(body: Processo, id: number, options?: any) {
            return ProcessosApiFp(configuration).processosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosApi - object-oriented interface
 * @export
 * @class ProcessosApi
 * @extends {BaseAPI}
 */
export class ProcessosApi extends BaseAPI {
    /**
     * 
     * @param {Processo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApi
     */
    public processosCreate(body: Processo, options?: any) {
        return ProcessosApiFp(this.configuration).processosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApi
     */
    public processosDelete(id: number, options?: any) {
        return ProcessosApiFp(this.configuration).processosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [data_inicial] 
     * @param {string} [data_final] 
     * @param {string} [defensor] 
     * @param {string} [defensoria] 
     * @param {string} [ativo] 
     * @param {string} [incluir_partes] 
     * @param {string} [filtro] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApi
     */
    public processosList(data_inicial?: string, data_final?: string, defensor?: string, defensoria?: string, ativo?: string, incluir_partes?: string, filtro?: string, limit?: number, offset?: number, options?: any) {
        return ProcessosApiFp(this.configuration).processosList(data_inicial, data_final, defensor, defensoria, ativo, incluir_partes, filtro, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Processo} body 
     * @param {number} id A unique integer value identifying this processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApi
     */
    public processosPartialUpdate(body: Processo, id: number, options?: any) {
        return ProcessosApiFp(this.configuration).processosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApi
     */
    public processosRead(id: number, options?: any) {
        return ProcessosApiFp(this.configuration).processosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Processo} body 
     * @param {number} id A unique integer value identifying this processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApi
     */
    public processosUpdate(body: Processo, id: number, options?: any) {
        return ProcessosApiFp(this.configuration).processosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosApensosApi - fetch parameter creator
 * @export
 */
export const ProcessosApensosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosCreate(body: ProcessoApenso, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosApensosCreate.');
            }
            const localVarPath = `/processos-apensos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessoApenso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosApensosDelete.');
            }
            const localVarPath = `/processos-apensos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-apensos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosPartialUpdate(body: ProcessoApenso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosApensosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosApensosPartialUpdate.');
            }
            const localVarPath = `/processos-apensos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessoApenso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosApensosRead.');
            }
            const localVarPath = `/processos-apensos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosUpdate(body: ProcessoApenso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosApensosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosApensosUpdate.');
            }
            const localVarPath = `/processos-apensos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessoApenso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosApensosApi - functional programming interface
 * @export
 */
export const ProcessosApensosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosCreate(body: ProcessoApenso, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessoApenso> {
            const localVarFetchArgs = ProcessosApensosApiFetchParamCreator(configuration).processosApensosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosApensosApiFetchParamCreator(configuration).processosApensosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200101> {
            const localVarFetchArgs = ProcessosApensosApiFetchParamCreator(configuration).processosApensosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosPartialUpdate(body: ProcessoApenso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessoApenso> {
            const localVarFetchArgs = ProcessosApensosApiFetchParamCreator(configuration).processosApensosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessoApenso> {
            const localVarFetchArgs = ProcessosApensosApiFetchParamCreator(configuration).processosApensosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosUpdate(body: ProcessoApenso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessoApenso> {
            const localVarFetchArgs = ProcessosApensosApiFetchParamCreator(configuration).processosApensosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosApensosApi - factory interface
 * @export
 */
export const ProcessosApensosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosCreate(body: ProcessoApenso, options?: any) {
            return ProcessosApensosApiFp(configuration).processosApensosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosDelete(id: number, options?: any) {
            return ProcessosApensosApiFp(configuration).processosApensosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosList(limit?: number, offset?: number, options?: any) {
            return ProcessosApensosApiFp(configuration).processosApensosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosPartialUpdate(body: ProcessoApenso, id: number, options?: any) {
            return ProcessosApensosApiFp(configuration).processosApensosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosRead(id: number, options?: any) {
            return ProcessosApensosApiFp(configuration).processosApensosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ProcessoApenso} body 
         * @param {number} id A unique integer value identifying this Apenso de Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosApensosUpdate(body: ProcessoApenso, id: number, options?: any) {
            return ProcessosApensosApiFp(configuration).processosApensosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosApensosApi - object-oriented interface
 * @export
 * @class ProcessosApensosApi
 * @extends {BaseAPI}
 */
export class ProcessosApensosApi extends BaseAPI {
    /**
     * 
     * @param {ProcessoApenso} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApensosApi
     */
    public processosApensosCreate(body: ProcessoApenso, options?: any) {
        return ProcessosApensosApiFp(this.configuration).processosApensosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Apenso de Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApensosApi
     */
    public processosApensosDelete(id: number, options?: any) {
        return ProcessosApensosApiFp(this.configuration).processosApensosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApensosApi
     */
    public processosApensosList(limit?: number, offset?: number, options?: any) {
        return ProcessosApensosApiFp(this.configuration).processosApensosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ProcessoApenso} body 
     * @param {number} id A unique integer value identifying this Apenso de Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApensosApi
     */
    public processosApensosPartialUpdate(body: ProcessoApenso, id: number, options?: any) {
        return ProcessosApensosApiFp(this.configuration).processosApensosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Apenso de Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApensosApi
     */
    public processosApensosRead(id: number, options?: any) {
        return ProcessosApensosApiFp(this.configuration).processosApensosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ProcessoApenso} body 
     * @param {number} id A unique integer value identifying this Apenso de Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosApensosApi
     */
    public processosApensosUpdate(body: ProcessoApenso, id: number, options?: any) {
        return ProcessosApensosApiFp(this.configuration).processosApensosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosAssuntosApi - fetch parameter creator
 * @export
 */
export const ProcessosAssuntosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosCreate(body: ProcessosAssuntos, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosAssuntosCreate.');
            }
            const localVarPath = `/processos-assuntos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessosAssuntos" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosAssuntosDelete.');
            }
            const localVarPath = `/processos-assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-assuntos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosPartialUpdate(body: ProcessosAssuntos, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosAssuntosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosAssuntosPartialUpdate.');
            }
            const localVarPath = `/processos-assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessosAssuntos" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosAssuntosRead.');
            }
            const localVarPath = `/processos-assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosUpdate(body: ProcessosAssuntos, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosAssuntosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosAssuntosUpdate.');
            }
            const localVarPath = `/processos-assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessosAssuntos" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosAssuntosApi - functional programming interface
 * @export
 */
export const ProcessosAssuntosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosCreate(body: ProcessosAssuntos, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessosAssuntos> {
            const localVarFetchArgs = ProcessosAssuntosApiFetchParamCreator(configuration).processosAssuntosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosAssuntosApiFetchParamCreator(configuration).processosAssuntosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200102> {
            const localVarFetchArgs = ProcessosAssuntosApiFetchParamCreator(configuration).processosAssuntosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosPartialUpdate(body: ProcessosAssuntos, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessosAssuntos> {
            const localVarFetchArgs = ProcessosAssuntosApiFetchParamCreator(configuration).processosAssuntosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessosAssuntos> {
            const localVarFetchArgs = ProcessosAssuntosApiFetchParamCreator(configuration).processosAssuntosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosUpdate(body: ProcessosAssuntos, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessosAssuntos> {
            const localVarFetchArgs = ProcessosAssuntosApiFetchParamCreator(configuration).processosAssuntosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosAssuntosApi - factory interface
 * @export
 */
export const ProcessosAssuntosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosCreate(body: ProcessosAssuntos, options?: any) {
            return ProcessosAssuntosApiFp(configuration).processosAssuntosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosDelete(id: number, options?: any) {
            return ProcessosAssuntosApiFp(configuration).processosAssuntosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosList(limit?: number, offset?: number, options?: any) {
            return ProcessosAssuntosApiFp(configuration).processosAssuntosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosPartialUpdate(body: ProcessosAssuntos, id: number, options?: any) {
            return ProcessosAssuntosApiFp(configuration).processosAssuntosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosRead(id: number, options?: any) {
            return ProcessosAssuntosApiFp(configuration).processosAssuntosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ProcessosAssuntos} body 
         * @param {number} id A unique integer value identifying this Assunto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosAssuntosUpdate(body: ProcessosAssuntos, id: number, options?: any) {
            return ProcessosAssuntosApiFp(configuration).processosAssuntosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosAssuntosApi - object-oriented interface
 * @export
 * @class ProcessosAssuntosApi
 * @extends {BaseAPI}
 */
export class ProcessosAssuntosApi extends BaseAPI {
    /**
     * 
     * @param {ProcessosAssuntos} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosAssuntosApi
     */
    public processosAssuntosCreate(body: ProcessosAssuntos, options?: any) {
        return ProcessosAssuntosApiFp(this.configuration).processosAssuntosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Assunto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosAssuntosApi
     */
    public processosAssuntosDelete(id: number, options?: any) {
        return ProcessosAssuntosApiFp(this.configuration).processosAssuntosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosAssuntosApi
     */
    public processosAssuntosList(limit?: number, offset?: number, options?: any) {
        return ProcessosAssuntosApiFp(this.configuration).processosAssuntosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ProcessosAssuntos} body 
     * @param {number} id A unique integer value identifying this Assunto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosAssuntosApi
     */
    public processosAssuntosPartialUpdate(body: ProcessosAssuntos, id: number, options?: any) {
        return ProcessosAssuntosApiFp(this.configuration).processosAssuntosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Assunto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosAssuntosApi
     */
    public processosAssuntosRead(id: number, options?: any) {
        return ProcessosAssuntosApiFp(this.configuration).processosAssuntosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ProcessosAssuntos} body 
     * @param {number} id A unique integer value identifying this Assunto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosAssuntosApi
     */
    public processosAssuntosUpdate(body: ProcessosAssuntos, id: number, options?: any) {
        return ProcessosAssuntosApiFp(this.configuration).processosAssuntosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosClassesApi - fetch parameter creator
 * @export
 */
export const ProcessosClassesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Acao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesCreate(body: Acao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosClassesCreate.');
            }
            const localVarPath = `/processos-classes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Acao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosClassesDelete.');
            }
            const localVarPath = `/processos-classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [judicial] 
         * @param {string} [extrajudicial] 
         * @param {string} [penal] 
         * @param {string} [inquerito] 
         * @param {string} [acao_penal] 
         * @param {string} [execucao_penal] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesList(judicial?: string, extrajudicial?: string, penal?: string, inquerito?: string, acao_penal?: string, execucao_penal?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-classes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (judicial !== undefined) {
                localVarQueryParameter['judicial'] = judicial;
            }

            if (extrajudicial !== undefined) {
                localVarQueryParameter['extrajudicial'] = extrajudicial;
            }

            if (penal !== undefined) {
                localVarQueryParameter['penal'] = penal;
            }

            if (inquerito !== undefined) {
                localVarQueryParameter['inquerito'] = inquerito;
            }

            if (acao_penal !== undefined) {
                localVarQueryParameter['acao_penal'] = acao_penal;
            }

            if (execucao_penal !== undefined) {
                localVarQueryParameter['execucao_penal'] = execucao_penal;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Acao} body 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesPartialUpdate(body: Acao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosClassesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosClassesPartialUpdate.');
            }
            const localVarPath = `/processos-classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Acao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosClassesRead.');
            }
            const localVarPath = `/processos-classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Acao} body 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesUpdate(body: Acao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosClassesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosClassesUpdate.');
            }
            const localVarPath = `/processos-classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Acao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosClassesApi - functional programming interface
 * @export
 */
export const ProcessosClassesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Acao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesCreate(body: Acao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Acao> {
            const localVarFetchArgs = ProcessosClassesApiFetchParamCreator(configuration).processosClassesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosClassesApiFetchParamCreator(configuration).processosClassesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [judicial] 
         * @param {string} [extrajudicial] 
         * @param {string} [penal] 
         * @param {string} [inquerito] 
         * @param {string} [acao_penal] 
         * @param {string} [execucao_penal] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesList(judicial?: string, extrajudicial?: string, penal?: string, inquerito?: string, acao_penal?: string, execucao_penal?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200103> {
            const localVarFetchArgs = ProcessosClassesApiFetchParamCreator(configuration).processosClassesList(judicial, extrajudicial, penal, inquerito, acao_penal, execucao_penal, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Acao} body 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesPartialUpdate(body: Acao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Acao> {
            const localVarFetchArgs = ProcessosClassesApiFetchParamCreator(configuration).processosClassesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Acao> {
            const localVarFetchArgs = ProcessosClassesApiFetchParamCreator(configuration).processosClassesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Acao} body 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesUpdate(body: Acao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Acao> {
            const localVarFetchArgs = ProcessosClassesApiFetchParamCreator(configuration).processosClassesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosClassesApi - factory interface
 * @export
 */
export const ProcessosClassesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Acao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesCreate(body: Acao, options?: any) {
            return ProcessosClassesApiFp(configuration).processosClassesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesDelete(id: number, options?: any) {
            return ProcessosClassesApiFp(configuration).processosClassesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [judicial] 
         * @param {string} [extrajudicial] 
         * @param {string} [penal] 
         * @param {string} [inquerito] 
         * @param {string} [acao_penal] 
         * @param {string} [execucao_penal] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesList(judicial?: string, extrajudicial?: string, penal?: string, inquerito?: string, acao_penal?: string, execucao_penal?: string, limit?: number, offset?: number, options?: any) {
            return ProcessosClassesApiFp(configuration).processosClassesList(judicial, extrajudicial, penal, inquerito, acao_penal, execucao_penal, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Acao} body 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesPartialUpdate(body: Acao, id: number, options?: any) {
            return ProcessosClassesApiFp(configuration).processosClassesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesRead(id: number, options?: any) {
            return ProcessosClassesApiFp(configuration).processosClassesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Acao} body 
         * @param {number} id A unique integer value identifying this Tipo de Ação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosClassesUpdate(body: Acao, id: number, options?: any) {
            return ProcessosClassesApiFp(configuration).processosClassesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosClassesApi - object-oriented interface
 * @export
 * @class ProcessosClassesApi
 * @extends {BaseAPI}
 */
export class ProcessosClassesApi extends BaseAPI {
    /**
     * 
     * @param {Acao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosClassesApi
     */
    public processosClassesCreate(body: Acao, options?: any) {
        return ProcessosClassesApiFp(this.configuration).processosClassesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Ação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosClassesApi
     */
    public processosClassesDelete(id: number, options?: any) {
        return ProcessosClassesApiFp(this.configuration).processosClassesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [judicial] 
     * @param {string} [extrajudicial] 
     * @param {string} [penal] 
     * @param {string} [inquerito] 
     * @param {string} [acao_penal] 
     * @param {string} [execucao_penal] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosClassesApi
     */
    public processosClassesList(judicial?: string, extrajudicial?: string, penal?: string, inquerito?: string, acao_penal?: string, execucao_penal?: string, limit?: number, offset?: number, options?: any) {
        return ProcessosClassesApiFp(this.configuration).processosClassesList(judicial, extrajudicial, penal, inquerito, acao_penal, execucao_penal, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Acao} body 
     * @param {number} id A unique integer value identifying this Tipo de Ação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosClassesApi
     */
    public processosClassesPartialUpdate(body: Acao, id: number, options?: any) {
        return ProcessosClassesApiFp(this.configuration).processosClassesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Ação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosClassesApi
     */
    public processosClassesRead(id: number, options?: any) {
        return ProcessosClassesApiFp(this.configuration).processosClassesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Acao} body 
     * @param {number} id A unique integer value identifying this Tipo de Ação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosClassesApi
     */
    public processosClassesUpdate(body: Acao, id: number, options?: any) {
        return ProcessosClassesApiFp(this.configuration).processosClassesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosDocumentosApi - fetch parameter creator
 * @export
 */
export const ProcessosDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosCreate(body: DocumentoFase, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosDocumentosCreate.');
            }
            const localVarPath = `/processos-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoFase" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosDocumentosDelete.');
            }
            const localVarPath = `/processos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosPartialUpdate(body: DocumentoFase, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosDocumentosPartialUpdate.');
            }
            const localVarPath = `/processos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoFase" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosDocumentosRead.');
            }
            const localVarPath = `/processos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosUpdate(body: DocumentoFase, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosDocumentosUpdate.');
            }
            const localVarPath = `/processos-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoFase" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosDocumentosApi - functional programming interface
 * @export
 */
export const ProcessosDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosCreate(body: DocumentoFase, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoFase> {
            const localVarFetchArgs = ProcessosDocumentosApiFetchParamCreator(configuration).processosDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosDocumentosApiFetchParamCreator(configuration).processosDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200104> {
            const localVarFetchArgs = ProcessosDocumentosApiFetchParamCreator(configuration).processosDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosPartialUpdate(body: DocumentoFase, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoFase> {
            const localVarFetchArgs = ProcessosDocumentosApiFetchParamCreator(configuration).processosDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoFase> {
            const localVarFetchArgs = ProcessosDocumentosApiFetchParamCreator(configuration).processosDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosUpdate(body: DocumentoFase, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoFase> {
            const localVarFetchArgs = ProcessosDocumentosApiFetchParamCreator(configuration).processosDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosDocumentosApi - factory interface
 * @export
 */
export const ProcessosDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosCreate(body: DocumentoFase, options?: any) {
            return ProcessosDocumentosApiFp(configuration).processosDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosDelete(id: number, options?: any) {
            return ProcessosDocumentosApiFp(configuration).processosDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosList(limit?: number, offset?: number, options?: any) {
            return ProcessosDocumentosApiFp(configuration).processosDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosPartialUpdate(body: DocumentoFase, id: number, options?: any) {
            return ProcessosDocumentosApiFp(configuration).processosDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosRead(id: number, options?: any) {
            return ProcessosDocumentosApiFp(configuration).processosDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DocumentoFase} body 
         * @param {number} id A unique integer value identifying this documento fase.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosDocumentosUpdate(body: DocumentoFase, id: number, options?: any) {
            return ProcessosDocumentosApiFp(configuration).processosDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosDocumentosApi - object-oriented interface
 * @export
 * @class ProcessosDocumentosApi
 * @extends {BaseAPI}
 */
export class ProcessosDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {DocumentoFase} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosDocumentosApi
     */
    public processosDocumentosCreate(body: DocumentoFase, options?: any) {
        return ProcessosDocumentosApiFp(this.configuration).processosDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento fase.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosDocumentosApi
     */
    public processosDocumentosDelete(id: number, options?: any) {
        return ProcessosDocumentosApiFp(this.configuration).processosDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosDocumentosApi
     */
    public processosDocumentosList(limit?: number, offset?: number, options?: any) {
        return ProcessosDocumentosApiFp(this.configuration).processosDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DocumentoFase} body 
     * @param {number} id A unique integer value identifying this documento fase.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosDocumentosApi
     */
    public processosDocumentosPartialUpdate(body: DocumentoFase, id: number, options?: any) {
        return ProcessosDocumentosApiFp(this.configuration).processosDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento fase.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosDocumentosApi
     */
    public processosDocumentosRead(id: number, options?: any) {
        return ProcessosDocumentosApiFp(this.configuration).processosDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DocumentoFase} body 
     * @param {number} id A unique integer value identifying this documento fase.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosDocumentosApi
     */
    public processosDocumentosUpdate(body: DocumentoFase, id: number, options?: any) {
        return ProcessosDocumentosApiFp(this.configuration).processosDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosEventosApi - fetch parameter creator
 * @export
 */
export const ProcessosEventosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Fase} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosCreate(body: Fase, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosEventosCreate.');
            }
            const localVarPath = `/processos-eventos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Fase" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosEventosDelete.');
            }
            const localVarPath = `/processos-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-eventos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Fase} body 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosPartialUpdate(body: Fase, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosEventosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosEventosPartialUpdate.');
            }
            const localVarPath = `/processos-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Fase" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosEventosRead.');
            }
            const localVarPath = `/processos-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Fase} body 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosUpdate(body: Fase, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosEventosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosEventosUpdate.');
            }
            const localVarPath = `/processos-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Fase" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosEventosApi - functional programming interface
 * @export
 */
export const ProcessosEventosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Fase} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosCreate(body: Fase, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fase> {
            const localVarFetchArgs = ProcessosEventosApiFetchParamCreator(configuration).processosEventosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosEventosApiFetchParamCreator(configuration).processosEventosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200105> {
            const localVarFetchArgs = ProcessosEventosApiFetchParamCreator(configuration).processosEventosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Fase} body 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosPartialUpdate(body: Fase, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fase> {
            const localVarFetchArgs = ProcessosEventosApiFetchParamCreator(configuration).processosEventosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fase> {
            const localVarFetchArgs = ProcessosEventosApiFetchParamCreator(configuration).processosEventosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Fase} body 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosUpdate(body: Fase, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fase> {
            const localVarFetchArgs = ProcessosEventosApiFetchParamCreator(configuration).processosEventosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosEventosApi - factory interface
 * @export
 */
export const ProcessosEventosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Fase} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosCreate(body: Fase, options?: any) {
            return ProcessosEventosApiFp(configuration).processosEventosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosDelete(id: number, options?: any) {
            return ProcessosEventosApiFp(configuration).processosEventosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosList(limit?: number, offset?: number, options?: any) {
            return ProcessosEventosApiFp(configuration).processosEventosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Fase} body 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosPartialUpdate(body: Fase, id: number, options?: any) {
            return ProcessosEventosApiFp(configuration).processosEventosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosRead(id: number, options?: any) {
            return ProcessosEventosApiFp(configuration).processosEventosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Fase} body 
         * @param {number} id A unique integer value identifying this Fase Processual.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosEventosUpdate(body: Fase, id: number, options?: any) {
            return ProcessosEventosApiFp(configuration).processosEventosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosEventosApi - object-oriented interface
 * @export
 * @class ProcessosEventosApi
 * @extends {BaseAPI}
 */
export class ProcessosEventosApi extends BaseAPI {
    /**
     * 
     * @param {Fase} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosEventosApi
     */
    public processosEventosCreate(body: Fase, options?: any) {
        return ProcessosEventosApiFp(this.configuration).processosEventosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Fase Processual.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosEventosApi
     */
    public processosEventosDelete(id: number, options?: any) {
        return ProcessosEventosApiFp(this.configuration).processosEventosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosEventosApi
     */
    public processosEventosList(limit?: number, offset?: number, options?: any) {
        return ProcessosEventosApiFp(this.configuration).processosEventosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Fase} body 
     * @param {number} id A unique integer value identifying this Fase Processual.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosEventosApi
     */
    public processosEventosPartialUpdate(body: Fase, id: number, options?: any) {
        return ProcessosEventosApiFp(this.configuration).processosEventosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Fase Processual.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosEventosApi
     */
    public processosEventosRead(id: number, options?: any) {
        return ProcessosEventosApiFp(this.configuration).processosEventosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Fase} body 
     * @param {number} id A unique integer value identifying this Fase Processual.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosEventosApi
     */
    public processosEventosUpdate(body: Fase, id: number, options?: any) {
        return ProcessosEventosApiFp(this.configuration).processosEventosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosOutrosParametrosApi - fetch parameter creator
 * @export
 */
export const ProcessosOutrosParametrosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OutroParametro} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosCreate(body: OutroParametro, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosOutrosParametrosCreate.');
            }
            const localVarPath = `/processos-outros-parametros/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OutroParametro" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosOutrosParametrosDelete.');
            }
            const localVarPath = `/processos-outros-parametros/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-outros-parametros/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OutroParametro} body 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosPartialUpdate(body: OutroParametro, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosOutrosParametrosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosOutrosParametrosPartialUpdate.');
            }
            const localVarPath = `/processos-outros-parametros/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OutroParametro" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosOutrosParametrosRead.');
            }
            const localVarPath = `/processos-outros-parametros/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OutroParametro} body 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosUpdate(body: OutroParametro, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosOutrosParametrosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosOutrosParametrosUpdate.');
            }
            const localVarPath = `/processos-outros-parametros/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OutroParametro" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosOutrosParametrosApi - functional programming interface
 * @export
 */
export const ProcessosOutrosParametrosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OutroParametro} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosCreate(body: OutroParametro, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutroParametro> {
            const localVarFetchArgs = ProcessosOutrosParametrosApiFetchParamCreator(configuration).processosOutrosParametrosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosOutrosParametrosApiFetchParamCreator(configuration).processosOutrosParametrosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200106> {
            const localVarFetchArgs = ProcessosOutrosParametrosApiFetchParamCreator(configuration).processosOutrosParametrosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {OutroParametro} body 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosPartialUpdate(body: OutroParametro, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutroParametro> {
            const localVarFetchArgs = ProcessosOutrosParametrosApiFetchParamCreator(configuration).processosOutrosParametrosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutroParametro> {
            const localVarFetchArgs = ProcessosOutrosParametrosApiFetchParamCreator(configuration).processosOutrosParametrosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {OutroParametro} body 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosUpdate(body: OutroParametro, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutroParametro> {
            const localVarFetchArgs = ProcessosOutrosParametrosApiFetchParamCreator(configuration).processosOutrosParametrosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosOutrosParametrosApi - factory interface
 * @export
 */
export const ProcessosOutrosParametrosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {OutroParametro} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosCreate(body: OutroParametro, options?: any) {
            return ProcessosOutrosParametrosApiFp(configuration).processosOutrosParametrosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosDelete(id: number, options?: any) {
            return ProcessosOutrosParametrosApiFp(configuration).processosOutrosParametrosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosList(limit?: number, offset?: number, options?: any) {
            return ProcessosOutrosParametrosApiFp(configuration).processosOutrosParametrosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {OutroParametro} body 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosPartialUpdate(body: OutroParametro, id: number, options?: any) {
            return ProcessosOutrosParametrosApiFp(configuration).processosOutrosParametrosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosRead(id: number, options?: any) {
            return ProcessosOutrosParametrosApiFp(configuration).processosOutrosParametrosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {OutroParametro} body 
         * @param {number} id A unique integer value identifying this Outro Parâmetro.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosOutrosParametrosUpdate(body: OutroParametro, id: number, options?: any) {
            return ProcessosOutrosParametrosApiFp(configuration).processosOutrosParametrosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosOutrosParametrosApi - object-oriented interface
 * @export
 * @class ProcessosOutrosParametrosApi
 * @extends {BaseAPI}
 */
export class ProcessosOutrosParametrosApi extends BaseAPI {
    /**
     * 
     * @param {OutroParametro} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosOutrosParametrosApi
     */
    public processosOutrosParametrosCreate(body: OutroParametro, options?: any) {
        return ProcessosOutrosParametrosApiFp(this.configuration).processosOutrosParametrosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Outro Parâmetro.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosOutrosParametrosApi
     */
    public processosOutrosParametrosDelete(id: number, options?: any) {
        return ProcessosOutrosParametrosApiFp(this.configuration).processosOutrosParametrosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosOutrosParametrosApi
     */
    public processosOutrosParametrosList(limit?: number, offset?: number, options?: any) {
        return ProcessosOutrosParametrosApiFp(this.configuration).processosOutrosParametrosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {OutroParametro} body 
     * @param {number} id A unique integer value identifying this Outro Parâmetro.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosOutrosParametrosApi
     */
    public processosOutrosParametrosPartialUpdate(body: OutroParametro, id: number, options?: any) {
        return ProcessosOutrosParametrosApiFp(this.configuration).processosOutrosParametrosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Outro Parâmetro.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosOutrosParametrosApi
     */
    public processosOutrosParametrosRead(id: number, options?: any) {
        return ProcessosOutrosParametrosApiFp(this.configuration).processosOutrosParametrosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {OutroParametro} body 
     * @param {number} id A unique integer value identifying this Outro Parâmetro.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosOutrosParametrosApi
     */
    public processosOutrosParametrosUpdate(body: OutroParametro, id: number, options?: any) {
        return ProcessosOutrosParametrosApiFp(this.configuration).processosOutrosParametrosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosPartesApi - fetch parameter creator
 * @export
 */
export const ProcessosPartesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesCreate(body: ParteProcesso, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosPartesCreate.');
            }
            const localVarPath = `/processos-partes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPartesDelete.');
            }
            const localVarPath = `/processos-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-partes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesPartialUpdate(body: ParteProcesso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosPartesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPartesPartialUpdate.');
            }
            const localVarPath = `/processos-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPartesRead.');
            }
            const localVarPath = `/processos-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesUpdate(body: ParteProcesso, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosPartesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPartesUpdate.');
            }
            const localVarPath = `/processos-partes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParteProcesso" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosPartesApi - functional programming interface
 * @export
 */
export const ProcessosPartesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesCreate(body: ParteProcesso, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteProcesso> {
            const localVarFetchArgs = ProcessosPartesApiFetchParamCreator(configuration).processosPartesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosPartesApiFetchParamCreator(configuration).processosPartesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20098> {
            const localVarFetchArgs = ProcessosPartesApiFetchParamCreator(configuration).processosPartesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesPartialUpdate(body: ParteProcesso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteProcesso> {
            const localVarFetchArgs = ProcessosPartesApiFetchParamCreator(configuration).processosPartesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteProcesso> {
            const localVarFetchArgs = ProcessosPartesApiFetchParamCreator(configuration).processosPartesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesUpdate(body: ParteProcesso, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParteProcesso> {
            const localVarFetchArgs = ProcessosPartesApiFetchParamCreator(configuration).processosPartesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosPartesApi - factory interface
 * @export
 */
export const ProcessosPartesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesCreate(body: ParteProcesso, options?: any) {
            return ProcessosPartesApiFp(configuration).processosPartesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesDelete(id: number, options?: any) {
            return ProcessosPartesApiFp(configuration).processosPartesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesList(limit?: number, offset?: number, options?: any) {
            return ProcessosPartesApiFp(configuration).processosPartesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesPartialUpdate(body: ParteProcesso, id: number, options?: any) {
            return ProcessosPartesApiFp(configuration).processosPartesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesRead(id: number, options?: any) {
            return ProcessosPartesApiFp(configuration).processosPartesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ParteProcesso} body 
         * @param {number} id A unique integer value identifying this Parte do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPartesUpdate(body: ParteProcesso, id: number, options?: any) {
            return ProcessosPartesApiFp(configuration).processosPartesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosPartesApi - object-oriented interface
 * @export
 * @class ProcessosPartesApi
 * @extends {BaseAPI}
 */
export class ProcessosPartesApi extends BaseAPI {
    /**
     * 
     * @param {ParteProcesso} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPartesApi
     */
    public processosPartesCreate(body: ParteProcesso, options?: any) {
        return ProcessosPartesApiFp(this.configuration).processosPartesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Parte do Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPartesApi
     */
    public processosPartesDelete(id: number, options?: any) {
        return ProcessosPartesApiFp(this.configuration).processosPartesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPartesApi
     */
    public processosPartesList(limit?: number, offset?: number, options?: any) {
        return ProcessosPartesApiFp(this.configuration).processosPartesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ParteProcesso} body 
     * @param {number} id A unique integer value identifying this Parte do Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPartesApi
     */
    public processosPartesPartialUpdate(body: ParteProcesso, id: number, options?: any) {
        return ProcessosPartesApiFp(this.configuration).processosPartesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Parte do Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPartesApi
     */
    public processosPartesRead(id: number, options?: any) {
        return ProcessosPartesApiFp(this.configuration).processosPartesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ParteProcesso} body 
     * @param {number} id A unique integer value identifying this Parte do Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPartesApi
     */
    public processosPartesUpdate(body: ParteProcesso, id: number, options?: any) {
        return ProcessosPartesApiFp(this.configuration).processosPartesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosPoloDestinatarioApi - fetch parameter creator
 * @export
 */
export const ProcessosPoloDestinatarioApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioCreate(body: ProcessoPoloDestinatario, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosPoloDestinatarioCreate.');
            }
            const localVarPath = `/processos-polo-destinatario/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessoPoloDestinatario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPoloDestinatarioDelete.');
            }
            const localVarPath = `/processos-polo-destinatario/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-polo-destinatario/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioPartialUpdate(body: ProcessoPoloDestinatario, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosPoloDestinatarioPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPoloDestinatarioPartialUpdate.');
            }
            const localVarPath = `/processos-polo-destinatario/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessoPoloDestinatario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPoloDestinatarioRead.');
            }
            const localVarPath = `/processos-polo-destinatario/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioUpdate(body: ProcessoPoloDestinatario, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosPoloDestinatarioUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosPoloDestinatarioUpdate.');
            }
            const localVarPath = `/processos-polo-destinatario/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessoPoloDestinatario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosPoloDestinatarioApi - functional programming interface
 * @export
 */
export const ProcessosPoloDestinatarioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioCreate(body: ProcessoPoloDestinatario, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessoPoloDestinatario> {
            const localVarFetchArgs = ProcessosPoloDestinatarioApiFetchParamCreator(configuration).processosPoloDestinatarioCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosPoloDestinatarioApiFetchParamCreator(configuration).processosPoloDestinatarioDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200107> {
            const localVarFetchArgs = ProcessosPoloDestinatarioApiFetchParamCreator(configuration).processosPoloDestinatarioList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioPartialUpdate(body: ProcessoPoloDestinatario, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessoPoloDestinatario> {
            const localVarFetchArgs = ProcessosPoloDestinatarioApiFetchParamCreator(configuration).processosPoloDestinatarioPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessoPoloDestinatario> {
            const localVarFetchArgs = ProcessosPoloDestinatarioApiFetchParamCreator(configuration).processosPoloDestinatarioRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioUpdate(body: ProcessoPoloDestinatario, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessoPoloDestinatario> {
            const localVarFetchArgs = ProcessosPoloDestinatarioApiFetchParamCreator(configuration).processosPoloDestinatarioUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosPoloDestinatarioApi - factory interface
 * @export
 */
export const ProcessosPoloDestinatarioApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioCreate(body: ProcessoPoloDestinatario, options?: any) {
            return ProcessosPoloDestinatarioApiFp(configuration).processosPoloDestinatarioCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioDelete(id: number, options?: any) {
            return ProcessosPoloDestinatarioApiFp(configuration).processosPoloDestinatarioDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioList(limit?: number, offset?: number, options?: any) {
            return ProcessosPoloDestinatarioApiFp(configuration).processosPoloDestinatarioList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioPartialUpdate(body: ProcessoPoloDestinatario, id: number, options?: any) {
            return ProcessosPoloDestinatarioApiFp(configuration).processosPoloDestinatarioPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioRead(id: number, options?: any) {
            return ProcessosPoloDestinatarioApiFp(configuration).processosPoloDestinatarioRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ProcessoPoloDestinatario} body 
         * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosPoloDestinatarioUpdate(body: ProcessoPoloDestinatario, id: number, options?: any) {
            return ProcessosPoloDestinatarioApiFp(configuration).processosPoloDestinatarioUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosPoloDestinatarioApi - object-oriented interface
 * @export
 * @class ProcessosPoloDestinatarioApi
 * @extends {BaseAPI}
 */
export class ProcessosPoloDestinatarioApi extends BaseAPI {
    /**
     * 
     * @param {ProcessoPoloDestinatario} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPoloDestinatarioApi
     */
    public processosPoloDestinatarioCreate(body: ProcessoPoloDestinatario, options?: any) {
        return ProcessosPoloDestinatarioApiFp(this.configuration).processosPoloDestinatarioCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPoloDestinatarioApi
     */
    public processosPoloDestinatarioDelete(id: number, options?: any) {
        return ProcessosPoloDestinatarioApiFp(this.configuration).processosPoloDestinatarioDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPoloDestinatarioApi
     */
    public processosPoloDestinatarioList(limit?: number, offset?: number, options?: any) {
        return ProcessosPoloDestinatarioApiFp(this.configuration).processosPoloDestinatarioList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ProcessoPoloDestinatario} body 
     * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPoloDestinatarioApi
     */
    public processosPoloDestinatarioPartialUpdate(body: ProcessoPoloDestinatario, id: number, options?: any) {
        return ProcessosPoloDestinatarioApiFp(this.configuration).processosPoloDestinatarioPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPoloDestinatarioApi
     */
    public processosPoloDestinatarioRead(id: number, options?: any) {
        return ProcessosPoloDestinatarioApiFp(this.configuration).processosPoloDestinatarioRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ProcessoPoloDestinatario} body 
     * @param {number} id A unique integer value identifying this Processo Polo Destinatário.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosPoloDestinatarioApi
     */
    public processosPoloDestinatarioUpdate(body: ProcessoPoloDestinatario, id: number, options?: any) {
        return ProcessosPoloDestinatarioApiFp(this.configuration).processosPoloDestinatarioUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosTiposDocumentoApi - fetch parameter creator
 * @export
 */
export const ProcessosTiposDocumentoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoCreate(body: DocumentoTipo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosTiposDocumentoCreate.');
            }
            const localVarPath = `/processos-tipos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosTiposDocumentoDelete.');
            }
            const localVarPath = `/processos-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-tipos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoPartialUpdate(body: DocumentoTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosTiposDocumentoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosTiposDocumentoPartialUpdate.');
            }
            const localVarPath = `/processos-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosTiposDocumentoRead.');
            }
            const localVarPath = `/processos-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoUpdate(body: DocumentoTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosTiposDocumentoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosTiposDocumentoUpdate.');
            }
            const localVarPath = `/processos-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosTiposDocumentoApi - functional programming interface
 * @export
 */
export const ProcessosTiposDocumentoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoCreate(body: DocumentoTipo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoTipo> {
            const localVarFetchArgs = ProcessosTiposDocumentoApiFetchParamCreator(configuration).processosTiposDocumentoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosTiposDocumentoApiFetchParamCreator(configuration).processosTiposDocumentoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200108> {
            const localVarFetchArgs = ProcessosTiposDocumentoApiFetchParamCreator(configuration).processosTiposDocumentoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoPartialUpdate(body: DocumentoTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoTipo> {
            const localVarFetchArgs = ProcessosTiposDocumentoApiFetchParamCreator(configuration).processosTiposDocumentoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoTipo> {
            const localVarFetchArgs = ProcessosTiposDocumentoApiFetchParamCreator(configuration).processosTiposDocumentoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoUpdate(body: DocumentoTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoTipo> {
            const localVarFetchArgs = ProcessosTiposDocumentoApiFetchParamCreator(configuration).processosTiposDocumentoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosTiposDocumentoApi - factory interface
 * @export
 */
export const ProcessosTiposDocumentoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoCreate(body: DocumentoTipo, options?: any) {
            return ProcessosTiposDocumentoApiFp(configuration).processosTiposDocumentoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoDelete(id: number, options?: any) {
            return ProcessosTiposDocumentoApiFp(configuration).processosTiposDocumentoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoList(limit?: number, offset?: number, options?: any) {
            return ProcessosTiposDocumentoApiFp(configuration).processosTiposDocumentoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoPartialUpdate(body: DocumentoTipo, id: number, options?: any) {
            return ProcessosTiposDocumentoApiFp(configuration).processosTiposDocumentoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoRead(id: number, options?: any) {
            return ProcessosTiposDocumentoApiFp(configuration).processosTiposDocumentoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DocumentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Documento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposDocumentoUpdate(body: DocumentoTipo, id: number, options?: any) {
            return ProcessosTiposDocumentoApiFp(configuration).processosTiposDocumentoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosTiposDocumentoApi - object-oriented interface
 * @export
 * @class ProcessosTiposDocumentoApi
 * @extends {BaseAPI}
 */
export class ProcessosTiposDocumentoApi extends BaseAPI {
    /**
     * 
     * @param {DocumentoTipo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposDocumentoApi
     */
    public processosTiposDocumentoCreate(body: DocumentoTipo, options?: any) {
        return ProcessosTiposDocumentoApiFp(this.configuration).processosTiposDocumentoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposDocumentoApi
     */
    public processosTiposDocumentoDelete(id: number, options?: any) {
        return ProcessosTiposDocumentoApiFp(this.configuration).processosTiposDocumentoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposDocumentoApi
     */
    public processosTiposDocumentoList(limit?: number, offset?: number, options?: any) {
        return ProcessosTiposDocumentoApiFp(this.configuration).processosTiposDocumentoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DocumentoTipo} body 
     * @param {number} id A unique integer value identifying this Tipo de Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposDocumentoApi
     */
    public processosTiposDocumentoPartialUpdate(body: DocumentoTipo, id: number, options?: any) {
        return ProcessosTiposDocumentoApiFp(this.configuration).processosTiposDocumentoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposDocumentoApi
     */
    public processosTiposDocumentoRead(id: number, options?: any) {
        return ProcessosTiposDocumentoApiFp(this.configuration).processosTiposDocumentoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DocumentoTipo} body 
     * @param {number} id A unique integer value identifying this Tipo de Documento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposDocumentoApi
     */
    public processosTiposDocumentoUpdate(body: DocumentoTipo, id: number, options?: any) {
        return ProcessosTiposDocumentoApiFp(this.configuration).processosTiposDocumentoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosTiposEventoApi - fetch parameter creator
 * @export
 */
export const ProcessosTiposEventoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FaseTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoCreate(body: FaseTipo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosTiposEventoCreate.');
            }
            const localVarPath = `/processos-tipos-evento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FaseTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosTiposEventoDelete.');
            }
            const localVarPath = `/processos-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/processos-tipos-evento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FaseTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoPartialUpdate(body: FaseTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosTiposEventoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosTiposEventoPartialUpdate.');
            }
            const localVarPath = `/processos-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FaseTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosTiposEventoRead.');
            }
            const localVarPath = `/processos-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FaseTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoUpdate(body: FaseTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processosTiposEventoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processosTiposEventoUpdate.');
            }
            const localVarPath = `/processos-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FaseTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosTiposEventoApi - functional programming interface
 * @export
 */
export const ProcessosTiposEventoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FaseTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoCreate(body: FaseTipo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FaseTipo> {
            const localVarFetchArgs = ProcessosTiposEventoApiFetchParamCreator(configuration).processosTiposEventoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessosTiposEventoApiFetchParamCreator(configuration).processosTiposEventoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200109> {
            const localVarFetchArgs = ProcessosTiposEventoApiFetchParamCreator(configuration).processosTiposEventoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FaseTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoPartialUpdate(body: FaseTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FaseTipo> {
            const localVarFetchArgs = ProcessosTiposEventoApiFetchParamCreator(configuration).processosTiposEventoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FaseTipo> {
            const localVarFetchArgs = ProcessosTiposEventoApiFetchParamCreator(configuration).processosTiposEventoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FaseTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoUpdate(body: FaseTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FaseTipo> {
            const localVarFetchArgs = ProcessosTiposEventoApiFetchParamCreator(configuration).processosTiposEventoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosTiposEventoApi - factory interface
 * @export
 */
export const ProcessosTiposEventoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {FaseTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoCreate(body: FaseTipo, options?: any) {
            return ProcessosTiposEventoApiFp(configuration).processosTiposEventoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoDelete(id: number, options?: any) {
            return ProcessosTiposEventoApiFp(configuration).processosTiposEventoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoList(limit?: number, offset?: number, options?: any) {
            return ProcessosTiposEventoApiFp(configuration).processosTiposEventoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FaseTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoPartialUpdate(body: FaseTipo, id: number, options?: any) {
            return ProcessosTiposEventoApiFp(configuration).processosTiposEventoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoRead(id: number, options?: any) {
            return ProcessosTiposEventoApiFp(configuration).processosTiposEventoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FaseTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposEventoUpdate(body: FaseTipo, id: number, options?: any) {
            return ProcessosTiposEventoApiFp(configuration).processosTiposEventoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosTiposEventoApi - object-oriented interface
 * @export
 * @class ProcessosTiposEventoApi
 * @extends {BaseAPI}
 */
export class ProcessosTiposEventoApi extends BaseAPI {
    /**
     * 
     * @param {FaseTipo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposEventoApi
     */
    public processosTiposEventoCreate(body: FaseTipo, options?: any) {
        return ProcessosTiposEventoApiFp(this.configuration).processosTiposEventoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposEventoApi
     */
    public processosTiposEventoDelete(id: number, options?: any) {
        return ProcessosTiposEventoApiFp(this.configuration).processosTiposEventoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposEventoApi
     */
    public processosTiposEventoList(limit?: number, offset?: number, options?: any) {
        return ProcessosTiposEventoApiFp(this.configuration).processosTiposEventoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FaseTipo} body 
     * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposEventoApi
     */
    public processosTiposEventoPartialUpdate(body: FaseTipo, id: number, options?: any) {
        return ProcessosTiposEventoApiFp(this.configuration).processosTiposEventoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposEventoApi
     */
    public processosTiposEventoRead(id: number, options?: any) {
        return ProcessosTiposEventoApiFp(this.configuration).processosTiposEventoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FaseTipo} body 
     * @param {number} id A unique integer value identifying this Tipo de Fase do Processo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposEventoApi
     */
    public processosTiposEventoUpdate(body: FaseTipo, id: number, options?: any) {
        return ProcessosTiposEventoApiFp(this.configuration).processosTiposEventoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessosTiposParteApi - fetch parameter creator
 * @export
 */
export const ProcessosTiposParteApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retorna uma lista dos tipos de parte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposParteList(options: any = {}): FetchArgs {
            const localVarPath = `/processos-tipos-parte/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessosTiposParteApi - functional programming interface
 * @export
 */
export const ProcessosTiposParteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retorna uma lista dos tipos de parte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposParteList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GenericIdNome>> {
            const localVarFetchArgs = ProcessosTiposParteApiFetchParamCreator(configuration).processosTiposParteList(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessosTiposParteApi - factory interface
 * @export
 */
export const ProcessosTiposParteApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retorna uma lista dos tipos de parte
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processosTiposParteList(options?: any) {
            return ProcessosTiposParteApiFp(configuration).processosTiposParteList(options)(fetch, basePath);
        },
    };
};

/**
 * ProcessosTiposParteApi - object-oriented interface
 * @export
 * @class ProcessosTiposParteApi
 * @extends {BaseAPI}
 */
export class ProcessosTiposParteApi extends BaseAPI {
    /**
     * Retorna uma lista dos tipos de parte
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessosTiposParteApi
     */
    public processosTiposParteList(options?: any) {
        return ProcessosTiposParteApiFp(this.configuration).processosTiposParteList(options)(this.fetch, this.basePath);
    }

}
/**
 * ProfissoesApi - fetch parameter creator
 * @export
 */
export const ProfissoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Profissao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesCreate(body: Profissao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling profissoesCreate.');
            }
            const localVarPath = `/profissoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Profissao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling profissoesDelete.');
            }
            const localVarPath = `/profissoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/profissoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Profissao} body 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesPartialUpdate(body: Profissao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling profissoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling profissoesPartialUpdate.');
            }
            const localVarPath = `/profissoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Profissao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling profissoesRead.');
            }
            const localVarPath = `/profissoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Profissao} body 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesUpdate(body: Profissao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling profissoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling profissoesUpdate.');
            }
            const localVarPath = `/profissoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Profissao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfissoesApi - functional programming interface
 * @export
 */
export const ProfissoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Profissao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesCreate(body: Profissao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Profissao> {
            const localVarFetchArgs = ProfissoesApiFetchParamCreator(configuration).profissoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfissoesApiFetchParamCreator(configuration).profissoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200111> {
            const localVarFetchArgs = ProfissoesApiFetchParamCreator(configuration).profissoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Profissao} body 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesPartialUpdate(body: Profissao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Profissao> {
            const localVarFetchArgs = ProfissoesApiFetchParamCreator(configuration).profissoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Profissao> {
            const localVarFetchArgs = ProfissoesApiFetchParamCreator(configuration).profissoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Profissao} body 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesUpdate(body: Profissao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Profissao> {
            const localVarFetchArgs = ProfissoesApiFetchParamCreator(configuration).profissoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfissoesApi - factory interface
 * @export
 */
export const ProfissoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Profissao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesCreate(body: Profissao, options?: any) {
            return ProfissoesApiFp(configuration).profissoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesDelete(id: number, options?: any) {
            return ProfissoesApiFp(configuration).profissoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesList(limit?: number, offset?: number, options?: any) {
            return ProfissoesApiFp(configuration).profissoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Profissao} body 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesPartialUpdate(body: Profissao, id: number, options?: any) {
            return ProfissoesApiFp(configuration).profissoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesRead(id: number, options?: any) {
            return ProfissoesApiFp(configuration).profissoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Profissao} body 
         * @param {number} id A unique integer value identifying this Profissão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profissoesUpdate(body: Profissao, id: number, options?: any) {
            return ProfissoesApiFp(configuration).profissoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProfissoesApi - object-oriented interface
 * @export
 * @class ProfissoesApi
 * @extends {BaseAPI}
 */
export class ProfissoesApi extends BaseAPI {
    /**
     * 
     * @param {Profissao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfissoesApi
     */
    public profissoesCreate(body: Profissao, options?: any) {
        return ProfissoesApiFp(this.configuration).profissoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Profissão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfissoesApi
     */
    public profissoesDelete(id: number, options?: any) {
        return ProfissoesApiFp(this.configuration).profissoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfissoesApi
     */
    public profissoesList(limit?: number, offset?: number, options?: any) {
        return ProfissoesApiFp(this.configuration).profissoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Profissao} body 
     * @param {number} id A unique integer value identifying this Profissão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfissoesApi
     */
    public profissoesPartialUpdate(body: Profissao, id: number, options?: any) {
        return ProfissoesApiFp(this.configuration).profissoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Profissão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfissoesApi
     */
    public profissoesRead(id: number, options?: any) {
        return ProfissoesApiFp(this.configuration).profissoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Profissao} body 
     * @param {number} id A unique integer value identifying this Profissão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfissoesApi
     */
    public profissoesUpdate(body: Profissao, id: number, options?: any) {
        return ProfissoesApiFp(this.configuration).profissoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PropacsApi - fetch parameter creator
 * @export
 */
export const PropacsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsCreate(body: PropacProcedimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsCreate.');
            }
            const localVarPath = `/propacs/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PropacProcedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsDelete.');
            }
            const localVarPath = `/propacs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/propacs/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsPartialUpdate(body: PropacProcedimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsPartialUpdate.');
            }
            const localVarPath = `/propacs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PropacProcedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsRead.');
            }
            const localVarPath = `/propacs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsUpdate(body: PropacProcedimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsUpdate.');
            }
            const localVarPath = `/propacs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PropacProcedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropacsApi - functional programming interface
 * @export
 */
export const PropacsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsCreate(body: PropacProcedimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropacProcedimento> {
            const localVarFetchArgs = PropacsApiFetchParamCreator(configuration).propacsCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropacsApiFetchParamCreator(configuration).propacsDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200117> {
            const localVarFetchArgs = PropacsApiFetchParamCreator(configuration).propacsList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsPartialUpdate(body: PropacProcedimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropacProcedimento> {
            const localVarFetchArgs = PropacsApiFetchParamCreator(configuration).propacsPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropacProcedimento> {
            const localVarFetchArgs = PropacsApiFetchParamCreator(configuration).propacsRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsUpdate(body: PropacProcedimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropacProcedimento> {
            const localVarFetchArgs = PropacsApiFetchParamCreator(configuration).propacsUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PropacsApi - factory interface
 * @export
 */
export const PropacsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsCreate(body: PropacProcedimento, options?: any) {
            return PropacsApiFp(configuration).propacsCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDelete(id: number, options?: any) {
            return PropacsApiFp(configuration).propacsDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsList(limit?: number, offset?: number, options?: any) {
            return PropacsApiFp(configuration).propacsList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsPartialUpdate(body: PropacProcedimento, id: number, options?: any) {
            return PropacsApiFp(configuration).propacsPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsRead(id: number, options?: any) {
            return PropacsApiFp(configuration).propacsRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PropacProcedimento} body 
         * @param {number} id A unique integer value identifying this  Procedimento e Propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsUpdate(body: PropacProcedimento, id: number, options?: any) {
            return PropacsApiFp(configuration).propacsUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PropacsApi - object-oriented interface
 * @export
 * @class PropacsApi
 * @extends {BaseAPI}
 */
export class PropacsApi extends BaseAPI {
    /**
     * 
     * @param {PropacProcedimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsApi
     */
    public propacsCreate(body: PropacProcedimento, options?: any) {
        return PropacsApiFp(this.configuration).propacsCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this  Procedimento e Propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsApi
     */
    public propacsDelete(id: number, options?: any) {
        return PropacsApiFp(this.configuration).propacsDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsApi
     */
    public propacsList(limit?: number, offset?: number, options?: any) {
        return PropacsApiFp(this.configuration).propacsList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PropacProcedimento} body 
     * @param {number} id A unique integer value identifying this  Procedimento e Propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsApi
     */
    public propacsPartialUpdate(body: PropacProcedimento, id: number, options?: any) {
        return PropacsApiFp(this.configuration).propacsPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this  Procedimento e Propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsApi
     */
    public propacsRead(id: number, options?: any) {
        return PropacsApiFp(this.configuration).propacsRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PropacProcedimento} body 
     * @param {number} id A unique integer value identifying this  Procedimento e Propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsApi
     */
    public propacsUpdate(body: PropacProcedimento, id: number, options?: any) {
        return PropacsApiFp(this.configuration).propacsUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PropacsDocumentosApi - fetch parameter creator
 * @export
 */
export const PropacsDocumentosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosCreate(body: DocumentoPropac, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsDocumentosCreate.');
            }
            const localVarPath = `/propacs-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoPropac" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsDocumentosDelete.');
            }
            const localVarPath = `/propacs-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/propacs-documentos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosPartialUpdate(body: DocumentoPropac, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsDocumentosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsDocumentosPartialUpdate.');
            }
            const localVarPath = `/propacs-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoPropac" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsDocumentosRead.');
            }
            const localVarPath = `/propacs-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosUpdate(body: DocumentoPropac, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsDocumentosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsDocumentosUpdate.');
            }
            const localVarPath = `/propacs-documentos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentoPropac" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropacsDocumentosApi - functional programming interface
 * @export
 */
export const PropacsDocumentosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosCreate(body: DocumentoPropac, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoPropac> {
            const localVarFetchArgs = PropacsDocumentosApiFetchParamCreator(configuration).propacsDocumentosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropacsDocumentosApiFetchParamCreator(configuration).propacsDocumentosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200112> {
            const localVarFetchArgs = PropacsDocumentosApiFetchParamCreator(configuration).propacsDocumentosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosPartialUpdate(body: DocumentoPropac, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoPropac> {
            const localVarFetchArgs = PropacsDocumentosApiFetchParamCreator(configuration).propacsDocumentosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoPropac> {
            const localVarFetchArgs = PropacsDocumentosApiFetchParamCreator(configuration).propacsDocumentosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosUpdate(body: DocumentoPropac, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentoPropac> {
            const localVarFetchArgs = PropacsDocumentosApiFetchParamCreator(configuration).propacsDocumentosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PropacsDocumentosApi - factory interface
 * @export
 */
export const PropacsDocumentosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosCreate(body: DocumentoPropac, options?: any) {
            return PropacsDocumentosApiFp(configuration).propacsDocumentosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosDelete(id: number, options?: any) {
            return PropacsDocumentosApiFp(configuration).propacsDocumentosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosList(limit?: number, offset?: number, options?: any) {
            return PropacsDocumentosApiFp(configuration).propacsDocumentosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosPartialUpdate(body: DocumentoPropac, id: number, options?: any) {
            return PropacsDocumentosApiFp(configuration).propacsDocumentosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosRead(id: number, options?: any) {
            return PropacsDocumentosApiFp(configuration).propacsDocumentosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DocumentoPropac} body 
         * @param {number} id A unique integer value identifying this documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsDocumentosUpdate(body: DocumentoPropac, id: number, options?: any) {
            return PropacsDocumentosApiFp(configuration).propacsDocumentosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PropacsDocumentosApi - object-oriented interface
 * @export
 * @class PropacsDocumentosApi
 * @extends {BaseAPI}
 */
export class PropacsDocumentosApi extends BaseAPI {
    /**
     * 
     * @param {DocumentoPropac} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsDocumentosApi
     */
    public propacsDocumentosCreate(body: DocumentoPropac, options?: any) {
        return PropacsDocumentosApiFp(this.configuration).propacsDocumentosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsDocumentosApi
     */
    public propacsDocumentosDelete(id: number, options?: any) {
        return PropacsDocumentosApiFp(this.configuration).propacsDocumentosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsDocumentosApi
     */
    public propacsDocumentosList(limit?: number, offset?: number, options?: any) {
        return PropacsDocumentosApiFp(this.configuration).propacsDocumentosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DocumentoPropac} body 
     * @param {number} id A unique integer value identifying this documento propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsDocumentosApi
     */
    public propacsDocumentosPartialUpdate(body: DocumentoPropac, id: number, options?: any) {
        return PropacsDocumentosApiFp(this.configuration).propacsDocumentosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this documento propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsDocumentosApi
     */
    public propacsDocumentosRead(id: number, options?: any) {
        return PropacsDocumentosApiFp(this.configuration).propacsDocumentosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DocumentoPropac} body 
     * @param {number} id A unique integer value identifying this documento propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsDocumentosApi
     */
    public propacsDocumentosUpdate(body: DocumentoPropac, id: number, options?: any) {
        return PropacsDocumentosApiFp(this.configuration).propacsDocumentosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PropacsEventosApi - fetch parameter creator
 * @export
 */
export const PropacsEventosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosCreate(body: PropacMovimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsEventosCreate.');
            }
            const localVarPath = `/propacs-eventos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PropacMovimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsEventosDelete.');
            }
            const localVarPath = `/propacs-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/propacs-eventos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosPartialUpdate(body: PropacMovimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsEventosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsEventosPartialUpdate.');
            }
            const localVarPath = `/propacs-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PropacMovimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsEventosRead.');
            }
            const localVarPath = `/propacs-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosUpdate(body: PropacMovimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsEventosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsEventosUpdate.');
            }
            const localVarPath = `/propacs-eventos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PropacMovimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropacsEventosApi - functional programming interface
 * @export
 */
export const PropacsEventosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosCreate(body: PropacMovimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropacMovimento> {
            const localVarFetchArgs = PropacsEventosApiFetchParamCreator(configuration).propacsEventosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropacsEventosApiFetchParamCreator(configuration).propacsEventosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200113> {
            const localVarFetchArgs = PropacsEventosApiFetchParamCreator(configuration).propacsEventosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosPartialUpdate(body: PropacMovimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropacMovimento> {
            const localVarFetchArgs = PropacsEventosApiFetchParamCreator(configuration).propacsEventosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropacMovimento> {
            const localVarFetchArgs = PropacsEventosApiFetchParamCreator(configuration).propacsEventosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosUpdate(body: PropacMovimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropacMovimento> {
            const localVarFetchArgs = PropacsEventosApiFetchParamCreator(configuration).propacsEventosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PropacsEventosApi - factory interface
 * @export
 */
export const PropacsEventosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosCreate(body: PropacMovimento, options?: any) {
            return PropacsEventosApiFp(configuration).propacsEventosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosDelete(id: number, options?: any) {
            return PropacsEventosApiFp(configuration).propacsEventosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosList(limit?: number, offset?: number, options?: any) {
            return PropacsEventosApiFp(configuration).propacsEventosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosPartialUpdate(body: PropacMovimento, id: number, options?: any) {
            return PropacsEventosApiFp(configuration).propacsEventosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosRead(id: number, options?: any) {
            return PropacsEventosApiFp(configuration).propacsEventosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PropacMovimento} body 
         * @param {number} id A unique integer value identifying this Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsEventosUpdate(body: PropacMovimento, id: number, options?: any) {
            return PropacsEventosApiFp(configuration).propacsEventosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PropacsEventosApi - object-oriented interface
 * @export
 * @class PropacsEventosApi
 * @extends {BaseAPI}
 */
export class PropacsEventosApi extends BaseAPI {
    /**
     * 
     * @param {PropacMovimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsEventosApi
     */
    public propacsEventosCreate(body: PropacMovimento, options?: any) {
        return PropacsEventosApiFp(this.configuration).propacsEventosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Movimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsEventosApi
     */
    public propacsEventosDelete(id: number, options?: any) {
        return PropacsEventosApiFp(this.configuration).propacsEventosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsEventosApi
     */
    public propacsEventosList(limit?: number, offset?: number, options?: any) {
        return PropacsEventosApiFp(this.configuration).propacsEventosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PropacMovimento} body 
     * @param {number} id A unique integer value identifying this Movimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsEventosApi
     */
    public propacsEventosPartialUpdate(body: PropacMovimento, id: number, options?: any) {
        return PropacsEventosApiFp(this.configuration).propacsEventosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Movimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsEventosApi
     */
    public propacsEventosRead(id: number, options?: any) {
        return PropacsEventosApiFp(this.configuration).propacsEventosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PropacMovimento} body 
     * @param {number} id A unique integer value identifying this Movimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsEventosApi
     */
    public propacsEventosUpdate(body: PropacMovimento, id: number, options?: any) {
        return PropacsEventosApiFp(this.configuration).propacsEventosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PropacsSituacoesApi - fetch parameter creator
 * @export
 */
export const PropacsSituacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesCreate(body: SituacaoProcedimento, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsSituacoesCreate.');
            }
            const localVarPath = `/propacs-situacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SituacaoProcedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsSituacoesDelete.');
            }
            const localVarPath = `/propacs-situacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/propacs-situacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesPartialUpdate(body: SituacaoProcedimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsSituacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsSituacoesPartialUpdate.');
            }
            const localVarPath = `/propacs-situacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SituacaoProcedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsSituacoesRead.');
            }
            const localVarPath = `/propacs-situacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesUpdate(body: SituacaoProcedimento, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsSituacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsSituacoesUpdate.');
            }
            const localVarPath = `/propacs-situacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SituacaoProcedimento" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropacsSituacoesApi - functional programming interface
 * @export
 */
export const PropacsSituacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesCreate(body: SituacaoProcedimento, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SituacaoProcedimento> {
            const localVarFetchArgs = PropacsSituacoesApiFetchParamCreator(configuration).propacsSituacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropacsSituacoesApiFetchParamCreator(configuration).propacsSituacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200114> {
            const localVarFetchArgs = PropacsSituacoesApiFetchParamCreator(configuration).propacsSituacoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesPartialUpdate(body: SituacaoProcedimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SituacaoProcedimento> {
            const localVarFetchArgs = PropacsSituacoesApiFetchParamCreator(configuration).propacsSituacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SituacaoProcedimento> {
            const localVarFetchArgs = PropacsSituacoesApiFetchParamCreator(configuration).propacsSituacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesUpdate(body: SituacaoProcedimento, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SituacaoProcedimento> {
            const localVarFetchArgs = PropacsSituacoesApiFetchParamCreator(configuration).propacsSituacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PropacsSituacoesApi - factory interface
 * @export
 */
export const PropacsSituacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesCreate(body: SituacaoProcedimento, options?: any) {
            return PropacsSituacoesApiFp(configuration).propacsSituacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesDelete(id: number, options?: any) {
            return PropacsSituacoesApiFp(configuration).propacsSituacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesList(limit?: number, offset?: number, options?: any) {
            return PropacsSituacoesApiFp(configuration).propacsSituacoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesPartialUpdate(body: SituacaoProcedimento, id: number, options?: any) {
            return PropacsSituacoesApiFp(configuration).propacsSituacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesRead(id: number, options?: any) {
            return PropacsSituacoesApiFp(configuration).propacsSituacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SituacaoProcedimento} body 
         * @param {number} id A unique integer value identifying this Situação do procedimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsSituacoesUpdate(body: SituacaoProcedimento, id: number, options?: any) {
            return PropacsSituacoesApiFp(configuration).propacsSituacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PropacsSituacoesApi - object-oriented interface
 * @export
 * @class PropacsSituacoesApi
 * @extends {BaseAPI}
 */
export class PropacsSituacoesApi extends BaseAPI {
    /**
     * 
     * @param {SituacaoProcedimento} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsSituacoesApi
     */
    public propacsSituacoesCreate(body: SituacaoProcedimento, options?: any) {
        return PropacsSituacoesApiFp(this.configuration).propacsSituacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Situação do procedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsSituacoesApi
     */
    public propacsSituacoesDelete(id: number, options?: any) {
        return PropacsSituacoesApiFp(this.configuration).propacsSituacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsSituacoesApi
     */
    public propacsSituacoesList(limit?: number, offset?: number, options?: any) {
        return PropacsSituacoesApiFp(this.configuration).propacsSituacoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SituacaoProcedimento} body 
     * @param {number} id A unique integer value identifying this Situação do procedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsSituacoesApi
     */
    public propacsSituacoesPartialUpdate(body: SituacaoProcedimento, id: number, options?: any) {
        return PropacsSituacoesApiFp(this.configuration).propacsSituacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Situação do procedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsSituacoesApi
     */
    public propacsSituacoesRead(id: number, options?: any) {
        return PropacsSituacoesApiFp(this.configuration).propacsSituacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SituacaoProcedimento} body 
     * @param {number} id A unique integer value identifying this Situação do procedimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsSituacoesApi
     */
    public propacsSituacoesUpdate(body: SituacaoProcedimento, id: number, options?: any) {
        return PropacsSituacoesApiFp(this.configuration).propacsSituacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PropacsTiposDocumentoApi - fetch parameter creator
 * @export
 */
export const PropacsTiposDocumentoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoCreate(body: TipoAnexoDocumentoPropac, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsTiposDocumentoCreate.');
            }
            const localVarPath = `/propacs-tipos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoAnexoDocumentoPropac" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsTiposDocumentoDelete.');
            }
            const localVarPath = `/propacs-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/propacs-tipos-documento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoPartialUpdate(body: TipoAnexoDocumentoPropac, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsTiposDocumentoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsTiposDocumentoPartialUpdate.');
            }
            const localVarPath = `/propacs-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoAnexoDocumentoPropac" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsTiposDocumentoRead.');
            }
            const localVarPath = `/propacs-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoUpdate(body: TipoAnexoDocumentoPropac, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsTiposDocumentoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsTiposDocumentoUpdate.');
            }
            const localVarPath = `/propacs-tipos-documento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoAnexoDocumentoPropac" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropacsTiposDocumentoApi - functional programming interface
 * @export
 */
export const PropacsTiposDocumentoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoCreate(body: TipoAnexoDocumentoPropac, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoAnexoDocumentoPropac> {
            const localVarFetchArgs = PropacsTiposDocumentoApiFetchParamCreator(configuration).propacsTiposDocumentoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropacsTiposDocumentoApiFetchParamCreator(configuration).propacsTiposDocumentoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200115> {
            const localVarFetchArgs = PropacsTiposDocumentoApiFetchParamCreator(configuration).propacsTiposDocumentoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoPartialUpdate(body: TipoAnexoDocumentoPropac, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoAnexoDocumentoPropac> {
            const localVarFetchArgs = PropacsTiposDocumentoApiFetchParamCreator(configuration).propacsTiposDocumentoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoAnexoDocumentoPropac> {
            const localVarFetchArgs = PropacsTiposDocumentoApiFetchParamCreator(configuration).propacsTiposDocumentoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoUpdate(body: TipoAnexoDocumentoPropac, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoAnexoDocumentoPropac> {
            const localVarFetchArgs = PropacsTiposDocumentoApiFetchParamCreator(configuration).propacsTiposDocumentoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PropacsTiposDocumentoApi - factory interface
 * @export
 */
export const PropacsTiposDocumentoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoCreate(body: TipoAnexoDocumentoPropac, options?: any) {
            return PropacsTiposDocumentoApiFp(configuration).propacsTiposDocumentoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoDelete(id: number, options?: any) {
            return PropacsTiposDocumentoApiFp(configuration).propacsTiposDocumentoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoList(limit?: number, offset?: number, options?: any) {
            return PropacsTiposDocumentoApiFp(configuration).propacsTiposDocumentoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoPartialUpdate(body: TipoAnexoDocumentoPropac, id: number, options?: any) {
            return PropacsTiposDocumentoApiFp(configuration).propacsTiposDocumentoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoRead(id: number, options?: any) {
            return PropacsTiposDocumentoApiFp(configuration).propacsTiposDocumentoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoAnexoDocumentoPropac} body 
         * @param {number} id A unique integer value identifying this tipo anexo documento propac.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposDocumentoUpdate(body: TipoAnexoDocumentoPropac, id: number, options?: any) {
            return PropacsTiposDocumentoApiFp(configuration).propacsTiposDocumentoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PropacsTiposDocumentoApi - object-oriented interface
 * @export
 * @class PropacsTiposDocumentoApi
 * @extends {BaseAPI}
 */
export class PropacsTiposDocumentoApi extends BaseAPI {
    /**
     * 
     * @param {TipoAnexoDocumentoPropac} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposDocumentoApi
     */
    public propacsTiposDocumentoCreate(body: TipoAnexoDocumentoPropac, options?: any) {
        return PropacsTiposDocumentoApiFp(this.configuration).propacsTiposDocumentoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this tipo anexo documento propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposDocumentoApi
     */
    public propacsTiposDocumentoDelete(id: number, options?: any) {
        return PropacsTiposDocumentoApiFp(this.configuration).propacsTiposDocumentoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposDocumentoApi
     */
    public propacsTiposDocumentoList(limit?: number, offset?: number, options?: any) {
        return PropacsTiposDocumentoApiFp(this.configuration).propacsTiposDocumentoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoAnexoDocumentoPropac} body 
     * @param {number} id A unique integer value identifying this tipo anexo documento propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposDocumentoApi
     */
    public propacsTiposDocumentoPartialUpdate(body: TipoAnexoDocumentoPropac, id: number, options?: any) {
        return PropacsTiposDocumentoApiFp(this.configuration).propacsTiposDocumentoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this tipo anexo documento propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposDocumentoApi
     */
    public propacsTiposDocumentoRead(id: number, options?: any) {
        return PropacsTiposDocumentoApiFp(this.configuration).propacsTiposDocumentoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoAnexoDocumentoPropac} body 
     * @param {number} id A unique integer value identifying this tipo anexo documento propac.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposDocumentoApi
     */
    public propacsTiposDocumentoUpdate(body: TipoAnexoDocumentoPropac, id: number, options?: any) {
        return PropacsTiposDocumentoApiFp(this.configuration).propacsTiposDocumentoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PropacsTiposEventoApi - fetch parameter creator
 * @export
 */
export const PropacsTiposEventoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoCreate(body: MovimentoTipo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsTiposEventoCreate.');
            }
            const localVarPath = `/propacs-tipos-evento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovimentoTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsTiposEventoDelete.');
            }
            const localVarPath = `/propacs-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/propacs-tipos-evento/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoPartialUpdate(body: MovimentoTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsTiposEventoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsTiposEventoPartialUpdate.');
            }
            const localVarPath = `/propacs-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovimentoTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsTiposEventoRead.');
            }
            const localVarPath = `/propacs-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoUpdate(body: MovimentoTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling propacsTiposEventoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling propacsTiposEventoUpdate.');
            }
            const localVarPath = `/propacs-tipos-evento/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovimentoTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropacsTiposEventoApi - functional programming interface
 * @export
 */
export const PropacsTiposEventoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoCreate(body: MovimentoTipo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MovimentoTipo> {
            const localVarFetchArgs = PropacsTiposEventoApiFetchParamCreator(configuration).propacsTiposEventoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropacsTiposEventoApiFetchParamCreator(configuration).propacsTiposEventoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200116> {
            const localVarFetchArgs = PropacsTiposEventoApiFetchParamCreator(configuration).propacsTiposEventoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoPartialUpdate(body: MovimentoTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MovimentoTipo> {
            const localVarFetchArgs = PropacsTiposEventoApiFetchParamCreator(configuration).propacsTiposEventoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MovimentoTipo> {
            const localVarFetchArgs = PropacsTiposEventoApiFetchParamCreator(configuration).propacsTiposEventoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoUpdate(body: MovimentoTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MovimentoTipo> {
            const localVarFetchArgs = PropacsTiposEventoApiFetchParamCreator(configuration).propacsTiposEventoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PropacsTiposEventoApi - factory interface
 * @export
 */
export const PropacsTiposEventoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoCreate(body: MovimentoTipo, options?: any) {
            return PropacsTiposEventoApiFp(configuration).propacsTiposEventoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoDelete(id: number, options?: any) {
            return PropacsTiposEventoApiFp(configuration).propacsTiposEventoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoList(limit?: number, offset?: number, options?: any) {
            return PropacsTiposEventoApiFp(configuration).propacsTiposEventoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoPartialUpdate(body: MovimentoTipo, id: number, options?: any) {
            return PropacsTiposEventoApiFp(configuration).propacsTiposEventoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoRead(id: number, options?: any) {
            return PropacsTiposEventoApiFp(configuration).propacsTiposEventoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MovimentoTipo} body 
         * @param {number} id A unique integer value identifying this Tipo de Movimento.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propacsTiposEventoUpdate(body: MovimentoTipo, id: number, options?: any) {
            return PropacsTiposEventoApiFp(configuration).propacsTiposEventoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * PropacsTiposEventoApi - object-oriented interface
 * @export
 * @class PropacsTiposEventoApi
 * @extends {BaseAPI}
 */
export class PropacsTiposEventoApi extends BaseAPI {
    /**
     * 
     * @param {MovimentoTipo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposEventoApi
     */
    public propacsTiposEventoCreate(body: MovimentoTipo, options?: any) {
        return PropacsTiposEventoApiFp(this.configuration).propacsTiposEventoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Movimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposEventoApi
     */
    public propacsTiposEventoDelete(id: number, options?: any) {
        return PropacsTiposEventoApiFp(this.configuration).propacsTiposEventoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposEventoApi
     */
    public propacsTiposEventoList(limit?: number, offset?: number, options?: any) {
        return PropacsTiposEventoApiFp(this.configuration).propacsTiposEventoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MovimentoTipo} body 
     * @param {number} id A unique integer value identifying this Tipo de Movimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposEventoApi
     */
    public propacsTiposEventoPartialUpdate(body: MovimentoTipo, id: number, options?: any) {
        return PropacsTiposEventoApiFp(this.configuration).propacsTiposEventoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Movimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposEventoApi
     */
    public propacsTiposEventoRead(id: number, options?: any) {
        return PropacsTiposEventoApiFp(this.configuration).propacsTiposEventoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MovimentoTipo} body 
     * @param {number} id A unique integer value identifying this Tipo de Movimento.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropacsTiposEventoApi
     */
    public propacsTiposEventoUpdate(body: MovimentoTipo, id: number, options?: any) {
        return PropacsTiposEventoApiFp(this.configuration).propacsTiposEventoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * QualificacoesApi - fetch parameter creator
 * @export
 */
export const QualificacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Qualificacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesCreate(body: Qualificacao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling qualificacoesCreate.');
            }
            const localVarPath = `/qualificacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Qualificacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificacoesDelete.');
            }
            const localVarPath = `/qualificacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/qualificacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Qualificacao} body 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesPartialUpdate(body: Qualificacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling qualificacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificacoesPartialUpdate.');
            }
            const localVarPath = `/qualificacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Qualificacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificacoesRead.');
            }
            const localVarPath = `/qualificacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Qualificacao} body 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesUpdate(body: Qualificacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling qualificacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificacoesUpdate.');
            }
            const localVarPath = `/qualificacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Qualificacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QualificacoesApi - functional programming interface
 * @export
 */
export const QualificacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Qualificacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesCreate(body: Qualificacao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Qualificacao> {
            const localVarFetchArgs = QualificacoesApiFetchParamCreator(configuration).qualificacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QualificacoesApiFetchParamCreator(configuration).qualificacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200119> {
            const localVarFetchArgs = QualificacoesApiFetchParamCreator(configuration).qualificacoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Qualificacao} body 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesPartialUpdate(body: Qualificacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Qualificacao> {
            const localVarFetchArgs = QualificacoesApiFetchParamCreator(configuration).qualificacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Qualificacao> {
            const localVarFetchArgs = QualificacoesApiFetchParamCreator(configuration).qualificacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Qualificacao} body 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesUpdate(body: Qualificacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Qualificacao> {
            const localVarFetchArgs = QualificacoesApiFetchParamCreator(configuration).qualificacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QualificacoesApi - factory interface
 * @export
 */
export const QualificacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Qualificacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesCreate(body: Qualificacao, options?: any) {
            return QualificacoesApiFp(configuration).qualificacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesDelete(id: number, options?: any) {
            return QualificacoesApiFp(configuration).qualificacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesList(limit?: number, offset?: number, options?: any) {
            return QualificacoesApiFp(configuration).qualificacoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Qualificacao} body 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesPartialUpdate(body: Qualificacao, id: number, options?: any) {
            return QualificacoesApiFp(configuration).qualificacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesRead(id: number, options?: any) {
            return QualificacoesApiFp(configuration).qualificacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Qualificacao} body 
         * @param {number} id A unique integer value identifying this Qualficação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesUpdate(body: Qualificacao, id: number, options?: any) {
            return QualificacoesApiFp(configuration).qualificacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * QualificacoesApi - object-oriented interface
 * @export
 * @class QualificacoesApi
 * @extends {BaseAPI}
 */
export class QualificacoesApi extends BaseAPI {
    /**
     * 
     * @param {Qualificacao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesApi
     */
    public qualificacoesCreate(body: Qualificacao, options?: any) {
        return QualificacoesApiFp(this.configuration).qualificacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Qualficação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesApi
     */
    public qualificacoesDelete(id: number, options?: any) {
        return QualificacoesApiFp(this.configuration).qualificacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesApi
     */
    public qualificacoesList(limit?: number, offset?: number, options?: any) {
        return QualificacoesApiFp(this.configuration).qualificacoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Qualificacao} body 
     * @param {number} id A unique integer value identifying this Qualficação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesApi
     */
    public qualificacoesPartialUpdate(body: Qualificacao, id: number, options?: any) {
        return QualificacoesApiFp(this.configuration).qualificacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Qualficação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesApi
     */
    public qualificacoesRead(id: number, options?: any) {
        return QualificacoesApiFp(this.configuration).qualificacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Qualificacao} body 
     * @param {number} id A unique integer value identifying this Qualficação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesApi
     */
    public qualificacoesUpdate(body: Qualificacao, id: number, options?: any) {
        return QualificacoesApiFp(this.configuration).qualificacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * QualificacoesAssuntosApi - fetch parameter creator
 * @export
 */
export const QualificacoesAssuntosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosCreate(body: QualificacaoAssunto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling qualificacoesAssuntosCreate.');
            }
            const localVarPath = `/qualificacoes-assuntos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QualificacaoAssunto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificacoesAssuntosDelete.');
            }
            const localVarPath = `/qualificacoes-assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/qualificacoes-assuntos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosPartialUpdate(body: QualificacaoAssunto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling qualificacoesAssuntosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificacoesAssuntosPartialUpdate.');
            }
            const localVarPath = `/qualificacoes-assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QualificacaoAssunto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificacoesAssuntosRead.');
            }
            const localVarPath = `/qualificacoes-assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosUpdate(body: QualificacaoAssunto, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling qualificacoesAssuntosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificacoesAssuntosUpdate.');
            }
            const localVarPath = `/qualificacoes-assuntos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QualificacaoAssunto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QualificacoesAssuntosApi - functional programming interface
 * @export
 */
export const QualificacoesAssuntosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosCreate(body: QualificacaoAssunto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QualificacaoAssunto> {
            const localVarFetchArgs = QualificacoesAssuntosApiFetchParamCreator(configuration).qualificacoesAssuntosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QualificacoesAssuntosApiFetchParamCreator(configuration).qualificacoesAssuntosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200118> {
            const localVarFetchArgs = QualificacoesAssuntosApiFetchParamCreator(configuration).qualificacoesAssuntosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosPartialUpdate(body: QualificacaoAssunto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QualificacaoAssunto> {
            const localVarFetchArgs = QualificacoesAssuntosApiFetchParamCreator(configuration).qualificacoesAssuntosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QualificacaoAssunto> {
            const localVarFetchArgs = QualificacoesAssuntosApiFetchParamCreator(configuration).qualificacoesAssuntosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosUpdate(body: QualificacaoAssunto, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QualificacaoAssunto> {
            const localVarFetchArgs = QualificacoesAssuntosApiFetchParamCreator(configuration).qualificacoesAssuntosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QualificacoesAssuntosApi - factory interface
 * @export
 */
export const QualificacoesAssuntosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosCreate(body: QualificacaoAssunto, options?: any) {
            return QualificacoesAssuntosApiFp(configuration).qualificacoesAssuntosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosDelete(id: number, options?: any) {
            return QualificacoesAssuntosApiFp(configuration).qualificacoesAssuntosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosList(limit?: number, offset?: number, options?: any) {
            return QualificacoesAssuntosApiFp(configuration).qualificacoesAssuntosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosPartialUpdate(body: QualificacaoAssunto, id: number, options?: any) {
            return QualificacoesAssuntosApiFp(configuration).qualificacoesAssuntosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosRead(id: number, options?: any) {
            return QualificacoesAssuntosApiFp(configuration).qualificacoesAssuntosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {QualificacaoAssunto} body 
         * @param {number} id A unique integer value identifying this Assunto de Qualificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificacoesAssuntosUpdate(body: QualificacaoAssunto, id: number, options?: any) {
            return QualificacoesAssuntosApiFp(configuration).qualificacoesAssuntosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * QualificacoesAssuntosApi - object-oriented interface
 * @export
 * @class QualificacoesAssuntosApi
 * @extends {BaseAPI}
 */
export class QualificacoesAssuntosApi extends BaseAPI {
    /**
     * 
     * @param {QualificacaoAssunto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesAssuntosApi
     */
    public qualificacoesAssuntosCreate(body: QualificacaoAssunto, options?: any) {
        return QualificacoesAssuntosApiFp(this.configuration).qualificacoesAssuntosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Assunto de Qualificação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesAssuntosApi
     */
    public qualificacoesAssuntosDelete(id: number, options?: any) {
        return QualificacoesAssuntosApiFp(this.configuration).qualificacoesAssuntosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesAssuntosApi
     */
    public qualificacoesAssuntosList(limit?: number, offset?: number, options?: any) {
        return QualificacoesAssuntosApiFp(this.configuration).qualificacoesAssuntosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {QualificacaoAssunto} body 
     * @param {number} id A unique integer value identifying this Assunto de Qualificação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesAssuntosApi
     */
    public qualificacoesAssuntosPartialUpdate(body: QualificacaoAssunto, id: number, options?: any) {
        return QualificacoesAssuntosApiFp(this.configuration).qualificacoesAssuntosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Assunto de Qualificação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesAssuntosApi
     */
    public qualificacoesAssuntosRead(id: number, options?: any) {
        return QualificacoesAssuntosApiFp(this.configuration).qualificacoesAssuntosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {QualificacaoAssunto} body 
     * @param {number} id A unique integer value identifying this Assunto de Qualificação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QualificacoesAssuntosApi
     */
    public qualificacoesAssuntosUpdate(body: QualificacaoAssunto, id: number, options?: any) {
        return QualificacoesAssuntosApiFp(this.configuration).qualificacoesAssuntosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * RelatoriosApi - fetch parameter creator
 * @export
 */
export const RelatoriosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Relatorio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosCreate(body: Relatorio, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling relatoriosCreate.');
            }
            const localVarPath = `/relatorios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Relatorio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling relatoriosDelete.');
            }
            const localVarPath = `/relatorios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [titulo] 
         * @param {string} [tipo] 
         * @param {string} [locais] 
         * @param {string} [papeis] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosList(titulo?: string, tipo?: string, locais?: string, papeis?: string, ativo?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/relatorios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (titulo !== undefined) {
                localVarQueryParameter['titulo'] = titulo;
            }

            if (tipo !== undefined) {
                localVarQueryParameter['tipo'] = tipo;
            }

            if (locais !== undefined) {
                localVarQueryParameter['locais'] = locais;
            }

            if (papeis !== undefined) {
                localVarQueryParameter['papeis'] = papeis;
            }

            if (ativo !== undefined) {
                localVarQueryParameter['ativo'] = ativo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Relatorio} body 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosPartialUpdate(body: Relatorio, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling relatoriosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling relatoriosPartialUpdate.');
            }
            const localVarPath = `/relatorios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Relatorio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling relatoriosRead.');
            }
            const localVarPath = `/relatorios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Relatorio} body 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosUpdate(body: Relatorio, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling relatoriosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling relatoriosUpdate.');
            }
            const localVarPath = `/relatorios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Relatorio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelatoriosApi - functional programming interface
 * @export
 */
export const RelatoriosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Relatorio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosCreate(body: Relatorio, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Relatorio> {
            const localVarFetchArgs = RelatoriosApiFetchParamCreator(configuration).relatoriosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RelatoriosApiFetchParamCreator(configuration).relatoriosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [titulo] 
         * @param {string} [tipo] 
         * @param {string} [locais] 
         * @param {string} [papeis] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosList(titulo?: string, tipo?: string, locais?: string, papeis?: string, ativo?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200120> {
            const localVarFetchArgs = RelatoriosApiFetchParamCreator(configuration).relatoriosList(titulo, tipo, locais, papeis, ativo, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Relatorio} body 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosPartialUpdate(body: Relatorio, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Relatorio> {
            const localVarFetchArgs = RelatoriosApiFetchParamCreator(configuration).relatoriosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Relatorio> {
            const localVarFetchArgs = RelatoriosApiFetchParamCreator(configuration).relatoriosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Relatorio} body 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosUpdate(body: Relatorio, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Relatorio> {
            const localVarFetchArgs = RelatoriosApiFetchParamCreator(configuration).relatoriosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RelatoriosApi - factory interface
 * @export
 */
export const RelatoriosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Relatorio} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosCreate(body: Relatorio, options?: any) {
            return RelatoriosApiFp(configuration).relatoriosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosDelete(id: number, options?: any) {
            return RelatoriosApiFp(configuration).relatoriosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [titulo] 
         * @param {string} [tipo] 
         * @param {string} [locais] 
         * @param {string} [papeis] 
         * @param {string} [ativo] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosList(titulo?: string, tipo?: string, locais?: string, papeis?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
            return RelatoriosApiFp(configuration).relatoriosList(titulo, tipo, locais, papeis, ativo, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Relatorio} body 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosPartialUpdate(body: Relatorio, id: number, options?: any) {
            return RelatoriosApiFp(configuration).relatoriosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosRead(id: number, options?: any) {
            return RelatoriosApiFp(configuration).relatoriosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Relatorio} body 
         * @param {number} id A unique integer value identifying this Relatório.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatoriosUpdate(body: Relatorio, id: number, options?: any) {
            return RelatoriosApiFp(configuration).relatoriosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * RelatoriosApi - object-oriented interface
 * @export
 * @class RelatoriosApi
 * @extends {BaseAPI}
 */
export class RelatoriosApi extends BaseAPI {
    /**
     * 
     * @param {Relatorio} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatoriosApi
     */
    public relatoriosCreate(body: Relatorio, options?: any) {
        return RelatoriosApiFp(this.configuration).relatoriosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Relatório.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatoriosApi
     */
    public relatoriosDelete(id: number, options?: any) {
        return RelatoriosApiFp(this.configuration).relatoriosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [titulo] 
     * @param {string} [tipo] 
     * @param {string} [locais] 
     * @param {string} [papeis] 
     * @param {string} [ativo] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatoriosApi
     */
    public relatoriosList(titulo?: string, tipo?: string, locais?: string, papeis?: string, ativo?: string, limit?: number, offset?: number, options?: any) {
        return RelatoriosApiFp(this.configuration).relatoriosList(titulo, tipo, locais, papeis, ativo, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Relatorio} body 
     * @param {number} id A unique integer value identifying this Relatório.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatoriosApi
     */
    public relatoriosPartialUpdate(body: Relatorio, id: number, options?: any) {
        return RelatoriosApiFp(this.configuration).relatoriosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Relatório.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatoriosApi
     */
    public relatoriosRead(id: number, options?: any) {
        return RelatoriosApiFp(this.configuration).relatoriosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Relatorio} body 
     * @param {number} id A unique integer value identifying this Relatório.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatoriosApi
     */
    public relatoriosUpdate(body: Relatorio, id: number, options?: any) {
        return RelatoriosApiFp(this.configuration).relatoriosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * RemicoesApi - fetch parameter creator
 * @export
 */
export const RemicoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Remissao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesCreate(body: Remissao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling remicoesCreate.');
            }
            const localVarPath = `/remicoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Remissao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling remicoesDelete.');
            }
            const localVarPath = `/remicoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/remicoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Remissao} body 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesPartialUpdate(body: Remissao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling remicoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling remicoesPartialUpdate.');
            }
            const localVarPath = `/remicoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Remissao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling remicoesRead.');
            }
            const localVarPath = `/remicoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Remissao} body 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesUpdate(body: Remissao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling remicoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling remicoesUpdate.');
            }
            const localVarPath = `/remicoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Remissao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemicoesApi - functional programming interface
 * @export
 */
export const RemicoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Remissao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesCreate(body: Remissao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Remissao> {
            const localVarFetchArgs = RemicoesApiFetchParamCreator(configuration).remicoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemicoesApiFetchParamCreator(configuration).remicoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200121> {
            const localVarFetchArgs = RemicoesApiFetchParamCreator(configuration).remicoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Remissao} body 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesPartialUpdate(body: Remissao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Remissao> {
            const localVarFetchArgs = RemicoesApiFetchParamCreator(configuration).remicoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Remissao> {
            const localVarFetchArgs = RemicoesApiFetchParamCreator(configuration).remicoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Remissao} body 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesUpdate(body: Remissao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Remissao> {
            const localVarFetchArgs = RemicoesApiFetchParamCreator(configuration).remicoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RemicoesApi - factory interface
 * @export
 */
export const RemicoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Remissao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesCreate(body: Remissao, options?: any) {
            return RemicoesApiFp(configuration).remicoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesDelete(id: number, options?: any) {
            return RemicoesApiFp(configuration).remicoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesList(limit?: number, offset?: number, options?: any) {
            return RemicoesApiFp(configuration).remicoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Remissao} body 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesPartialUpdate(body: Remissao, id: number, options?: any) {
            return RemicoesApiFp(configuration).remicoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesRead(id: number, options?: any) {
            return RemicoesApiFp(configuration).remicoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Remissao} body 
         * @param {number} id A unique integer value identifying this Remição.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remicoesUpdate(body: Remissao, id: number, options?: any) {
            return RemicoesApiFp(configuration).remicoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * RemicoesApi - object-oriented interface
 * @export
 * @class RemicoesApi
 * @extends {BaseAPI}
 */
export class RemicoesApi extends BaseAPI {
    /**
     * 
     * @param {Remissao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemicoesApi
     */
    public remicoesCreate(body: Remissao, options?: any) {
        return RemicoesApiFp(this.configuration).remicoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Remição.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemicoesApi
     */
    public remicoesDelete(id: number, options?: any) {
        return RemicoesApiFp(this.configuration).remicoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemicoesApi
     */
    public remicoesList(limit?: number, offset?: number, options?: any) {
        return RemicoesApiFp(this.configuration).remicoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Remissao} body 
     * @param {number} id A unique integer value identifying this Remição.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemicoesApi
     */
    public remicoesPartialUpdate(body: Remissao, id: number, options?: any) {
        return RemicoesApiFp(this.configuration).remicoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Remição.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemicoesApi
     */
    public remicoesRead(id: number, options?: any) {
        return RemicoesApiFp(this.configuration).remicoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Remissao} body 
     * @param {number} id A unique integer value identifying this Remição.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemicoesApi
     */
    public remicoesUpdate(body: Remissao, id: number, options?: any) {
        return RemicoesApiFp(this.configuration).remicoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * RendasApi - fetch parameter creator
 * @export
 */
export const RendasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Renda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasCreate(body: Renda, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rendasCreate.');
            }
            const localVarPath = `/rendas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Renda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rendasDelete.');
            }
            const localVarPath = `/rendas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/rendas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Renda} body 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasPartialUpdate(body: Renda, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rendasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rendasPartialUpdate.');
            }
            const localVarPath = `/rendas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Renda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rendasRead.');
            }
            const localVarPath = `/rendas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Renda} body 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasUpdate(body: Renda, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rendasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rendasUpdate.');
            }
            const localVarPath = `/rendas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Renda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RendasApi - functional programming interface
 * @export
 */
export const RendasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Renda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasCreate(body: Renda, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Renda> {
            const localVarFetchArgs = RendasApiFetchParamCreator(configuration).rendasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RendasApiFetchParamCreator(configuration).rendasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200122> {
            const localVarFetchArgs = RendasApiFetchParamCreator(configuration).rendasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Renda} body 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasPartialUpdate(body: Renda, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Renda> {
            const localVarFetchArgs = RendasApiFetchParamCreator(configuration).rendasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Renda> {
            const localVarFetchArgs = RendasApiFetchParamCreator(configuration).rendasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Renda} body 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasUpdate(body: Renda, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Renda> {
            const localVarFetchArgs = RendasApiFetchParamCreator(configuration).rendasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RendasApi - factory interface
 * @export
 */
export const RendasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Renda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasCreate(body: Renda, options?: any) {
            return RendasApiFp(configuration).rendasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasDelete(id: number, options?: any) {
            return RendasApiFp(configuration).rendasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasList(limit?: number, offset?: number, options?: any) {
            return RendasApiFp(configuration).rendasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Renda} body 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasPartialUpdate(body: Renda, id: number, options?: any) {
            return RendasApiFp(configuration).rendasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasRead(id: number, options?: any) {
            return RendasApiFp(configuration).rendasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Renda} body 
         * @param {number} id A unique integer value identifying this renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rendasUpdate(body: Renda, id: number, options?: any) {
            return RendasApiFp(configuration).rendasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * RendasApi - object-oriented interface
 * @export
 * @class RendasApi
 * @extends {BaseAPI}
 */
export class RendasApi extends BaseAPI {
    /**
     * 
     * @param {Renda} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RendasApi
     */
    public rendasCreate(body: Renda, options?: any) {
        return RendasApiFp(this.configuration).rendasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this renda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RendasApi
     */
    public rendasDelete(id: number, options?: any) {
        return RendasApiFp(this.configuration).rendasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RendasApi
     */
    public rendasList(limit?: number, offset?: number, options?: any) {
        return RendasApiFp(this.configuration).rendasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Renda} body 
     * @param {number} id A unique integer value identifying this renda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RendasApi
     */
    public rendasPartialUpdate(body: Renda, id: number, options?: any) {
        return RendasApiFp(this.configuration).rendasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this renda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RendasApi
     */
    public rendasRead(id: number, options?: any) {
        return RendasApiFp(this.configuration).rendasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Renda} body 
     * @param {number} id A unique integer value identifying this renda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RendasApi
     */
    public rendasUpdate(body: Renda, id: number, options?: any) {
        return RendasApiFp(this.configuration).rendasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * RestricoesPrestacaoDeServicoApi - fetch parameter creator
 * @export
 */
export const RestricoesPrestacaoDeServicoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoCreate(body: RestricaoPrestacaoServico, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restricoesPrestacaoDeServicoCreate.');
            }
            const localVarPath = `/restricoes-prestacao-de-servico/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestricaoPrestacaoServico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restricoesPrestacaoDeServicoDelete.');
            }
            const localVarPath = `/restricoes-prestacao-de-servico/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/restricoes-prestacao-de-servico/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoPartialUpdate(body: RestricaoPrestacaoServico, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restricoesPrestacaoDeServicoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restricoesPrestacaoDeServicoPartialUpdate.');
            }
            const localVarPath = `/restricoes-prestacao-de-servico/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestricaoPrestacaoServico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restricoesPrestacaoDeServicoRead.');
            }
            const localVarPath = `/restricoes-prestacao-de-servico/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoUpdate(body: RestricaoPrestacaoServico, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restricoesPrestacaoDeServicoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restricoesPrestacaoDeServicoUpdate.');
            }
            const localVarPath = `/restricoes-prestacao-de-servico/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestricaoPrestacaoServico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestricoesPrestacaoDeServicoApi - functional programming interface
 * @export
 */
export const RestricoesPrestacaoDeServicoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoCreate(body: RestricaoPrestacaoServico, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RestricaoPrestacaoServico> {
            const localVarFetchArgs = RestricoesPrestacaoDeServicoApiFetchParamCreator(configuration).restricoesPrestacaoDeServicoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RestricoesPrestacaoDeServicoApiFetchParamCreator(configuration).restricoesPrestacaoDeServicoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200123> {
            const localVarFetchArgs = RestricoesPrestacaoDeServicoApiFetchParamCreator(configuration).restricoesPrestacaoDeServicoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoPartialUpdate(body: RestricaoPrestacaoServico, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RestricaoPrestacaoServico> {
            const localVarFetchArgs = RestricoesPrestacaoDeServicoApiFetchParamCreator(configuration).restricoesPrestacaoDeServicoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RestricaoPrestacaoServico> {
            const localVarFetchArgs = RestricoesPrestacaoDeServicoApiFetchParamCreator(configuration).restricoesPrestacaoDeServicoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoUpdate(body: RestricaoPrestacaoServico, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RestricaoPrestacaoServico> {
            const localVarFetchArgs = RestricoesPrestacaoDeServicoApiFetchParamCreator(configuration).restricoesPrestacaoDeServicoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RestricoesPrestacaoDeServicoApi - factory interface
 * @export
 */
export const RestricoesPrestacaoDeServicoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoCreate(body: RestricaoPrestacaoServico, options?: any) {
            return RestricoesPrestacaoDeServicoApiFp(configuration).restricoesPrestacaoDeServicoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoDelete(id: number, options?: any) {
            return RestricoesPrestacaoDeServicoApiFp(configuration).restricoesPrestacaoDeServicoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoList(limit?: number, offset?: number, options?: any) {
            return RestricoesPrestacaoDeServicoApiFp(configuration).restricoesPrestacaoDeServicoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoPartialUpdate(body: RestricaoPrestacaoServico, id: number, options?: any) {
            return RestricoesPrestacaoDeServicoApiFp(configuration).restricoesPrestacaoDeServicoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoRead(id: number, options?: any) {
            return RestricoesPrestacaoDeServicoApiFp(configuration).restricoesPrestacaoDeServicoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RestricaoPrestacaoServico} body 
         * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restricoesPrestacaoDeServicoUpdate(body: RestricaoPrestacaoServico, id: number, options?: any) {
            return RestricoesPrestacaoDeServicoApiFp(configuration).restricoesPrestacaoDeServicoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * RestricoesPrestacaoDeServicoApi - object-oriented interface
 * @export
 * @class RestricoesPrestacaoDeServicoApi
 * @extends {BaseAPI}
 */
export class RestricoesPrestacaoDeServicoApi extends BaseAPI {
    /**
     * 
     * @param {RestricaoPrestacaoServico} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestricoesPrestacaoDeServicoApi
     */
    public restricoesPrestacaoDeServicoCreate(body: RestricaoPrestacaoServico, options?: any) {
        return RestricoesPrestacaoDeServicoApiFp(this.configuration).restricoesPrestacaoDeServicoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestricoesPrestacaoDeServicoApi
     */
    public restricoesPrestacaoDeServicoDelete(id: number, options?: any) {
        return RestricoesPrestacaoDeServicoApiFp(this.configuration).restricoesPrestacaoDeServicoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestricoesPrestacaoDeServicoApi
     */
    public restricoesPrestacaoDeServicoList(limit?: number, offset?: number, options?: any) {
        return RestricoesPrestacaoDeServicoApiFp(this.configuration).restricoesPrestacaoDeServicoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RestricaoPrestacaoServico} body 
     * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestricoesPrestacaoDeServicoApi
     */
    public restricoesPrestacaoDeServicoPartialUpdate(body: RestricaoPrestacaoServico, id: number, options?: any) {
        return RestricoesPrestacaoDeServicoApiFp(this.configuration).restricoesPrestacaoDeServicoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestricoesPrestacaoDeServicoApi
     */
    public restricoesPrestacaoDeServicoRead(id: number, options?: any) {
        return RestricoesPrestacaoDeServicoApiFp(this.configuration).restricoesPrestacaoDeServicoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RestricaoPrestacaoServico} body 
     * @param {number} id A unique integer value identifying this Restrição - Prestação de Serviço.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestricoesPrestacaoDeServicoApi
     */
    public restricoesPrestacaoDeServicoUpdate(body: RestricaoPrestacaoServico, id: number, options?: any) {
        return RestricoesPrestacaoDeServicoApiFp(this.configuration).restricoesPrestacaoDeServicoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * SalariosApi - fetch parameter creator
 * @export
 */
export const SalariosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Salario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosCreate(body: Salario, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling salariosCreate.');
            }
            const localVarPath = `/salarios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Salario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salariosDelete.');
            }
            const localVarPath = `/salarios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/salarios/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Salario} body 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosPartialUpdate(body: Salario, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling salariosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salariosPartialUpdate.');
            }
            const localVarPath = `/salarios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Salario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salariosRead.');
            }
            const localVarPath = `/salarios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Salario} body 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosUpdate(body: Salario, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling salariosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salariosUpdate.');
            }
            const localVarPath = `/salarios/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Salario" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalariosApi - functional programming interface
 * @export
 */
export const SalariosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Salario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosCreate(body: Salario, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Salario> {
            const localVarFetchArgs = SalariosApiFetchParamCreator(configuration).salariosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SalariosApiFetchParamCreator(configuration).salariosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200124> {
            const localVarFetchArgs = SalariosApiFetchParamCreator(configuration).salariosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Salario} body 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosPartialUpdate(body: Salario, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Salario> {
            const localVarFetchArgs = SalariosApiFetchParamCreator(configuration).salariosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Salario> {
            const localVarFetchArgs = SalariosApiFetchParamCreator(configuration).salariosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Salario} body 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosUpdate(body: Salario, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Salario> {
            const localVarFetchArgs = SalariosApiFetchParamCreator(configuration).salariosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalariosApi - factory interface
 * @export
 */
export const SalariosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Salario} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosCreate(body: Salario, options?: any) {
            return SalariosApiFp(configuration).salariosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosDelete(id: number, options?: any) {
            return SalariosApiFp(configuration).salariosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosList(limit?: number, offset?: number, options?: any) {
            return SalariosApiFp(configuration).salariosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Salario} body 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosPartialUpdate(body: Salario, id: number, options?: any) {
            return SalariosApiFp(configuration).salariosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosRead(id: number, options?: any) {
            return SalariosApiFp(configuration).salariosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Salario} body 
         * @param {number} id A unique integer value identifying this salario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salariosUpdate(body: Salario, id: number, options?: any) {
            return SalariosApiFp(configuration).salariosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * SalariosApi - object-oriented interface
 * @export
 * @class SalariosApi
 * @extends {BaseAPI}
 */
export class SalariosApi extends BaseAPI {
    /**
     * 
     * @param {Salario} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalariosApi
     */
    public salariosCreate(body: Salario, options?: any) {
        return SalariosApiFp(this.configuration).salariosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this salario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalariosApi
     */
    public salariosDelete(id: number, options?: any) {
        return SalariosApiFp(this.configuration).salariosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalariosApi
     */
    public salariosList(limit?: number, offset?: number, options?: any) {
        return SalariosApiFp(this.configuration).salariosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Salario} body 
     * @param {number} id A unique integer value identifying this salario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalariosApi
     */
    public salariosPartialUpdate(body: Salario, id: number, options?: any) {
        return SalariosApiFp(this.configuration).salariosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this salario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalariosApi
     */
    public salariosRead(id: number, options?: any) {
        return SalariosApiFp(this.configuration).salariosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Salario} body 
     * @param {number} id A unique integer value identifying this salario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalariosApi
     */
    public salariosUpdate(body: Salario, id: number, options?: any) {
        return SalariosApiFp(this.configuration).salariosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * SemoventesApi - fetch parameter creator
 * @export
 */
export const SemoventesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Semovente} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesCreate(body: Semovente, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling semoventesCreate.');
            }
            const localVarPath = `/semoventes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Semovente" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling semoventesDelete.');
            }
            const localVarPath = `/semoventes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/semoventes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Semovente} body 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesPartialUpdate(body: Semovente, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling semoventesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling semoventesPartialUpdate.');
            }
            const localVarPath = `/semoventes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Semovente" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling semoventesRead.');
            }
            const localVarPath = `/semoventes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Semovente} body 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesUpdate(body: Semovente, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling semoventesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling semoventesUpdate.');
            }
            const localVarPath = `/semoventes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Semovente" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SemoventesApi - functional programming interface
 * @export
 */
export const SemoventesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Semovente} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesCreate(body: Semovente, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Semovente> {
            const localVarFetchArgs = SemoventesApiFetchParamCreator(configuration).semoventesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SemoventesApiFetchParamCreator(configuration).semoventesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200125> {
            const localVarFetchArgs = SemoventesApiFetchParamCreator(configuration).semoventesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Semovente} body 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesPartialUpdate(body: Semovente, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Semovente> {
            const localVarFetchArgs = SemoventesApiFetchParamCreator(configuration).semoventesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Semovente> {
            const localVarFetchArgs = SemoventesApiFetchParamCreator(configuration).semoventesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Semovente} body 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesUpdate(body: Semovente, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Semovente> {
            const localVarFetchArgs = SemoventesApiFetchParamCreator(configuration).semoventesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SemoventesApi - factory interface
 * @export
 */
export const SemoventesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Semovente} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesCreate(body: Semovente, options?: any) {
            return SemoventesApiFp(configuration).semoventesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesDelete(id: number, options?: any) {
            return SemoventesApiFp(configuration).semoventesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesList(limit?: number, offset?: number, options?: any) {
            return SemoventesApiFp(configuration).semoventesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Semovente} body 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesPartialUpdate(body: Semovente, id: number, options?: any) {
            return SemoventesApiFp(configuration).semoventesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesRead(id: number, options?: any) {
            return SemoventesApiFp(configuration).semoventesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Semovente} body 
         * @param {number} id A unique integer value identifying this semovente.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semoventesUpdate(body: Semovente, id: number, options?: any) {
            return SemoventesApiFp(configuration).semoventesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * SemoventesApi - object-oriented interface
 * @export
 * @class SemoventesApi
 * @extends {BaseAPI}
 */
export class SemoventesApi extends BaseAPI {
    /**
     * 
     * @param {Semovente} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemoventesApi
     */
    public semoventesCreate(body: Semovente, options?: any) {
        return SemoventesApiFp(this.configuration).semoventesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this semovente.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemoventesApi
     */
    public semoventesDelete(id: number, options?: any) {
        return SemoventesApiFp(this.configuration).semoventesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemoventesApi
     */
    public semoventesList(limit?: number, offset?: number, options?: any) {
        return SemoventesApiFp(this.configuration).semoventesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Semovente} body 
     * @param {number} id A unique integer value identifying this semovente.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemoventesApi
     */
    public semoventesPartialUpdate(body: Semovente, id: number, options?: any) {
        return SemoventesApiFp(this.configuration).semoventesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this semovente.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemoventesApi
     */
    public semoventesRead(id: number, options?: any) {
        return SemoventesApiFp(this.configuration).semoventesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Semovente} body 
     * @param {number} id A unique integer value identifying this semovente.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemoventesApi
     */
    public semoventesUpdate(body: Semovente, id: number, options?: any) {
        return SemoventesApiFp(this.configuration).semoventesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * ServidoresApi - fetch parameter creator
 * @export
 */
export const ServidoresApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServidorV2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresCreate(body: ServidorV2, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling servidoresCreate.');
            }
            const localVarPath = `/servidores/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServidorV2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling servidoresDelete.');
            }
            const localVarPath = `/servidores/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [cpf] 
         * @param {string} [comarca] 
         * @param {string} [nome] 
         * @param {string} [papel] 
         * @param {string} [matricula] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresList(id?: number, cpf?: string, comarca?: string, nome?: string, papel?: string, matricula?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/servidores/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (cpf !== undefined) {
                localVarQueryParameter['cpf'] = cpf;
            }

            if (comarca !== undefined) {
                localVarQueryParameter['comarca'] = comarca;
            }

            if (nome !== undefined) {
                localVarQueryParameter['nome'] = nome;
            }

            if (papel !== undefined) {
                localVarQueryParameter['papel'] = papel;
            }

            if (matricula !== undefined) {
                localVarQueryParameter['matricula'] = matricula;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServidorV2} body 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresPartialUpdate(body: ServidorV2, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling servidoresPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling servidoresPartialUpdate.');
            }
            const localVarPath = `/servidores/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServidorV2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling servidoresRead.');
            }
            const localVarPath = `/servidores/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServidorV2} body 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresUpdate(body: ServidorV2, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling servidoresUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling servidoresUpdate.');
            }
            const localVarPath = `/servidores/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServidorV2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServidoresApi - functional programming interface
 * @export
 */
export const ServidoresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServidorV2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresCreate(body: ServidorV2, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServidorV2> {
            const localVarFetchArgs = ServidoresApiFetchParamCreator(configuration).servidoresCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ServidoresApiFetchParamCreator(configuration).servidoresDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [cpf] 
         * @param {string} [comarca] 
         * @param {string} [nome] 
         * @param {string} [papel] 
         * @param {string} [matricula] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresList(id?: number, cpf?: string, comarca?: string, nome?: string, papel?: string, matricula?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200126> {
            const localVarFetchArgs = ServidoresApiFetchParamCreator(configuration).servidoresList(id, cpf, comarca, nome, papel, matricula, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ServidorV2} body 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresPartialUpdate(body: ServidorV2, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServidorV2> {
            const localVarFetchArgs = ServidoresApiFetchParamCreator(configuration).servidoresPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServidorV2> {
            const localVarFetchArgs = ServidoresApiFetchParamCreator(configuration).servidoresRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ServidorV2} body 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresUpdate(body: ServidorV2, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServidorV2> {
            const localVarFetchArgs = ServidoresApiFetchParamCreator(configuration).servidoresUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ServidoresApi - factory interface
 * @export
 */
export const ServidoresApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ServidorV2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresCreate(body: ServidorV2, options?: any) {
            return ServidoresApiFp(configuration).servidoresCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresDelete(id: number, options?: any) {
            return ServidoresApiFp(configuration).servidoresDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [cpf] 
         * @param {string} [comarca] 
         * @param {string} [nome] 
         * @param {string} [papel] 
         * @param {string} [matricula] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresList(id?: number, cpf?: string, comarca?: string, nome?: string, papel?: string, matricula?: string, limit?: number, offset?: number, options?: any) {
            return ServidoresApiFp(configuration).servidoresList(id, cpf, comarca, nome, papel, matricula, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ServidorV2} body 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresPartialUpdate(body: ServidorV2, id: number, options?: any) {
            return ServidoresApiFp(configuration).servidoresPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresRead(id: number, options?: any) {
            return ServidoresApiFp(configuration).servidoresRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ServidorV2} body 
         * @param {number} id A unique integer value identifying this Servidor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servidoresUpdate(body: ServidorV2, id: number, options?: any) {
            return ServidoresApiFp(configuration).servidoresUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ServidoresApi - object-oriented interface
 * @export
 * @class ServidoresApi
 * @extends {BaseAPI}
 */
export class ServidoresApi extends BaseAPI {
    /**
     * 
     * @param {ServidorV2} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServidoresApi
     */
    public servidoresCreate(body: ServidorV2, options?: any) {
        return ServidoresApiFp(this.configuration).servidoresCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Servidor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServidoresApi
     */
    public servidoresDelete(id: number, options?: any) {
        return ServidoresApiFp(this.configuration).servidoresDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {string} [cpf] 
     * @param {string} [comarca] 
     * @param {string} [nome] 
     * @param {string} [papel] 
     * @param {string} [matricula] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServidoresApi
     */
    public servidoresList(id?: number, cpf?: string, comarca?: string, nome?: string, papel?: string, matricula?: string, limit?: number, offset?: number, options?: any) {
        return ServidoresApiFp(this.configuration).servidoresList(id, cpf, comarca, nome, papel, matricula, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ServidorV2} body 
     * @param {number} id A unique integer value identifying this Servidor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServidoresApi
     */
    public servidoresPartialUpdate(body: ServidorV2, id: number, options?: any) {
        return ServidoresApiFp(this.configuration).servidoresPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Servidor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServidoresApi
     */
    public servidoresRead(id: number, options?: any) {
        return ServidoresApiFp(this.configuration).servidoresRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ServidorV2} body 
     * @param {number} id A unique integer value identifying this Servidor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServidoresApi
     */
    public servidoresUpdate(body: ServidorV2, id: number, options?: any) {
        return ServidoresApiFp(this.configuration).servidoresUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * SistemasWebserviceApi - fetch parameter creator
 * @export
 */
export const SistemasWebserviceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceCreate(body: SistemaWebService, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sistemasWebserviceCreate.');
            }
            const localVarPath = `/sistemas-webservice/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SistemaWebService" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sistemasWebserviceDelete.');
            }
            const localVarPath = `/sistemas-webservice/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/sistemas-webservice/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebservicePartialUpdate(body: SistemaWebService, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sistemasWebservicePartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sistemasWebservicePartialUpdate.');
            }
            const localVarPath = `/sistemas-webservice/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SistemaWebService" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sistemasWebserviceRead.');
            }
            const localVarPath = `/sistemas-webservice/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceUpdate(body: SistemaWebService, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sistemasWebserviceUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sistemasWebserviceUpdate.');
            }
            const localVarPath = `/sistemas-webservice/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SistemaWebService" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SistemasWebserviceApi - functional programming interface
 * @export
 */
export const SistemasWebserviceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceCreate(body: SistemaWebService, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SistemaWebService> {
            const localVarFetchArgs = SistemasWebserviceApiFetchParamCreator(configuration).sistemasWebserviceCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SistemasWebserviceApiFetchParamCreator(configuration).sistemasWebserviceDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = SistemasWebserviceApiFetchParamCreator(configuration).sistemasWebserviceList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebservicePartialUpdate(body: SistemaWebService, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SistemaWebService> {
            const localVarFetchArgs = SistemasWebserviceApiFetchParamCreator(configuration).sistemasWebservicePartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SistemaWebService> {
            const localVarFetchArgs = SistemasWebserviceApiFetchParamCreator(configuration).sistemasWebserviceRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceUpdate(body: SistemaWebService, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SistemaWebService> {
            const localVarFetchArgs = SistemasWebserviceApiFetchParamCreator(configuration).sistemasWebserviceUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SistemasWebserviceApi - factory interface
 * @export
 */
export const SistemasWebserviceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceCreate(body: SistemaWebService, options?: any) {
            return SistemasWebserviceApiFp(configuration).sistemasWebserviceCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceDelete(id: number, options?: any) {
            return SistemasWebserviceApiFp(configuration).sistemasWebserviceDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceList(limit?: number, offset?: number, options?: any) {
            return SistemasWebserviceApiFp(configuration).sistemasWebserviceList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebservicePartialUpdate(body: SistemaWebService, id: number, options?: any) {
            return SistemasWebserviceApiFp(configuration).sistemasWebservicePartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceRead(id: number, options?: any) {
            return SistemasWebserviceApiFp(configuration).sistemasWebserviceRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SistemaWebService} body 
         * @param {number} id A unique integer value identifying this Sistema Web Service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sistemasWebserviceUpdate(body: SistemaWebService, id: number, options?: any) {
            return SistemasWebserviceApiFp(configuration).sistemasWebserviceUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * SistemasWebserviceApi - object-oriented interface
 * @export
 * @class SistemasWebserviceApi
 * @extends {BaseAPI}
 */
export class SistemasWebserviceApi extends BaseAPI {
    /**
     * 
     * @param {SistemaWebService} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SistemasWebserviceApi
     */
    public sistemasWebserviceCreate(body: SistemaWebService, options?: any) {
        return SistemasWebserviceApiFp(this.configuration).sistemasWebserviceCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Sistema Web Service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SistemasWebserviceApi
     */
    public sistemasWebserviceDelete(id: number, options?: any) {
        return SistemasWebserviceApiFp(this.configuration).sistemasWebserviceDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SistemasWebserviceApi
     */
    public sistemasWebserviceList(limit?: number, offset?: number, options?: any) {
        return SistemasWebserviceApiFp(this.configuration).sistemasWebserviceList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SistemaWebService} body 
     * @param {number} id A unique integer value identifying this Sistema Web Service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SistemasWebserviceApi
     */
    public sistemasWebservicePartialUpdate(body: SistemaWebService, id: number, options?: any) {
        return SistemasWebserviceApiFp(this.configuration).sistemasWebservicePartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Sistema Web Service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SistemasWebserviceApi
     */
    public sistemasWebserviceRead(id: number, options?: any) {
        return SistemasWebserviceApiFp(this.configuration).sistemasWebserviceRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SistemaWebService} body 
     * @param {number} id A unique integer value identifying this Sistema Web Service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SistemasWebserviceApi
     */
    public sistemasWebserviceUpdate(body: SistemaWebService, id: number, options?: any) {
        return SistemasWebserviceApiFp(this.configuration).sistemasWebserviceUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * SituacoesApi - fetch parameter creator
 * @export
 */
export const SituacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Situacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesCreate(body: Situacao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling situacoesCreate.');
            }
            const localVarPath = `/situacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Situacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling situacoesDelete.');
            }
            const localVarPath = `/situacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/situacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Situacao} body 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesPartialUpdate(body: Situacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling situacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling situacoesPartialUpdate.');
            }
            const localVarPath = `/situacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Situacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling situacoesRead.');
            }
            const localVarPath = `/situacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Situacao} body 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesUpdate(body: Situacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling situacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling situacoesUpdate.');
            }
            const localVarPath = `/situacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Situacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SituacoesApi - functional programming interface
 * @export
 */
export const SituacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Situacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesCreate(body: Situacao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Situacao> {
            const localVarFetchArgs = SituacoesApiFetchParamCreator(configuration).situacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SituacoesApiFetchParamCreator(configuration).situacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200127> {
            const localVarFetchArgs = SituacoesApiFetchParamCreator(configuration).situacoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Situacao} body 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesPartialUpdate(body: Situacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Situacao> {
            const localVarFetchArgs = SituacoesApiFetchParamCreator(configuration).situacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Situacao> {
            const localVarFetchArgs = SituacoesApiFetchParamCreator(configuration).situacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Situacao} body 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesUpdate(body: Situacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Situacao> {
            const localVarFetchArgs = SituacoesApiFetchParamCreator(configuration).situacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SituacoesApi - factory interface
 * @export
 */
export const SituacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Situacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesCreate(body: Situacao, options?: any) {
            return SituacoesApiFp(configuration).situacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesDelete(id: number, options?: any) {
            return SituacoesApiFp(configuration).situacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesList(limit?: number, offset?: number, options?: any) {
            return SituacoesApiFp(configuration).situacoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Situacao} body 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesPartialUpdate(body: Situacao, id: number, options?: any) {
            return SituacoesApiFp(configuration).situacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesRead(id: number, options?: any) {
            return SituacoesApiFp(configuration).situacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Situacao} body 
         * @param {number} id A unique integer value identifying this Situação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        situacoesUpdate(body: Situacao, id: number, options?: any) {
            return SituacoesApiFp(configuration).situacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * SituacoesApi - object-oriented interface
 * @export
 * @class SituacoesApi
 * @extends {BaseAPI}
 */
export class SituacoesApi extends BaseAPI {
    /**
     * 
     * @param {Situacao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SituacoesApi
     */
    public situacoesCreate(body: Situacao, options?: any) {
        return SituacoesApiFp(this.configuration).situacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Situação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SituacoesApi
     */
    public situacoesDelete(id: number, options?: any) {
        return SituacoesApiFp(this.configuration).situacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SituacoesApi
     */
    public situacoesList(limit?: number, offset?: number, options?: any) {
        return SituacoesApiFp(this.configuration).situacoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Situacao} body 
     * @param {number} id A unique integer value identifying this Situação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SituacoesApi
     */
    public situacoesPartialUpdate(body: Situacao, id: number, options?: any) {
        return SituacoesApiFp(this.configuration).situacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Situação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SituacoesApi
     */
    public situacoesRead(id: number, options?: any) {
        return SituacoesApiFp(this.configuration).situacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Situacao} body 
     * @param {number} id A unique integer value identifying this Situação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SituacoesApi
     */
    public situacoesUpdate(body: Situacao, id: number, options?: any) {
        return SituacoesApiFp(this.configuration).situacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * SolturasApi - fetch parameter creator
 * @export
 */
export const SolturasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Soltura} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasCreate(body: Soltura, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling solturasCreate.');
            }
            const localVarPath = `/solturas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Soltura" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling solturasDelete.');
            }
            const localVarPath = `/solturas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/solturas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Soltura} body 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasPartialUpdate(body: Soltura, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling solturasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling solturasPartialUpdate.');
            }
            const localVarPath = `/solturas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Soltura" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling solturasRead.');
            }
            const localVarPath = `/solturas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Soltura} body 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasUpdate(body: Soltura, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling solturasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling solturasUpdate.');
            }
            const localVarPath = `/solturas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Soltura" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SolturasApi - functional programming interface
 * @export
 */
export const SolturasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Soltura} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasCreate(body: Soltura, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Soltura> {
            const localVarFetchArgs = SolturasApiFetchParamCreator(configuration).solturasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SolturasApiFetchParamCreator(configuration).solturasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200128> {
            const localVarFetchArgs = SolturasApiFetchParamCreator(configuration).solturasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Soltura} body 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasPartialUpdate(body: Soltura, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Soltura> {
            const localVarFetchArgs = SolturasApiFetchParamCreator(configuration).solturasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Soltura> {
            const localVarFetchArgs = SolturasApiFetchParamCreator(configuration).solturasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Soltura} body 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasUpdate(body: Soltura, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Soltura> {
            const localVarFetchArgs = SolturasApiFetchParamCreator(configuration).solturasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SolturasApi - factory interface
 * @export
 */
export const SolturasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Soltura} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasCreate(body: Soltura, options?: any) {
            return SolturasApiFp(configuration).solturasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasDelete(id: number, options?: any) {
            return SolturasApiFp(configuration).solturasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasList(limit?: number, offset?: number, options?: any) {
            return SolturasApiFp(configuration).solturasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Soltura} body 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasPartialUpdate(body: Soltura, id: number, options?: any) {
            return SolturasApiFp(configuration).solturasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasRead(id: number, options?: any) {
            return SolturasApiFp(configuration).solturasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Soltura} body 
         * @param {number} id A unique integer value identifying this soltura.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        solturasUpdate(body: Soltura, id: number, options?: any) {
            return SolturasApiFp(configuration).solturasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * SolturasApi - object-oriented interface
 * @export
 * @class SolturasApi
 * @extends {BaseAPI}
 */
export class SolturasApi extends BaseAPI {
    /**
     * 
     * @param {Soltura} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolturasApi
     */
    public solturasCreate(body: Soltura, options?: any) {
        return SolturasApiFp(this.configuration).solturasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this soltura.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolturasApi
     */
    public solturasDelete(id: number, options?: any) {
        return SolturasApiFp(this.configuration).solturasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolturasApi
     */
    public solturasList(limit?: number, offset?: number, options?: any) {
        return SolturasApiFp(this.configuration).solturasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Soltura} body 
     * @param {number} id A unique integer value identifying this soltura.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolturasApi
     */
    public solturasPartialUpdate(body: Soltura, id: number, options?: any) {
        return SolturasApiFp(this.configuration).solturasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this soltura.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolturasApi
     */
    public solturasRead(id: number, options?: any) {
        return SolturasApiFp(this.configuration).solturasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Soltura} body 
     * @param {number} id A unique integer value identifying this soltura.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolturasApi
     */
    public solturasUpdate(body: Soltura, id: number, options?: any) {
        return SolturasApiFp(this.configuration).solturasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TarefasApi - fetch parameter creator
 * @export
 */
export const TarefasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Tarefa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasCreate(body: Tarefa, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tarefasCreate.');
            }
            const localVarPath = `/tarefas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tarefa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tarefasDelete.');
            }
            const localVarPath = `/tarefas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tarefas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tarefa} body 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasPartialUpdate(body: Tarefa, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tarefasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tarefasPartialUpdate.');
            }
            const localVarPath = `/tarefas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tarefa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tarefasRead.');
            }
            const localVarPath = `/tarefas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tarefa} body 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasUpdate(body: Tarefa, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tarefasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tarefasUpdate.');
            }
            const localVarPath = `/tarefas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tarefa" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TarefasApi - functional programming interface
 * @export
 */
export const TarefasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Tarefa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasCreate(body: Tarefa, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tarefa> {
            const localVarFetchArgs = TarefasApiFetchParamCreator(configuration).tarefasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TarefasApiFetchParamCreator(configuration).tarefasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200129> {
            const localVarFetchArgs = TarefasApiFetchParamCreator(configuration).tarefasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Tarefa} body 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasPartialUpdate(body: Tarefa, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tarefa> {
            const localVarFetchArgs = TarefasApiFetchParamCreator(configuration).tarefasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tarefa> {
            const localVarFetchArgs = TarefasApiFetchParamCreator(configuration).tarefasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Tarefa} body 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasUpdate(body: Tarefa, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tarefa> {
            const localVarFetchArgs = TarefasApiFetchParamCreator(configuration).tarefasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TarefasApi - factory interface
 * @export
 */
export const TarefasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Tarefa} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasCreate(body: Tarefa, options?: any) {
            return TarefasApiFp(configuration).tarefasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasDelete(id: number, options?: any) {
            return TarefasApiFp(configuration).tarefasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasList(limit?: number, offset?: number, options?: any) {
            return TarefasApiFp(configuration).tarefasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Tarefa} body 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasPartialUpdate(body: Tarefa, id: number, options?: any) {
            return TarefasApiFp(configuration).tarefasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasRead(id: number, options?: any) {
            return TarefasApiFp(configuration).tarefasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Tarefa} body 
         * @param {number} id A unique integer value identifying this tarefa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tarefasUpdate(body: Tarefa, id: number, options?: any) {
            return TarefasApiFp(configuration).tarefasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TarefasApi - object-oriented interface
 * @export
 * @class TarefasApi
 * @extends {BaseAPI}
 */
export class TarefasApi extends BaseAPI {
    /**
     * 
     * @param {Tarefa} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TarefasApi
     */
    public tarefasCreate(body: Tarefa, options?: any) {
        return TarefasApiFp(this.configuration).tarefasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this tarefa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TarefasApi
     */
    public tarefasDelete(id: number, options?: any) {
        return TarefasApiFp(this.configuration).tarefasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TarefasApi
     */
    public tarefasList(limit?: number, offset?: number, options?: any) {
        return TarefasApiFp(this.configuration).tarefasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Tarefa} body 
     * @param {number} id A unique integer value identifying this tarefa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TarefasApi
     */
    public tarefasPartialUpdate(body: Tarefa, id: number, options?: any) {
        return TarefasApiFp(this.configuration).tarefasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this tarefa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TarefasApi
     */
    public tarefasRead(id: number, options?: any) {
        return TarefasApiFp(this.configuration).tarefasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Tarefa} body 
     * @param {number} id A unique integer value identifying this tarefa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TarefasApi
     */
    public tarefasUpdate(body: Tarefa, id: number, options?: any) {
        return TarefasApiFp(this.configuration).tarefasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TelefonesApi - fetch parameter creator
 * @export
 */
export const TelefonesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesCreate(body: ContribTelefone, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling telefonesCreate.');
            }
            const localVarPath = `/telefones/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribTelefone" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling telefonesDelete.');
            }
            const localVarPath = `/telefones/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/telefones/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesPartialUpdate(body: ContribTelefone, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling telefonesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling telefonesPartialUpdate.');
            }
            const localVarPath = `/telefones/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribTelefone" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling telefonesRead.');
            }
            const localVarPath = `/telefones/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesUpdate(body: ContribTelefone, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling telefonesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling telefonesUpdate.');
            }
            const localVarPath = `/telefones/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContribTelefone" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelefonesApi - functional programming interface
 * @export
 */
export const TelefonesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesCreate(body: ContribTelefone, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribTelefone> {
            const localVarFetchArgs = TelefonesApiFetchParamCreator(configuration).telefonesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TelefonesApiFetchParamCreator(configuration).telefonesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200130> {
            const localVarFetchArgs = TelefonesApiFetchParamCreator(configuration).telefonesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesPartialUpdate(body: ContribTelefone, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribTelefone> {
            const localVarFetchArgs = TelefonesApiFetchParamCreator(configuration).telefonesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribTelefone> {
            const localVarFetchArgs = TelefonesApiFetchParamCreator(configuration).telefonesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesUpdate(body: ContribTelefone, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContribTelefone> {
            const localVarFetchArgs = TelefonesApiFetchParamCreator(configuration).telefonesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TelefonesApi - factory interface
 * @export
 */
export const TelefonesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesCreate(body: ContribTelefone, options?: any) {
            return TelefonesApiFp(configuration).telefonesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesDelete(id: number, options?: any) {
            return TelefonesApiFp(configuration).telefonesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesList(limit?: number, offset?: number, options?: any) {
            return TelefonesApiFp(configuration).telefonesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesPartialUpdate(body: ContribTelefone, id: number, options?: any) {
            return TelefonesApiFp(configuration).telefonesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesRead(id: number, options?: any) {
            return TelefonesApiFp(configuration).telefonesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ContribTelefone} body 
         * @param {number} id A unique integer value identifying this Telefone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telefonesUpdate(body: ContribTelefone, id: number, options?: any) {
            return TelefonesApiFp(configuration).telefonesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TelefonesApi - object-oriented interface
 * @export
 * @class TelefonesApi
 * @extends {BaseAPI}
 */
export class TelefonesApi extends BaseAPI {
    /**
     * 
     * @param {ContribTelefone} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelefonesApi
     */
    public telefonesCreate(body: ContribTelefone, options?: any) {
        return TelefonesApiFp(this.configuration).telefonesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Telefone.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelefonesApi
     */
    public telefonesDelete(id: number, options?: any) {
        return TelefonesApiFp(this.configuration).telefonesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelefonesApi
     */
    public telefonesList(limit?: number, offset?: number, options?: any) {
        return TelefonesApiFp(this.configuration).telefonesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ContribTelefone} body 
     * @param {number} id A unique integer value identifying this Telefone.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelefonesApi
     */
    public telefonesPartialUpdate(body: ContribTelefone, id: number, options?: any) {
        return TelefonesApiFp(this.configuration).telefonesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Telefone.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelefonesApi
     */
    public telefonesRead(id: number, options?: any) {
        return TelefonesApiFp(this.configuration).telefonesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ContribTelefone} body 
     * @param {number} id A unique integer value identifying this Telefone.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelefonesApi
     */
    public telefonesUpdate(body: ContribTelefone, id: number, options?: any) {
        return TelefonesApiFp(this.configuration).telefonesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TermosApi - fetch parameter creator
 * @export
 */
export const TermosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Termo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosCreate(body: Termo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling termosCreate.');
            }
            const localVarPath = `/termos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Termo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling termosDelete.');
            }
            const localVarPath = `/termos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/termos/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Termo} body 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosPartialUpdate(body: Termo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling termosPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling termosPartialUpdate.');
            }
            const localVarPath = `/termos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Termo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling termosRead.');
            }
            const localVarPath = `/termos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Termo} body 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosUpdate(body: Termo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling termosUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling termosUpdate.');
            }
            const localVarPath = `/termos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Termo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TermosApi - functional programming interface
 * @export
 */
export const TermosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Termo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosCreate(body: Termo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Termo> {
            const localVarFetchArgs = TermosApiFetchParamCreator(configuration).termosCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TermosApiFetchParamCreator(configuration).termosDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200132> {
            const localVarFetchArgs = TermosApiFetchParamCreator(configuration).termosList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Termo} body 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosPartialUpdate(body: Termo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Termo> {
            const localVarFetchArgs = TermosApiFetchParamCreator(configuration).termosPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Termo> {
            const localVarFetchArgs = TermosApiFetchParamCreator(configuration).termosRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Termo} body 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosUpdate(body: Termo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Termo> {
            const localVarFetchArgs = TermosApiFetchParamCreator(configuration).termosUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TermosApi - factory interface
 * @export
 */
export const TermosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Termo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosCreate(body: Termo, options?: any) {
            return TermosApiFp(configuration).termosCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosDelete(id: number, options?: any) {
            return TermosApiFp(configuration).termosDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosList(limit?: number, offset?: number, options?: any) {
            return TermosApiFp(configuration).termosList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Termo} body 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosPartialUpdate(body: Termo, id: number, options?: any) {
            return TermosApiFp(configuration).termosPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRead(id: number, options?: any) {
            return TermosApiFp(configuration).termosRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Termo} body 
         * @param {number} id A unique integer value identifying this Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosUpdate(body: Termo, id: number, options?: any) {
            return TermosApiFp(configuration).termosUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TermosApi - object-oriented interface
 * @export
 * @class TermosApi
 * @extends {BaseAPI}
 */
export class TermosApi extends BaseAPI {
    /**
     * 
     * @param {Termo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosApi
     */
    public termosCreate(body: Termo, options?: any) {
        return TermosApiFp(this.configuration).termosCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Termo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosApi
     */
    public termosDelete(id: number, options?: any) {
        return TermosApiFp(this.configuration).termosDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosApi
     */
    public termosList(limit?: number, offset?: number, options?: any) {
        return TermosApiFp(this.configuration).termosList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Termo} body 
     * @param {number} id A unique integer value identifying this Termo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosApi
     */
    public termosPartialUpdate(body: Termo, id: number, options?: any) {
        return TermosApiFp(this.configuration).termosPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Termo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosApi
     */
    public termosRead(id: number, options?: any) {
        return TermosApiFp(this.configuration).termosRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Termo} body 
     * @param {number} id A unique integer value identifying this Termo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosApi
     */
    public termosUpdate(body: Termo, id: number, options?: any) {
        return TermosApiFp(this.configuration).termosUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TermosRespostasApi - fetch parameter creator
 * @export
 */
export const TermosRespostasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TermoResposta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasCreate(body: TermoResposta, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling termosRespostasCreate.');
            }
            const localVarPath = `/termos-respostas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TermoResposta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling termosRespostasDelete.');
            }
            const localVarPath = `/termos-respostas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/termos-respostas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TermoResposta} body 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasPartialUpdate(body: TermoResposta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling termosRespostasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling termosRespostasPartialUpdate.');
            }
            const localVarPath = `/termos-respostas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TermoResposta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling termosRespostasRead.');
            }
            const localVarPath = `/termos-respostas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TermoResposta} body 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasUpdate(body: TermoResposta, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling termosRespostasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling termosRespostasUpdate.');
            }
            const localVarPath = `/termos-respostas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TermoResposta" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TermosRespostasApi - functional programming interface
 * @export
 */
export const TermosRespostasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TermoResposta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasCreate(body: TermoResposta, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TermoResposta> {
            const localVarFetchArgs = TermosRespostasApiFetchParamCreator(configuration).termosRespostasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TermosRespostasApiFetchParamCreator(configuration).termosRespostasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200131> {
            const localVarFetchArgs = TermosRespostasApiFetchParamCreator(configuration).termosRespostasList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TermoResposta} body 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasPartialUpdate(body: TermoResposta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TermoResposta> {
            const localVarFetchArgs = TermosRespostasApiFetchParamCreator(configuration).termosRespostasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TermoResposta> {
            const localVarFetchArgs = TermosRespostasApiFetchParamCreator(configuration).termosRespostasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TermoResposta} body 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasUpdate(body: TermoResposta, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TermoResposta> {
            const localVarFetchArgs = TermosRespostasApiFetchParamCreator(configuration).termosRespostasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TermosRespostasApi - factory interface
 * @export
 */
export const TermosRespostasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TermoResposta} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasCreate(body: TermoResposta, options?: any) {
            return TermosRespostasApiFp(configuration).termosRespostasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasDelete(id: number, options?: any) {
            return TermosRespostasApiFp(configuration).termosRespostasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasList(limit?: number, offset?: number, options?: any) {
            return TermosRespostasApiFp(configuration).termosRespostasList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TermoResposta} body 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasPartialUpdate(body: TermoResposta, id: number, options?: any) {
            return TermosRespostasApiFp(configuration).termosRespostasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasRead(id: number, options?: any) {
            return TermosRespostasApiFp(configuration).termosRespostasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TermoResposta} body 
         * @param {number} id A unique integer value identifying this Resposta de Termo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termosRespostasUpdate(body: TermoResposta, id: number, options?: any) {
            return TermosRespostasApiFp(configuration).termosRespostasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TermosRespostasApi - object-oriented interface
 * @export
 * @class TermosRespostasApi
 * @extends {BaseAPI}
 */
export class TermosRespostasApi extends BaseAPI {
    /**
     * 
     * @param {TermoResposta} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosRespostasApi
     */
    public termosRespostasCreate(body: TermoResposta, options?: any) {
        return TermosRespostasApiFp(this.configuration).termosRespostasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Resposta de Termo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosRespostasApi
     */
    public termosRespostasDelete(id: number, options?: any) {
        return TermosRespostasApiFp(this.configuration).termosRespostasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosRespostasApi
     */
    public termosRespostasList(limit?: number, offset?: number, options?: any) {
        return TermosRespostasApiFp(this.configuration).termosRespostasList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TermoResposta} body 
     * @param {number} id A unique integer value identifying this Resposta de Termo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosRespostasApi
     */
    public termosRespostasPartialUpdate(body: TermoResposta, id: number, options?: any) {
        return TermosRespostasApiFp(this.configuration).termosRespostasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Resposta de Termo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosRespostasApi
     */
    public termosRespostasRead(id: number, options?: any) {
        return TermosRespostasApiFp(this.configuration).termosRespostasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TermoResposta} body 
     * @param {number} id A unique integer value identifying this Resposta de Termo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermosRespostasApi
     */
    public termosRespostasUpdate(body: TermoResposta, id: number, options?: any) {
        return TermosRespostasApiFp(this.configuration).termosRespostasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TipificacoesApi - fetch parameter creator
 * @export
 */
export const TipificacoesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Tipificacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesCreate(body: Tipificacao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tipificacoesCreate.');
            }
            const localVarPath = `/tipificacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tipificacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tipificacoesDelete.');
            }
            const localVarPath = `/tipificacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tipificacoes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tipificacao} body 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesPartialUpdate(body: Tipificacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tipificacoesPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tipificacoesPartialUpdate.');
            }
            const localVarPath = `/tipificacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tipificacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tipificacoesRead.');
            }
            const localVarPath = `/tipificacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tipificacao} body 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesUpdate(body: Tipificacao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tipificacoesUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tipificacoesUpdate.');
            }
            const localVarPath = `/tipificacoes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tipificacao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TipificacoesApi - functional programming interface
 * @export
 */
export const TipificacoesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Tipificacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesCreate(body: Tipificacao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tipificacao> {
            const localVarFetchArgs = TipificacoesApiFetchParamCreator(configuration).tipificacoesCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TipificacoesApiFetchParamCreator(configuration).tipificacoesDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200133> {
            const localVarFetchArgs = TipificacoesApiFetchParamCreator(configuration).tipificacoesList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Tipificacao} body 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesPartialUpdate(body: Tipificacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tipificacao> {
            const localVarFetchArgs = TipificacoesApiFetchParamCreator(configuration).tipificacoesPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tipificacao> {
            const localVarFetchArgs = TipificacoesApiFetchParamCreator(configuration).tipificacoesRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Tipificacao} body 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesUpdate(body: Tipificacao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tipificacao> {
            const localVarFetchArgs = TipificacoesApiFetchParamCreator(configuration).tipificacoesUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TipificacoesApi - factory interface
 * @export
 */
export const TipificacoesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Tipificacao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesCreate(body: Tipificacao, options?: any) {
            return TipificacoesApiFp(configuration).tipificacoesCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesDelete(id: number, options?: any) {
            return TipificacoesApiFp(configuration).tipificacoesDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesList(limit?: number, offset?: number, options?: any) {
            return TipificacoesApiFp(configuration).tipificacoesList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Tipificacao} body 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesPartialUpdate(body: Tipificacao, id: number, options?: any) {
            return TipificacoesApiFp(configuration).tipificacoesPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesRead(id: number, options?: any) {
            return TipificacoesApiFp(configuration).tipificacoesRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Tipificacao} body 
         * @param {number} id A unique integer value identifying this Tipificação.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipificacoesUpdate(body: Tipificacao, id: number, options?: any) {
            return TipificacoesApiFp(configuration).tipificacoesUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TipificacoesApi - object-oriented interface
 * @export
 * @class TipificacoesApi
 * @extends {BaseAPI}
 */
export class TipificacoesApi extends BaseAPI {
    /**
     * 
     * @param {Tipificacao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipificacoesApi
     */
    public tipificacoesCreate(body: Tipificacao, options?: any) {
        return TipificacoesApiFp(this.configuration).tipificacoesCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipificação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipificacoesApi
     */
    public tipificacoesDelete(id: number, options?: any) {
        return TipificacoesApiFp(this.configuration).tipificacoesDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipificacoesApi
     */
    public tipificacoesList(limit?: number, offset?: number, options?: any) {
        return TipificacoesApiFp(this.configuration).tipificacoesList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Tipificacao} body 
     * @param {number} id A unique integer value identifying this Tipificação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipificacoesApi
     */
    public tipificacoesPartialUpdate(body: Tipificacao, id: number, options?: any) {
        return TipificacoesApiFp(this.configuration).tipificacoesPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipificação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipificacoesApi
     */
    public tipificacoesRead(id: number, options?: any) {
        return TipificacoesApiFp(this.configuration).tipificacoesRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Tipificacao} body 
     * @param {number} id A unique integer value identifying this Tipificação.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipificacoesApi
     */
    public tipificacoesUpdate(body: Tipificacao, id: number, options?: any) {
        return TipificacoesApiFp(this.configuration).tipificacoesUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TiposAtividadeExtraordinariaApi - fetch parameter creator
 * @export
 */
export const TiposAtividadeExtraordinariaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaCreate(body: AtividadeExtraordinariaTipo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposAtividadeExtraordinariaCreate.');
            }
            const localVarPath = `/tipos-atividade-extraordinaria/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtividadeExtraordinariaTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposAtividadeExtraordinariaDelete.');
            }
            const localVarPath = `/tipos-atividade-extraordinaria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tipos-atividade-extraordinaria/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaPartialUpdate(body: AtividadeExtraordinariaTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposAtividadeExtraordinariaPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposAtividadeExtraordinariaPartialUpdate.');
            }
            const localVarPath = `/tipos-atividade-extraordinaria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtividadeExtraordinariaTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposAtividadeExtraordinariaRead.');
            }
            const localVarPath = `/tipos-atividade-extraordinaria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaUpdate(body: AtividadeExtraordinariaTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposAtividadeExtraordinariaUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposAtividadeExtraordinariaUpdate.');
            }
            const localVarPath = `/tipos-atividade-extraordinaria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AtividadeExtraordinariaTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TiposAtividadeExtraordinariaApi - functional programming interface
 * @export
 */
export const TiposAtividadeExtraordinariaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaCreate(body: AtividadeExtraordinariaTipo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtividadeExtraordinariaTipo> {
            const localVarFetchArgs = TiposAtividadeExtraordinariaApiFetchParamCreator(configuration).tiposAtividadeExtraordinariaCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TiposAtividadeExtraordinariaApiFetchParamCreator(configuration).tiposAtividadeExtraordinariaDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200134> {
            const localVarFetchArgs = TiposAtividadeExtraordinariaApiFetchParamCreator(configuration).tiposAtividadeExtraordinariaList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaPartialUpdate(body: AtividadeExtraordinariaTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtividadeExtraordinariaTipo> {
            const localVarFetchArgs = TiposAtividadeExtraordinariaApiFetchParamCreator(configuration).tiposAtividadeExtraordinariaPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtividadeExtraordinariaTipo> {
            const localVarFetchArgs = TiposAtividadeExtraordinariaApiFetchParamCreator(configuration).tiposAtividadeExtraordinariaRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaUpdate(body: AtividadeExtraordinariaTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AtividadeExtraordinariaTipo> {
            const localVarFetchArgs = TiposAtividadeExtraordinariaApiFetchParamCreator(configuration).tiposAtividadeExtraordinariaUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TiposAtividadeExtraordinariaApi - factory interface
 * @export
 */
export const TiposAtividadeExtraordinariaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaCreate(body: AtividadeExtraordinariaTipo, options?: any) {
            return TiposAtividadeExtraordinariaApiFp(configuration).tiposAtividadeExtraordinariaCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaDelete(id: number, options?: any) {
            return TiposAtividadeExtraordinariaApiFp(configuration).tiposAtividadeExtraordinariaDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaList(limit?: number, offset?: number, options?: any) {
            return TiposAtividadeExtraordinariaApiFp(configuration).tiposAtividadeExtraordinariaList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaPartialUpdate(body: AtividadeExtraordinariaTipo, id: number, options?: any) {
            return TiposAtividadeExtraordinariaApiFp(configuration).tiposAtividadeExtraordinariaPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaRead(id: number, options?: any) {
            return TiposAtividadeExtraordinariaApiFp(configuration).tiposAtividadeExtraordinariaRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AtividadeExtraordinariaTipo} body 
         * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposAtividadeExtraordinariaUpdate(body: AtividadeExtraordinariaTipo, id: number, options?: any) {
            return TiposAtividadeExtraordinariaApiFp(configuration).tiposAtividadeExtraordinariaUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TiposAtividadeExtraordinariaApi - object-oriented interface
 * @export
 * @class TiposAtividadeExtraordinariaApi
 * @extends {BaseAPI}
 */
export class TiposAtividadeExtraordinariaApi extends BaseAPI {
    /**
     * 
     * @param {AtividadeExtraordinariaTipo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposAtividadeExtraordinariaApi
     */
    public tiposAtividadeExtraordinariaCreate(body: AtividadeExtraordinariaTipo, options?: any) {
        return TiposAtividadeExtraordinariaApiFp(this.configuration).tiposAtividadeExtraordinariaCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposAtividadeExtraordinariaApi
     */
    public tiposAtividadeExtraordinariaDelete(id: number, options?: any) {
        return TiposAtividadeExtraordinariaApiFp(this.configuration).tiposAtividadeExtraordinariaDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposAtividadeExtraordinariaApi
     */
    public tiposAtividadeExtraordinariaList(limit?: number, offset?: number, options?: any) {
        return TiposAtividadeExtraordinariaApiFp(this.configuration).tiposAtividadeExtraordinariaList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtividadeExtraordinariaTipo} body 
     * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposAtividadeExtraordinariaApi
     */
    public tiposAtividadeExtraordinariaPartialUpdate(body: AtividadeExtraordinariaTipo, id: number, options?: any) {
        return TiposAtividadeExtraordinariaApiFp(this.configuration).tiposAtividadeExtraordinariaPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposAtividadeExtraordinariaApi
     */
    public tiposAtividadeExtraordinariaRead(id: number, options?: any) {
        return TiposAtividadeExtraordinariaApiFp(this.configuration).tiposAtividadeExtraordinariaRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AtividadeExtraordinariaTipo} body 
     * @param {number} id A unique integer value identifying this Atividade Extraordinária Tipo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposAtividadeExtraordinariaApi
     */
    public tiposAtividadeExtraordinariaUpdate(body: AtividadeExtraordinariaTipo, id: number, options?: any) {
        return TiposAtividadeExtraordinariaApiFp(this.configuration).tiposAtividadeExtraordinariaUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TiposColetividadeApi - fetch parameter creator
 * @export
 */
export const TiposColetividadeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeCreate(body: TipoColetividade, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposColetividadeCreate.');
            }
            const localVarPath = `/tipos-coletividade/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoColetividade" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposColetividadeDelete.');
            }
            const localVarPath = `/tipos-coletividade/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tipos-coletividade/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadePartialUpdate(body: TipoColetividade, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposColetividadePartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposColetividadePartialUpdate.');
            }
            const localVarPath = `/tipos-coletividade/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoColetividade" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposColetividadeRead.');
            }
            const localVarPath = `/tipos-coletividade/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeUpdate(body: TipoColetividade, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposColetividadeUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposColetividadeUpdate.');
            }
            const localVarPath = `/tipos-coletividade/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoColetividade" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TiposColetividadeApi - functional programming interface
 * @export
 */
export const TiposColetividadeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeCreate(body: TipoColetividade, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoColetividade> {
            const localVarFetchArgs = TiposColetividadeApiFetchParamCreator(configuration).tiposColetividadeCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TiposColetividadeApiFetchParamCreator(configuration).tiposColetividadeDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200135> {
            const localVarFetchArgs = TiposColetividadeApiFetchParamCreator(configuration).tiposColetividadeList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadePartialUpdate(body: TipoColetividade, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoColetividade> {
            const localVarFetchArgs = TiposColetividadeApiFetchParamCreator(configuration).tiposColetividadePartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoColetividade> {
            const localVarFetchArgs = TiposColetividadeApiFetchParamCreator(configuration).tiposColetividadeRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeUpdate(body: TipoColetividade, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoColetividade> {
            const localVarFetchArgs = TiposColetividadeApiFetchParamCreator(configuration).tiposColetividadeUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TiposColetividadeApi - factory interface
 * @export
 */
export const TiposColetividadeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeCreate(body: TipoColetividade, options?: any) {
            return TiposColetividadeApiFp(configuration).tiposColetividadeCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeDelete(id: number, options?: any) {
            return TiposColetividadeApiFp(configuration).tiposColetividadeDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeList(limit?: number, offset?: number, options?: any) {
            return TiposColetividadeApiFp(configuration).tiposColetividadeList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadePartialUpdate(body: TipoColetividade, id: number, options?: any) {
            return TiposColetividadeApiFp(configuration).tiposColetividadePartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeRead(id: number, options?: any) {
            return TiposColetividadeApiFp(configuration).tiposColetividadeRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoColetividade} body 
         * @param {number} id A unique integer value identifying this Tipo de Coletividade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposColetividadeUpdate(body: TipoColetividade, id: number, options?: any) {
            return TiposColetividadeApiFp(configuration).tiposColetividadeUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TiposColetividadeApi - object-oriented interface
 * @export
 * @class TiposColetividadeApi
 * @extends {BaseAPI}
 */
export class TiposColetividadeApi extends BaseAPI {
    /**
     * 
     * @param {TipoColetividade} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposColetividadeApi
     */
    public tiposColetividadeCreate(body: TipoColetividade, options?: any) {
        return TiposColetividadeApiFp(this.configuration).tiposColetividadeCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Coletividade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposColetividadeApi
     */
    public tiposColetividadeDelete(id: number, options?: any) {
        return TiposColetividadeApiFp(this.configuration).tiposColetividadeDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposColetividadeApi
     */
    public tiposColetividadeList(limit?: number, offset?: number, options?: any) {
        return TiposColetividadeApiFp(this.configuration).tiposColetividadeList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoColetividade} body 
     * @param {number} id A unique integer value identifying this Tipo de Coletividade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposColetividadeApi
     */
    public tiposColetividadePartialUpdate(body: TipoColetividade, id: number, options?: any) {
        return TiposColetividadeApiFp(this.configuration).tiposColetividadePartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Coletividade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposColetividadeApi
     */
    public tiposColetividadeRead(id: number, options?: any) {
        return TiposColetividadeApiFp(this.configuration).tiposColetividadeRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoColetividade} body 
     * @param {number} id A unique integer value identifying this Tipo de Coletividade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposColetividadeApi
     */
    public tiposColetividadeUpdate(body: TipoColetividade, id: number, options?: any) {
        return TiposColetividadeApiFp(this.configuration).tiposColetividadeUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TiposEstabelecimentoPenalApi - fetch parameter creator
 * @export
 */
export const TiposEstabelecimentoPenalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalCreate(body: TipoEstabelecimentoPenal, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposEstabelecimentoPenalCreate.');
            }
            const localVarPath = `/tipos-estabelecimento-penal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoEstabelecimentoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposEstabelecimentoPenalDelete.');
            }
            const localVarPath = `/tipos-estabelecimento-penal/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tipos-estabelecimento-penal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalPartialUpdate(body: TipoEstabelecimentoPenal, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposEstabelecimentoPenalPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposEstabelecimentoPenalPartialUpdate.');
            }
            const localVarPath = `/tipos-estabelecimento-penal/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoEstabelecimentoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposEstabelecimentoPenalRead.');
            }
            const localVarPath = `/tipos-estabelecimento-penal/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalUpdate(body: TipoEstabelecimentoPenal, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposEstabelecimentoPenalUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposEstabelecimentoPenalUpdate.');
            }
            const localVarPath = `/tipos-estabelecimento-penal/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoEstabelecimentoPenal" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TiposEstabelecimentoPenalApi - functional programming interface
 * @export
 */
export const TiposEstabelecimentoPenalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalCreate(body: TipoEstabelecimentoPenal, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoEstabelecimentoPenal> {
            const localVarFetchArgs = TiposEstabelecimentoPenalApiFetchParamCreator(configuration).tiposEstabelecimentoPenalCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TiposEstabelecimentoPenalApiFetchParamCreator(configuration).tiposEstabelecimentoPenalDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200136> {
            const localVarFetchArgs = TiposEstabelecimentoPenalApiFetchParamCreator(configuration).tiposEstabelecimentoPenalList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalPartialUpdate(body: TipoEstabelecimentoPenal, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoEstabelecimentoPenal> {
            const localVarFetchArgs = TiposEstabelecimentoPenalApiFetchParamCreator(configuration).tiposEstabelecimentoPenalPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoEstabelecimentoPenal> {
            const localVarFetchArgs = TiposEstabelecimentoPenalApiFetchParamCreator(configuration).tiposEstabelecimentoPenalRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalUpdate(body: TipoEstabelecimentoPenal, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoEstabelecimentoPenal> {
            const localVarFetchArgs = TiposEstabelecimentoPenalApiFetchParamCreator(configuration).tiposEstabelecimentoPenalUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TiposEstabelecimentoPenalApi - factory interface
 * @export
 */
export const TiposEstabelecimentoPenalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalCreate(body: TipoEstabelecimentoPenal, options?: any) {
            return TiposEstabelecimentoPenalApiFp(configuration).tiposEstabelecimentoPenalCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalDelete(id: number, options?: any) {
            return TiposEstabelecimentoPenalApiFp(configuration).tiposEstabelecimentoPenalDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalList(limit?: number, offset?: number, options?: any) {
            return TiposEstabelecimentoPenalApiFp(configuration).tiposEstabelecimentoPenalList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalPartialUpdate(body: TipoEstabelecimentoPenal, id: number, options?: any) {
            return TiposEstabelecimentoPenalApiFp(configuration).tiposEstabelecimentoPenalPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalRead(id: number, options?: any) {
            return TiposEstabelecimentoPenalApiFp(configuration).tiposEstabelecimentoPenalRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoEstabelecimentoPenal} body 
         * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposEstabelecimentoPenalUpdate(body: TipoEstabelecimentoPenal, id: number, options?: any) {
            return TiposEstabelecimentoPenalApiFp(configuration).tiposEstabelecimentoPenalUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TiposEstabelecimentoPenalApi - object-oriented interface
 * @export
 * @class TiposEstabelecimentoPenalApi
 * @extends {BaseAPI}
 */
export class TiposEstabelecimentoPenalApi extends BaseAPI {
    /**
     * 
     * @param {TipoEstabelecimentoPenal} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposEstabelecimentoPenalApi
     */
    public tiposEstabelecimentoPenalCreate(body: TipoEstabelecimentoPenal, options?: any) {
        return TiposEstabelecimentoPenalApiFp(this.configuration).tiposEstabelecimentoPenalCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposEstabelecimentoPenalApi
     */
    public tiposEstabelecimentoPenalDelete(id: number, options?: any) {
        return TiposEstabelecimentoPenalApiFp(this.configuration).tiposEstabelecimentoPenalDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposEstabelecimentoPenalApi
     */
    public tiposEstabelecimentoPenalList(limit?: number, offset?: number, options?: any) {
        return TiposEstabelecimentoPenalApiFp(this.configuration).tiposEstabelecimentoPenalList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoEstabelecimentoPenal} body 
     * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposEstabelecimentoPenalApi
     */
    public tiposEstabelecimentoPenalPartialUpdate(body: TipoEstabelecimentoPenal, id: number, options?: any) {
        return TiposEstabelecimentoPenalApiFp(this.configuration).tiposEstabelecimentoPenalPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposEstabelecimentoPenalApi
     */
    public tiposEstabelecimentoPenalRead(id: number, options?: any) {
        return TiposEstabelecimentoPenalApiFp(this.configuration).tiposEstabelecimentoPenalRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoEstabelecimentoPenal} body 
     * @param {number} id A unique integer value identifying this Tipo de Estabelecimento Penal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposEstabelecimentoPenalApi
     */
    public tiposEstabelecimentoPenalUpdate(body: TipoEstabelecimentoPenal, id: number, options?: any) {
        return TiposEstabelecimentoPenalApiFp(this.configuration).tiposEstabelecimentoPenalUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TiposPatrimonialApi - fetch parameter creator
 * @export
 */
export const TiposPatrimonialApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialCreate(body: PatrimonialTipo, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposPatrimonialCreate.');
            }
            const localVarPath = `/tipos-patrimonial/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatrimonialTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposPatrimonialDelete.');
            }
            const localVarPath = `/tipos-patrimonial/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tipos-patrimonial/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialPartialUpdate(body: PatrimonialTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposPatrimonialPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposPatrimonialPartialUpdate.');
            }
            const localVarPath = `/tipos-patrimonial/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatrimonialTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposPatrimonialRead.');
            }
            const localVarPath = `/tipos-patrimonial/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialUpdate(body: PatrimonialTipo, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposPatrimonialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposPatrimonialUpdate.');
            }
            const localVarPath = `/tipos-patrimonial/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatrimonialTipo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TiposPatrimonialApi - functional programming interface
 * @export
 */
export const TiposPatrimonialApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialCreate(body: PatrimonialTipo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PatrimonialTipo> {
            const localVarFetchArgs = TiposPatrimonialApiFetchParamCreator(configuration).tiposPatrimonialCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TiposPatrimonialApiFetchParamCreator(configuration).tiposPatrimonialDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200137> {
            const localVarFetchArgs = TiposPatrimonialApiFetchParamCreator(configuration).tiposPatrimonialList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialPartialUpdate(body: PatrimonialTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PatrimonialTipo> {
            const localVarFetchArgs = TiposPatrimonialApiFetchParamCreator(configuration).tiposPatrimonialPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PatrimonialTipo> {
            const localVarFetchArgs = TiposPatrimonialApiFetchParamCreator(configuration).tiposPatrimonialRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialUpdate(body: PatrimonialTipo, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PatrimonialTipo> {
            const localVarFetchArgs = TiposPatrimonialApiFetchParamCreator(configuration).tiposPatrimonialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TiposPatrimonialApi - factory interface
 * @export
 */
export const TiposPatrimonialApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialCreate(body: PatrimonialTipo, options?: any) {
            return TiposPatrimonialApiFp(configuration).tiposPatrimonialCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialDelete(id: number, options?: any) {
            return TiposPatrimonialApiFp(configuration).tiposPatrimonialDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialList(limit?: number, offset?: number, options?: any) {
            return TiposPatrimonialApiFp(configuration).tiposPatrimonialList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialPartialUpdate(body: PatrimonialTipo, id: number, options?: any) {
            return TiposPatrimonialApiFp(configuration).tiposPatrimonialPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialRead(id: number, options?: any) {
            return TiposPatrimonialApiFp(configuration).tiposPatrimonialRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PatrimonialTipo} body 
         * @param {number} id A unique integer value identifying this patrimonial tipo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposPatrimonialUpdate(body: PatrimonialTipo, id: number, options?: any) {
            return TiposPatrimonialApiFp(configuration).tiposPatrimonialUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TiposPatrimonialApi - object-oriented interface
 * @export
 * @class TiposPatrimonialApi
 * @extends {BaseAPI}
 */
export class TiposPatrimonialApi extends BaseAPI {
    /**
     * 
     * @param {PatrimonialTipo} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposPatrimonialApi
     */
    public tiposPatrimonialCreate(body: PatrimonialTipo, options?: any) {
        return TiposPatrimonialApiFp(this.configuration).tiposPatrimonialCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this patrimonial tipo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposPatrimonialApi
     */
    public tiposPatrimonialDelete(id: number, options?: any) {
        return TiposPatrimonialApiFp(this.configuration).tiposPatrimonialDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposPatrimonialApi
     */
    public tiposPatrimonialList(limit?: number, offset?: number, options?: any) {
        return TiposPatrimonialApiFp(this.configuration).tiposPatrimonialList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PatrimonialTipo} body 
     * @param {number} id A unique integer value identifying this patrimonial tipo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposPatrimonialApi
     */
    public tiposPatrimonialPartialUpdate(body: PatrimonialTipo, id: number, options?: any) {
        return TiposPatrimonialApiFp(this.configuration).tiposPatrimonialPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this patrimonial tipo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposPatrimonialApi
     */
    public tiposPatrimonialRead(id: number, options?: any) {
        return TiposPatrimonialApiFp(this.configuration).tiposPatrimonialRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PatrimonialTipo} body 
     * @param {number} id A unique integer value identifying this patrimonial tipo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposPatrimonialApi
     */
    public tiposPatrimonialUpdate(body: PatrimonialTipo, id: number, options?: any) {
        return TiposPatrimonialApiFp(this.configuration).tiposPatrimonialUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TiposRendaApi - fetch parameter creator
 * @export
 */
export const TiposRendaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoRenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaCreate(body: TipoRenda, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposRendaCreate.');
            }
            const localVarPath = `/tipos-renda/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoRenda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposRendaDelete.');
            }
            const localVarPath = `/tipos-renda/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tipos-renda/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoRenda} body 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaPartialUpdate(body: TipoRenda, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposRendaPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposRendaPartialUpdate.');
            }
            const localVarPath = `/tipos-renda/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoRenda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposRendaRead.');
            }
            const localVarPath = `/tipos-renda/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoRenda} body 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaUpdate(body: TipoRenda, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposRendaUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposRendaUpdate.');
            }
            const localVarPath = `/tipos-renda/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoRenda" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TiposRendaApi - functional programming interface
 * @export
 */
export const TiposRendaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoRenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaCreate(body: TipoRenda, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoRenda> {
            const localVarFetchArgs = TiposRendaApiFetchParamCreator(configuration).tiposRendaCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TiposRendaApiFetchParamCreator(configuration).tiposRendaDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200138> {
            const localVarFetchArgs = TiposRendaApiFetchParamCreator(configuration).tiposRendaList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoRenda} body 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaPartialUpdate(body: TipoRenda, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoRenda> {
            const localVarFetchArgs = TiposRendaApiFetchParamCreator(configuration).tiposRendaPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoRenda> {
            const localVarFetchArgs = TiposRendaApiFetchParamCreator(configuration).tiposRendaRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoRenda} body 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaUpdate(body: TipoRenda, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoRenda> {
            const localVarFetchArgs = TiposRendaApiFetchParamCreator(configuration).tiposRendaUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TiposRendaApi - factory interface
 * @export
 */
export const TiposRendaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TipoRenda} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaCreate(body: TipoRenda, options?: any) {
            return TiposRendaApiFp(configuration).tiposRendaCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaDelete(id: number, options?: any) {
            return TiposRendaApiFp(configuration).tiposRendaDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaList(limit?: number, offset?: number, options?: any) {
            return TiposRendaApiFp(configuration).tiposRendaList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoRenda} body 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaPartialUpdate(body: TipoRenda, id: number, options?: any) {
            return TiposRendaApiFp(configuration).tiposRendaPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaRead(id: number, options?: any) {
            return TiposRendaApiFp(configuration).tiposRendaRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoRenda} body 
         * @param {number} id A unique integer value identifying this Tipo de Renda.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposRendaUpdate(body: TipoRenda, id: number, options?: any) {
            return TiposRendaApiFp(configuration).tiposRendaUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TiposRendaApi - object-oriented interface
 * @export
 * @class TiposRendaApi
 * @extends {BaseAPI}
 */
export class TiposRendaApi extends BaseAPI {
    /**
     * 
     * @param {TipoRenda} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposRendaApi
     */
    public tiposRendaCreate(body: TipoRenda, options?: any) {
        return TiposRendaApiFp(this.configuration).tiposRendaCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Renda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposRendaApi
     */
    public tiposRendaDelete(id: number, options?: any) {
        return TiposRendaApiFp(this.configuration).tiposRendaDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposRendaApi
     */
    public tiposRendaList(limit?: number, offset?: number, options?: any) {
        return TiposRendaApiFp(this.configuration).tiposRendaList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoRenda} body 
     * @param {number} id A unique integer value identifying this Tipo de Renda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposRendaApi
     */
    public tiposRendaPartialUpdate(body: TipoRenda, id: number, options?: any) {
        return TiposRendaApiFp(this.configuration).tiposRendaPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Renda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposRendaApi
     */
    public tiposRendaRead(id: number, options?: any) {
        return TiposRendaApiFp(this.configuration).tiposRendaRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoRenda} body 
     * @param {number} id A unique integer value identifying this Tipo de Renda.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposRendaApi
     */
    public tiposRendaUpdate(body: TipoRenda, id: number, options?: any) {
        return TiposRendaApiFp(this.configuration).tiposRendaUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TiposVulnerabilidadeDigitalApi - fetch parameter creator
 * @export
 */
export const TiposVulnerabilidadeDigitalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalCreate(body: TipoVulnerabilidade, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposVulnerabilidadeDigitalCreate.');
            }
            const localVarPath = `/tipos-vulnerabilidade-digital/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoVulnerabilidade" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposVulnerabilidadeDigitalDelete.');
            }
            const localVarPath = `/tipos-vulnerabilidade-digital/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tipos-vulnerabilidade-digital/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalPartialUpdate(body: TipoVulnerabilidade, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposVulnerabilidadeDigitalPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposVulnerabilidadeDigitalPartialUpdate.');
            }
            const localVarPath = `/tipos-vulnerabilidade-digital/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoVulnerabilidade" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposVulnerabilidadeDigitalRead.');
            }
            const localVarPath = `/tipos-vulnerabilidade-digital/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalUpdate(body: TipoVulnerabilidade, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tiposVulnerabilidadeDigitalUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tiposVulnerabilidadeDigitalUpdate.');
            }
            const localVarPath = `/tipos-vulnerabilidade-digital/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TipoVulnerabilidade" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TiposVulnerabilidadeDigitalApi - functional programming interface
 * @export
 */
export const TiposVulnerabilidadeDigitalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalCreate(body: TipoVulnerabilidade, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoVulnerabilidade> {
            const localVarFetchArgs = TiposVulnerabilidadeDigitalApiFetchParamCreator(configuration).tiposVulnerabilidadeDigitalCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TiposVulnerabilidadeDigitalApiFetchParamCreator(configuration).tiposVulnerabilidadeDigitalDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200139> {
            const localVarFetchArgs = TiposVulnerabilidadeDigitalApiFetchParamCreator(configuration).tiposVulnerabilidadeDigitalList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalPartialUpdate(body: TipoVulnerabilidade, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoVulnerabilidade> {
            const localVarFetchArgs = TiposVulnerabilidadeDigitalApiFetchParamCreator(configuration).tiposVulnerabilidadeDigitalPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoVulnerabilidade> {
            const localVarFetchArgs = TiposVulnerabilidadeDigitalApiFetchParamCreator(configuration).tiposVulnerabilidadeDigitalRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalUpdate(body: TipoVulnerabilidade, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TipoVulnerabilidade> {
            const localVarFetchArgs = TiposVulnerabilidadeDigitalApiFetchParamCreator(configuration).tiposVulnerabilidadeDigitalUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TiposVulnerabilidadeDigitalApi - factory interface
 * @export
 */
export const TiposVulnerabilidadeDigitalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalCreate(body: TipoVulnerabilidade, options?: any) {
            return TiposVulnerabilidadeDigitalApiFp(configuration).tiposVulnerabilidadeDigitalCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalDelete(id: number, options?: any) {
            return TiposVulnerabilidadeDigitalApiFp(configuration).tiposVulnerabilidadeDigitalDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalList(limit?: number, offset?: number, options?: any) {
            return TiposVulnerabilidadeDigitalApiFp(configuration).tiposVulnerabilidadeDigitalList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalPartialUpdate(body: TipoVulnerabilidade, id: number, options?: any) {
            return TiposVulnerabilidadeDigitalApiFp(configuration).tiposVulnerabilidadeDigitalPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalRead(id: number, options?: any) {
            return TiposVulnerabilidadeDigitalApiFp(configuration).tiposVulnerabilidadeDigitalRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TipoVulnerabilidade} body 
         * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiposVulnerabilidadeDigitalUpdate(body: TipoVulnerabilidade, id: number, options?: any) {
            return TiposVulnerabilidadeDigitalApiFp(configuration).tiposVulnerabilidadeDigitalUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TiposVulnerabilidadeDigitalApi - object-oriented interface
 * @export
 * @class TiposVulnerabilidadeDigitalApi
 * @extends {BaseAPI}
 */
export class TiposVulnerabilidadeDigitalApi extends BaseAPI {
    /**
     * 
     * @param {TipoVulnerabilidade} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposVulnerabilidadeDigitalApi
     */
    public tiposVulnerabilidadeDigitalCreate(body: TipoVulnerabilidade, options?: any) {
        return TiposVulnerabilidadeDigitalApiFp(this.configuration).tiposVulnerabilidadeDigitalCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposVulnerabilidadeDigitalApi
     */
    public tiposVulnerabilidadeDigitalDelete(id: number, options?: any) {
        return TiposVulnerabilidadeDigitalApiFp(this.configuration).tiposVulnerabilidadeDigitalDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposVulnerabilidadeDigitalApi
     */
    public tiposVulnerabilidadeDigitalList(limit?: number, offset?: number, options?: any) {
        return TiposVulnerabilidadeDigitalApiFp(this.configuration).tiposVulnerabilidadeDigitalList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoVulnerabilidade} body 
     * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposVulnerabilidadeDigitalApi
     */
    public tiposVulnerabilidadeDigitalPartialUpdate(body: TipoVulnerabilidade, id: number, options?: any) {
        return TiposVulnerabilidadeDigitalApiFp(this.configuration).tiposVulnerabilidadeDigitalPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposVulnerabilidadeDigitalApi
     */
    public tiposVulnerabilidadeDigitalRead(id: number, options?: any) {
        return TiposVulnerabilidadeDigitalApiFp(this.configuration).tiposVulnerabilidadeDigitalRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TipoVulnerabilidade} body 
     * @param {number} id A unique integer value identifying this Tipo de Vulnerabilidade Digital.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiposVulnerabilidadeDigitalApi
     */
    public tiposVulnerabilidadeDigitalUpdate(body: TipoVulnerabilidade, id: number, options?: any) {
        return TiposVulnerabilidadeDigitalApiFp(this.configuration).tiposVulnerabilidadeDigitalUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * VagasEditalPlantaoApi - fetch parameter creator
 * @export
 */
export const VagasEditalPlantaoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoCreate(body: VagaEditalPlantao, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling vagasEditalPlantaoCreate.');
            }
            const localVarPath = `/vagas-edital-plantao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VagaEditalPlantao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vagasEditalPlantaoDelete.');
            }
            const localVarPath = `/vagas-edital-plantao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoList(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/vagas-edital-plantao/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoPartialUpdate(body: VagaEditalPlantao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling vagasEditalPlantaoPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vagasEditalPlantaoPartialUpdate.');
            }
            const localVarPath = `/vagas-edital-plantao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VagaEditalPlantao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vagasEditalPlantaoRead.');
            }
            const localVarPath = `/vagas-edital-plantao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoUpdate(body: VagaEditalPlantao, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling vagasEditalPlantaoUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vagasEditalPlantaoUpdate.');
            }
            const localVarPath = `/vagas-edital-plantao/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VagaEditalPlantao" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VagasEditalPlantaoApi - functional programming interface
 * @export
 */
export const VagasEditalPlantaoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoCreate(body: VagaEditalPlantao, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VagaEditalPlantao> {
            const localVarFetchArgs = VagasEditalPlantaoApiFetchParamCreator(configuration).vagasEditalPlantaoCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VagasEditalPlantaoApiFetchParamCreator(configuration).vagasEditalPlantaoDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoList(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200140> {
            const localVarFetchArgs = VagasEditalPlantaoApiFetchParamCreator(configuration).vagasEditalPlantaoList(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoPartialUpdate(body: VagaEditalPlantao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VagaEditalPlantao> {
            const localVarFetchArgs = VagasEditalPlantaoApiFetchParamCreator(configuration).vagasEditalPlantaoPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VagaEditalPlantao> {
            const localVarFetchArgs = VagasEditalPlantaoApiFetchParamCreator(configuration).vagasEditalPlantaoRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoUpdate(body: VagaEditalPlantao, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VagaEditalPlantao> {
            const localVarFetchArgs = VagasEditalPlantaoApiFetchParamCreator(configuration).vagasEditalPlantaoUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VagasEditalPlantaoApi - factory interface
 * @export
 */
export const VagasEditalPlantaoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoCreate(body: VagaEditalPlantao, options?: any) {
            return VagasEditalPlantaoApiFp(configuration).vagasEditalPlantaoCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoDelete(id: number, options?: any) {
            return VagasEditalPlantaoApiFp(configuration).vagasEditalPlantaoDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoList(limit?: number, offset?: number, options?: any) {
            return VagasEditalPlantaoApiFp(configuration).vagasEditalPlantaoList(limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoPartialUpdate(body: VagaEditalPlantao, id: number, options?: any) {
            return VagasEditalPlantaoApiFp(configuration).vagasEditalPlantaoPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoRead(id: number, options?: any) {
            return VagasEditalPlantaoApiFp(configuration).vagasEditalPlantaoRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {VagaEditalPlantao} body 
         * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vagasEditalPlantaoUpdate(body: VagaEditalPlantao, id: number, options?: any) {
            return VagasEditalPlantaoApiFp(configuration).vagasEditalPlantaoUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * VagasEditalPlantaoApi - object-oriented interface
 * @export
 * @class VagasEditalPlantaoApi
 * @extends {BaseAPI}
 */
export class VagasEditalPlantaoApi extends BaseAPI {
    /**
     * 
     * @param {VagaEditalPlantao} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VagasEditalPlantaoApi
     */
    public vagasEditalPlantaoCreate(body: VagaEditalPlantao, options?: any) {
        return VagasEditalPlantaoApiFp(this.configuration).vagasEditalPlantaoCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VagasEditalPlantaoApi
     */
    public vagasEditalPlantaoDelete(id: number, options?: any) {
        return VagasEditalPlantaoApiFp(this.configuration).vagasEditalPlantaoDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VagasEditalPlantaoApi
     */
    public vagasEditalPlantaoList(limit?: number, offset?: number, options?: any) {
        return VagasEditalPlantaoApiFp(this.configuration).vagasEditalPlantaoList(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {VagaEditalPlantao} body 
     * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VagasEditalPlantaoApi
     */
    public vagasEditalPlantaoPartialUpdate(body: VagaEditalPlantao, id: number, options?: any) {
        return VagasEditalPlantaoApiFp(this.configuration).vagasEditalPlantaoPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VagasEditalPlantaoApi
     */
    public vagasEditalPlantaoRead(id: number, options?: any) {
        return VagasEditalPlantaoApiFp(this.configuration).vagasEditalPlantaoRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {VagaEditalPlantao} body 
     * @param {number} id A unique integer value identifying this Vaga para Edital de Plantão.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VagasEditalPlantaoApi
     */
    public vagasEditalPlantaoUpdate(body: VagaEditalPlantao, id: number, options?: any) {
        return VagasEditalPlantaoApiFp(this.configuration).vagasEditalPlantaoUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * VarasApi - fetch parameter creator
 * @export
 */
export const VarasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Vara} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasCreate(body: Vara, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling varasCreate.');
            }
            const localVarPath = `/varas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Vara" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling varasDelete.');
            }
            const localVarPath = `/varas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [grau] 
         * @param {string} [comarca] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasList(grau?: string, comarca?: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/varas/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (grau !== undefined) {
                localVarQueryParameter['grau'] = grau;
            }

            if (comarca !== undefined) {
                localVarQueryParameter['comarca'] = comarca;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Vara} body 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasPartialUpdate(body: Vara, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling varasPartialUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling varasPartialUpdate.');
            }
            const localVarPath = `/varas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Vara" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasRead(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling varasRead.');
            }
            const localVarPath = `/varas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Vara} body 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasUpdate(body: Vara, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling varasUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling varasUpdate.');
            }
            const localVarPath = `/varas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication TokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Vara" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VarasApi - functional programming interface
 * @export
 */
export const VarasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Vara} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasCreate(body: Vara, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vara> {
            const localVarFetchArgs = VarasApiFetchParamCreator(configuration).varasCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VarasApiFetchParamCreator(configuration).varasDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [grau] 
         * @param {string} [comarca] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasList(grau?: string, comarca?: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200141> {
            const localVarFetchArgs = VarasApiFetchParamCreator(configuration).varasList(grau, comarca, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Vara} body 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasPartialUpdate(body: Vara, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vara> {
            const localVarFetchArgs = VarasApiFetchParamCreator(configuration).varasPartialUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasRead(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vara> {
            const localVarFetchArgs = VarasApiFetchParamCreator(configuration).varasRead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Vara} body 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasUpdate(body: Vara, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vara> {
            const localVarFetchArgs = VarasApiFetchParamCreator(configuration).varasUpdate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VarasApi - factory interface
 * @export
 */
export const VarasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Vara} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasCreate(body: Vara, options?: any) {
            return VarasApiFp(configuration).varasCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasDelete(id: number, options?: any) {
            return VarasApiFp(configuration).varasDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [grau] 
         * @param {string} [comarca] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasList(grau?: string, comarca?: string, limit?: number, offset?: number, options?: any) {
            return VarasApiFp(configuration).varasList(grau, comarca, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Vara} body 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasPartialUpdate(body: Vara, id: number, options?: any) {
            return VarasApiFp(configuration).varasPartialUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasRead(id: number, options?: any) {
            return VarasApiFp(configuration).varasRead(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Vara} body 
         * @param {number} id A unique integer value identifying this Vara.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        varasUpdate(body: Vara, id: number, options?: any) {
            return VarasApiFp(configuration).varasUpdate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * VarasApi - object-oriented interface
 * @export
 * @class VarasApi
 * @extends {BaseAPI}
 */
export class VarasApi extends BaseAPI {
    /**
     * 
     * @param {Vara} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VarasApi
     */
    public varasCreate(body: Vara, options?: any) {
        return VarasApiFp(this.configuration).varasCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Vara.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VarasApi
     */
    public varasDelete(id: number, options?: any) {
        return VarasApiFp(this.configuration).varasDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [grau] 
     * @param {string} [comarca] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VarasApi
     */
    public varasList(grau?: string, comarca?: string, limit?: number, offset?: number, options?: any) {
        return VarasApiFp(this.configuration).varasList(grau, comarca, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Vara} body 
     * @param {number} id A unique integer value identifying this Vara.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VarasApi
     */
    public varasPartialUpdate(body: Vara, id: number, options?: any) {
        return VarasApiFp(this.configuration).varasPartialUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Vara.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VarasApi
     */
    public varasRead(id: number, options?: any) {
        return VarasApiFp(this.configuration).varasRead(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Vara} body 
     * @param {number} id A unique integer value identifying this Vara.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VarasApi
     */
    public varasUpdate(body: Vara, id: number, options?: any) {
        return VarasApiFp(this.configuration).varasUpdate(body, id, options)(this.fetch, this.basePath);
    }

}
